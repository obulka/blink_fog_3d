Root {
 inputs 0
 name /home/ob1/software/nuke/blink_fog_3d/examples/test.nk
 format "2048 1556 0 0 2048 1556 1 2K_Super_35(full-ap)"
 proxy_type scale
 proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
 colorManagement Nuke
 workingSpaceLUT linear
 monitorLut sRGB
 int8Lut sRGB
 int16Lut sRGB
 logLut Cineon
 floatLut linear
}
Axis2 {
 inputs 0
 rotate {20 {frame*2} 0}
 name Axis3
 xpos -487
 ypos -443
}
Camera2 {
 translate {0 0 10}
 focal_point 10
 fstop 0.09
 name Camera3
 xpos -487
 ypos -321
}
Dot {
 name Dot5
 xpos -377
 ypos -297
}
set Na5df220 [stack 0]
CheckerBoard2 {
 inputs 0
 name CheckerBoard2
 xpos -358
 ypos -560
}
Dot {
 name Dot4
 xpos -324
 ypos -447
}
set Na59b9e0 [stack 0]
Sphere {
 translate {{curve x1 -1 x20 2} 0 -3}
 uniform_scale 0.5
 name Sphere2
 xpos -358
 ypos -417
}
push $Na59b9e0
Sphere {
 translate {{curve x1 -1 x20 2} 0 0}
 name Sphere1
 xpos -243
 ypos -451
}
Scene {
 inputs 2
 name Scene1
 xpos -233
 ypos -391
}
push 0
ScanlineRender {
 inputs 3
 conservative_shader_sampling false
 overscan 200
 samples 15
 shutteroffset centred
 motion_vectors_type distance
 output_shader_vectors true
 name ScanlineRender2
 xpos -243
 ypos -301
}
Dot {
 name Dot2
 xpos -209
 ypos -229
}
set Na5a53a0 [stack 0]
Dot {
 name Dot1
 xpos -291
 ypos -169
}
push $Na5a53a0
push $Na5df220
Dot {
 name Dot7
 xpos -377
 ypos -95
}
Group {
 inputs 3
 name blink_fog_3d
 knobChanged "\n# Copyright 2022 by Owen Bulka.\n# All rights reserved.\n# This file is released under the \"MIT License Agreement\".\n# Please see the LICENSE.md file that should have been included as part\n# of this package.\nimport logging\n\nimport nuke\n\n_LOGGER = logging.getLogger(\"blink_fog\")\n\n\nclass KnobChangedCallbacks(dict):\n    def register(self, knob_name):\n        def decorated(method):\n            self\[knob_name] = method\n            return method\n        return decorated\n\n    def register_multiple(self, knob_names):\n        def decorated(method):\n            for knob_name in knob_names:\n                self\[knob_name] = method\n            return method\n        return decorated\n\n\nclass KnobManager(object):\n    _knob_changed_callbacks = KnobChangedCallbacks()\n\n    def __init__(self):\n        self._node = nuke.thisNode()\n        self._knob = nuke.thisKnob()\n\n    def handle_node_created(self):\n        self._input_changed()\n\n    def handle_knob_changed(self):\n        knob_name = self._knob.name()\n        try:\n            type(self)._knob_changed_callbacks.get(knob_name)(self)\n        except TypeError:\n            _LOGGER.debug(\"No callbacks for knob: %s\", knob_name)\n\n    @_knob_changed_callbacks.register(\"inputChange\")\n    def _input_changed(self):\n        pass\n\n\nclass BlinkFogKnobManager(KnobManager):\n    _knob_changed_callbacks = KnobChangedCallbacks(KnobManager._knob_changed_callbacks)\n\n    _deep_blender = \"deep_blender\"\n    _input_name = \"Input1\"\n    _deep_merge = \"DeepMerge\"\n    _time_warp = \"TimeWarp\"\n    _expression = \"Expression\"\n    _alpha_expression = \"ExprAlpha\"\n    _deep_from_image = \"DeepFromImage\"\n    _holdout_mode = \"holdout_mode\"\n    _samples_per_ray = \"samples_per_ray\"\n    _rays_per_pixel = \"rays_per_pixel\"\n    _output_deep = \"output_deep\"\n\n    _shape_enable_knobs = \{\n        \"plane\": \"enable_planar_ramp\",\n        \"box\": \"enable_box_ramp\",\n        \"sphere\": \"enable_spherical_ramp\",\n    \}\n    _shape_knobs = \{\n        \"plane\": \[\n            \"plane_point\",\n            \"plane_normal\",\n            \"in\",\n            \"out\",\n            \"in_falloff\",\n            \"out_falloff\",\n            \"plane_div\",\n            \"plane_falloff_power\",\n            \"plane_falloff_offset\",\n        ],\n        \"box\": \[\n            \"box_ramp_position\",\n            \"box_ramp_rotation\",\n            \"width\",\n            \"height\",\n            \"depth\",\n            \"box_falloff_distance\",\n            \"box_falloff_power\",\n            \"box_falloff_offset\",\n        ],\n        \"sphere\": \[\n            \"spherical_ramp_position\",\n            \"spherical_ramp_start_radius\",\n            \"spherical_ramp_end_radius\",\n            \"sphere_falloff_power\",\n            \"sphere_falloff_offset\",\n        ],\n    \}\n\n    def __init__(self):\n        super(BlinkFogKnobManager, self).__init__()\n\n    def _add_deep_samples(self, samples_to_add, current_deep_samples):\n        even = current_deep_samples % 2 == 0\n\n        input_pos = nuke.toNode(self._input_name).knob(\"xpos\").value()\n        time_warp_y_pos = nuke.toNode(self._time_warp + \"0\").knob(\"ypos\").value()\n        node_spacing_x = 150\n        node_spacing_y = 50\n\n        for sample in range(samples_to_add):\n            current_sample = current_deep_samples + sample\n            x_pos = input_pos + current_sample * node_spacing_x\n            if even:\n                time_warp = nuke.nodes.TimeWarp()\n                time_warp.setInput(0, nuke.toNode(self._input_name))\n                time_warp.knob(\"name\").setValue(self._time_warp + \"\{\}\".format(current_sample))\n                time_warp.knob(\"xpos\").setValue(x_pos)\n                time_warp.knob(\"ypos\").setValue(time_warp_y_pos)\n                time_warp.knob(\"filter\").setValue(\"none\")\n                time_warp.knob(\"lookup\").setExpression(\"frame + (1/parent.samples_per_ray*\{\})\".format(current_sample))\n\n                expression = nuke.nodes.Expression()\n                expression.setInput(0, time_warp)\n                expression.knob(\"name\").setValue(self._expression + \"\{\}\".format(current_sample))\n                expression.knob(\"xpos\").setValue(x_pos)\n                expression.knob(\"ypos\").setValue(time_warp_y_pos + node_spacing_y)\n                expression.knob(\"expr0\").setValue(\"r\")\n                expression.knob(\"expr1\").setValue(\"r\")\n                expression.knob(\"expr2\").setValue(\"r\")\n                expression.knob(\"expr3\").setValue(\"1/g\")\n                expression.knob(\"channel3\").setValue(\"depth\")\n\n                alpha_expression = nuke.nodes.Expression()\n                alpha_expression.setInput(0, expression)\n                alpha_expression.knob(\"name\").setValue(self._alpha_expression + \"\{\}\".format(current_sample))\n                alpha_expression.knob(\"xpos\").setValue(x_pos)\n                alpha_expression.knob(\"ypos\").setValue(time_warp_y_pos + 2 * node_spacing_y)\n                alpha_expression.knob(\"expr3\").setValue(\"r\")\n\n                deep_from_image = nuke.nodes.DeepFromImage()\n                deep_from_image.setInput(0, alpha_expression)\n                deep_from_image.knob(\"name\").setValue(self._deep_from_image + \"\{\}\".format(current_sample))\n                deep_from_image.knob(\"xpos\").setValue(x_pos)\n                deep_from_image.knob(\"ypos\").setValue(time_warp_y_pos + 3 * node_spacing_y)\n                deep_from_image.knob(\"premult\").setValue(True)\n\n                deep_merge = nuke.toNode(self._deep_merge)\n                deep_merge.setInput(current_sample, deep_from_image)\n\n            else:\n                time_warp = nuke.toNode(self._time_warp + \"\{\}\".format(current_sample - 1))\n\n                expression = nuke.nodes.Expression()\n                expression.setInput(0, time_warp)\n                expression.knob(\"name\").setValue(self._expression + \"\{\}\".format(current_sample))\n                expression.knob(\"xpos\").setValue(x_pos)\n                expression.knob(\"ypos\").setValue(time_warp_y_pos + node_spacing_y)\n                expression.knob(\"expr0\").setValue(\"b\")\n                expression.knob(\"expr1\").setValue(\"b\")\n                expression.knob(\"expr2\").setValue(\"b\")\n                expression.knob(\"expr3\").setValue(\"1/a\")\n                expression.knob(\"channel3\").setValue(\"depth\")\n\n                alpha_expression = nuke.nodes.Expression()\n                alpha_expression.setInput(0, expression)\n                alpha_expression.knob(\"name\").setValue(self._alpha_expression + \"\{\}\".format(current_sample))\n                alpha_expression.knob(\"xpos\").setValue(x_pos)\n                alpha_expression.knob(\"ypos\").setValue(time_warp_y_pos + 2 * node_spacing_y)\n                alpha_expression.knob(\"expr3\").setValue(\"r\")\n\n                deep_from_image = nuke.nodes.DeepFromImage()\n                deep_from_image.setInput(0, alpha_expression)\n                deep_from_image.knob(\"name\").setValue(self._deep_from_image + \"\{\}\".format(current_sample))\n                deep_from_image.knob(\"xpos\").setValue(x_pos)\n                deep_from_image.knob(\"ypos\").setValue(time_warp_y_pos + 3 * node_spacing_y)\n                deep_from_image.knob(\"premult\").setValue(True)\n\n                deep_merge = nuke.toNode(self._deep_merge)\n                deep_merge.setInput(current_sample, deep_from_image)\n\n            even = not even\n\n    def _remove_deep_samples(self, samples_to_remove, current_deep_samples):\n        even = current_deep_samples % 2 == 1\n\n        for sample in range(current_deep_samples - 1, current_deep_samples - samples_to_remove - 1, -1):\n            if even:\n                time_warp = nuke.toNode(self._time_warp + \"\{\}\".format(sample))\n                time_warp.setInput(0, None)\n                nuke.delete(time_warp)\n\n            expression = nuke.toNode(self._expression + \"\{\}\".format(sample))\n            alpha_expression = nuke.toNode(self._alpha_expression + \"\{\}\".format(sample))\n            deep_from_image = nuke.toNode(self._deep_from_image + \"\{\}\".format(sample))\n\n            nuke.delete(expression)\n            nuke.delete(alpha_expression)\n            nuke.delete(deep_from_image)\n\n            even = not even\n\n    def update_deep_nodes(self):\n        with self._node:\n            with nuke.toNode(self._deep_blender):\n                current_deep_samples = len(nuke.allNodes(filter=\"DeepFromImage\"))\n                samples_per_ray = self._node.knob(self._samples_per_ray).value()\n                deep_samples_to_add = int(samples_per_ray - current_deep_samples)\n\n                if deep_samples_to_add > 0:\n                    self._add_deep_samples(deep_samples_to_add, current_deep_samples)\n                elif deep_samples_to_add < 0 and samples_per_ray > 0:\n                    self._remove_deep_samples(abs(deep_samples_to_add), current_deep_samples)\n\n    @_knob_changed_callbacks.register(\"samples_per_ray\")\n    def _samples_per_ray_changed(self):\n        if self._node.knob(self._holdout_mode).getValue() == 2 or self._node.knob(self._output_deep).value():\n            self.update_deep_nodes()\n\n    @_knob_changed_callbacks.register(\"holdout_mode\")\n    def _holdout_mode_changed(self):\n        with self._node:\n            with nuke.toNode(self._deep_blender):\n                if self._knob.getValue() < 2 and not self._node.knob(self._output_deep).value():\n                    current_deep_samples = len(nuke.allNodes(filter=\"DeepFromImage\"))\n                    self._remove_deep_samples(current_deep_samples - 1, current_deep_samples)\n                else:\n                    self.update_deep_nodes()\n\n    @_knob_changed_callbacks.register(\"output_deep\")\n    def _output_deep_changed(self):\n        with self._node:\n            with nuke.toNode(self._deep_blender):\n                if self._knob.value():\n                    self.update_deep_nodes()\n                elif self._node.knob(self._holdout_mode).getValue() < 2:\n                    current_deep_samples = len(nuke.allNodes(filter=\"DeepFromImage\"))\n                    self._remove_deep_samples(current_deep_samples - 1, current_deep_samples)\n\n    @_knob_changed_callbacks.register(\"shapes\")\n    def _shape_dropdown_changed(self):\n        for shape, knob_name in self._shape_enable_knobs.items():\n            self._node.knob(knob_name).setValue(shape == self._knob.value())\n        for shape, knob_names in self._shape_knobs.items():\n            for knob_name in knob_names:\n                self._node.knob(knob_name).setVisible(shape == self._knob.value())\n\n\nBlinkFogKnobManager().handle_knob_changed()\n"
 tile_color 0x3b004cff
 xpos -243
 ypos -99
 addUserKnob {20 User l BlinkFog3D}
 addUserKnob {26 sampling_settings l "<b>sampling settings"}
 addUserKnob {3 samples_per_ray l "samples per ray" t "This is the most important sampling setting. Increasing this will decrease the distance between samples, reducing noise.\n\nThe number of noise samples to compute per ray. Increase this to reduce flickering/improve quality, though it will run slower with a higher value."}
 samples_per_ray 50
 addUserKnob {3 rays_per_pixel l "rays per pixel" t "The number of rays per pixel to sample noise on. This enables antialiasing as well as cleaning up the noise from sampling depth of field.\n\nNOTE: Increasing this by 1 adds an ADDITIONAL samples_per_ray to the total samples, use with caution, or just leave this at 1"}
 rays_per_pixel 1
 addUserKnob {7 hit_tolerance l "hit tolerance" t "This is the range in which a ray will be considered to have hit a shape, if rendering noise with one of the 'shape' types. This is the initial tolerance, and for speed it is dynamically increased the farther you get from camera. If you are rendering small noise shapes very far away you may need to decrease this." R 1e-06 1}
 hit_tolerance 0.0001
 addUserKnob {7 max_distance l "max distance" t "The maximum distance to sample noise to if an earlier end point cannot be determined." R 1000 1e+08}
 max_distance 100000
 addUserKnob {20 time_blur l "Motion Blur" n 1}
 time_blur 0
 addUserKnob {6 enable_motion_blur l enable t "Enable the motion blur" +STARTLINE}
 addUserKnob {41 divisions T TimeBlur1.divisions}
 addUserKnob {41 shutter T TimeBlur1.shutter}
 addUserKnob {41 shutteroffset l "shutter offset" T TimeBlur1.shutteroffset}
 addUserKnob {41 shuttercustomoffset l "" -STARTLINE T TimeBlur1.shuttercustomoffset}
 addUserKnob {6 depth_of_field l "depth of field" t "Enable depth of field. This will be determined by the focal distance and fstop of the input camera. Increase the rays per pixel to clean up the noise when using this." +STARTLINE}
 addUserKnob {20 endGroup_1 n -1}
 addUserKnob {26 density_settings l "<b>density settings"}
 addUserKnob {7 density t "A multiplier that increases fog density." R 0 10}
 density 0.5
 addUserKnob {20 depth_ramp_1 l "Depth Ramp" t "Ramp to control the density of the fog as depth changes" n 1}
 depth_ramp_1 0
 addUserKnob {6 enable_depth_ramp l "enable depth ramp" t "Enable the depth ramp" +STARTLINE}
 enable_depth_ramp true
 addUserKnob {41 range l "depth ramp" t "The fog will only start being sampled at the depth specified in the first value, it will be scaled up to full density at the second value, maintain that density until the depth of the third value, and then ramp back down to the depth of the final value." T depth_ramp_dummy.range}
 addUserKnob {20 endGroup n -1}
 addUserKnob {26 ""}
 addUserKnob {4 shapes l shape t "The shape to restrict the noise to" M {none plane sphere box "" ""}}
 addUserKnob {6 enable_planar_ramp l "enable planar ramp" t "whether or not to use the planar ramp" +INVISIBLE +STARTLINE}
 addUserKnob {13 plane_point l position t "A position on the plane." +HIDDEN}
 plane_point {0 2 0}
 addUserKnob {13 plane_normal l normal t "The normal direction to the plane" +HIDDEN}
 plane_normal {0 1 0}
 addUserKnob {7 in t "The distance from the underside of the plane (the side the normal is pointing away from) at which the noise reaches full intensity." +HIDDEN R 0 100}
 in 1
 addUserKnob {7 in_falloff l falloff t "The distance over which the noise goes from full to no intensity on the side of the plane that the normal points away from." -STARTLINE +HIDDEN R 0 10}
 in_falloff 1
 addUserKnob {7 out t "The distance from the plane, on the side the normal points towards, at which the noise reaches full intensity." +HIDDEN R 0 100}
 out 1
 addUserKnob {7 out_falloff l falloff t "The distance over which the noise falls off from full to no intensity on the side of the plane the normal points towards." -STARTLINE +HIDDEN R 0 10}
 out_falloff 1
 addUserKnob {26 plane_div l "" +STARTLINE +HIDDEN}
 addUserKnob {7 plane_falloff_power l "falloff power" t "The power of exponential falloff to use." +HIDDEN R 0 4}
 addUserKnob {7 plane_falloff_offset l "falloff offset" t "The value to offset the distance with before falling off. A value less than 1 will look like the plane is a light." +HIDDEN}
 plane_falloff_offset 1
 addUserKnob {6 enable_spherical_ramp l "enable spherical ramp" t "Enable the spherical ramp" +HIDDEN +STARTLINE}
 addUserKnob {13 spherical_ramp_position l position t "The center of the spherical ramp" +HIDDEN}
 addUserKnob {7 spherical_ramp_start_radius l "start radius" t "The radius where the noise begins to falloff. Closer than this radius it is at full strength." +HIDDEN R 0 100}
 spherical_ramp_start_radius 1
 addUserKnob {7 spherical_ramp_end_radius l "end radius" t "Where the falloff ends. Beyond this radius there is no noise" +HIDDEN R 0 100}
 spherical_ramp_end_radius 2
 addUserKnob {7 sphere_falloff_power l "falloff power" t "The power of exponential falloff to use." +HIDDEN R 0 4}
 addUserKnob {7 sphere_falloff_offset l "falloff offset" t "The value to offset the distance with before falling off. A value less than 1 will look like a light is at the center of the sphere." +HIDDEN}
 sphere_falloff_offset 1
 addUserKnob {6 enable_box_ramp l "enable box ramp" t "enable the box ramp" +HIDDEN +STARTLINE}
 addUserKnob {13 box_ramp_position l "center position" t "the position of the box" +HIDDEN}
 addUserKnob {13 box_ramp_rotation l rotation t "The rotation of the box" +HIDDEN}
 addUserKnob {7 width t "The box width" +HIDDEN R 0 100}
 width 2
 addUserKnob {7 height t "The height of the noise box" +HIDDEN R 0 100}
 height 2
 addUserKnob {7 depth t "the depth of the noise box" +HIDDEN R 0 100}
 depth 2
 addUserKnob {7 box_falloff_distance l "falloff distance" t "The distance from the box over which to falloff. After this distance, no noise will be shown" +HIDDEN R 0 100}
 box_falloff_distance 0.1
 addUserKnob {7 box_falloff_power l "falloff power" t "The power of exponential falloff to use." +HIDDEN R 0 4}
 addUserKnob {7 box_falloff_offset l "falloff offset" t "The value to offset the distance with before falling off. A value less than 1 will look like a light is at the center of the box." +HIDDEN}
 box_falloff_offset 1
 addUserKnob {26 noise_settings l "<b>noise settings"}
 addUserKnob {7 size t "The size of the noise." R 1 300}
 size 5
 addUserKnob {4 type t "The noise type." M {turbulence fBm "" ""}}
 type fBm
 addUserKnob {13 translation t "Translate the noise by this amount."}
 addUserKnob {3 octaves t "The number of different frequencies to use."}
 octaves 8
 addUserKnob {7 lacunarity t "The per octave frequency multiplier." R 1 10}
 lacunarity 2
 addUserKnob {7 gain t "The per octave amplitude multiplier."}
 gain 0.6
 addUserKnob {7 gamma t "The result will be raised to 1 over this power."}
 gamma 0.4
 addUserKnob {26 spacer_0 l "" +STARTLINE T " "}
 addUserKnob {19 low_frequency_scale l "low freq scale" t "Scale the low frequencies by this amount separately from the high frequencies."}
 low_frequency_scale {1 1 1 1}
 addUserKnob {19 high_frequency_scale l "high freq scale" t "Scale the high frequencies by this amount separately from the low frequencies."}
 high_frequency_scale {1 1 1 1}
 addUserKnob {26 spacer l "" +STARTLINE T " "}
 addUserKnob {19 low_frequency_translation l "low freq translation" t "Translate the low frequencies by this amount separately from the high frequencies."}
 low_frequency_translation {0 0 0 0}
 addUserKnob {19 high_frequency_translation l "high freq translation" t "Translate the high frequencies by this amount separately from the low frequencies."}
 high_frequency_translation {0 0 0 0}
 addUserKnob {26 spacer_ l "" +STARTLINE T " "}
 addUserKnob {19 low_frequency_evolve l "low freq evolve" t "Evolve the low frequency over time."}
 low_frequency_evolve {0 0 0 0}
 addUserKnob {19 high_frequency_evolve l "high freq evolve" t "Evolve the high frequency over time."}
 high_frequency_evolve {0 0 0 0}
 addUserKnob {26 spacer_2 l "" +STARTLINE T " "}
 addUserKnob {26 holdout_settings l "<b>holdout settings"}
 addUserKnob {4 holdout_mode l "holdout mode" M {depth "deep (proxy)" "deep (full)"}}
 addUserKnob {26 ""}
 addUserKnob {41 from0 l "depth channel" T Copy1.from0}
 addUserKnob {6 invert_depth l "invert depth" t "Check this box to do 1/z, otherwise assumes true depth." -STARTLINE}
 invert_depth true
 addUserKnob {6 camera_space l "camera space" t "Leave this checked if the depth is in camera space, uncheck if the depth is in world space. If the depth is camera space and the holdout is far away then the depth will appear to change as the held-out object moves from the center to the edge of frame. This will not be very noticeable for foreground objects.\n\nMost depth renders are in camera space, so when in doubt, leave this checked." -STARTLINE}
 camera_space true
 addUserKnob {6 output_deep l "output deep (slow)" t "Output deep data, this will be slow." +STARTLINE}
 addUserKnob {26 output_settings l "<b>output settings"}
 addUserKnob {41 format T format_.format}
 addUserKnob {3 overscan}
 addUserKnob {6 latlong t "Render a latlong." +STARTLINE}
 addUserKnob {26 div0 l "" +STARTLINE}
 addUserKnob {26 info l "" +STARTLINE T "v2.0.0 - (c) Owen Bulka & Riley Gray - 2024"}
}
 Input {
  inputs 0
  name camera
  xpos 1620
  ypos 894
 }
 Camera {
  projection_mode {{"\[expression \[value the_cam]projection_mode(\[value the_frame])]"}}
  focal {{"\[expression \[value the_cam]focal(\[value the_frame])]"}}
  haperture {{"\[expression \[value the_cam]haperture(\[value the_frame])]"}}
  vaperture {{"\[expression \[value the_cam]vaperture(\[value the_frame])]"}}
  near {{"\[expression \[value the_cam]near(\[value the_frame])]"}}
  far {{"\[expression \[value the_cam]far(\[value the_frame])]"}}
  win_translate {{"\[expression \[value the_cam]win_translate.u(\[value the_frame])]"} {"\[expression \[value the_cam]win_translate.v(\[value the_frame])]"}}
  win_scale {{"\[expression \[value the_cam]win_scale.u(\[value the_frame])]"} {"\[expression \[value the_cam]win_scale.v(\[value the_frame])]"}}
  winroll {{"\[expression \[value the_cam]winroll(\[value the_frame])]"}}
  focal_point {{"\[expression \[value the_cam]focal_point(\[value the_frame])]"}}
  fstop {{"\[expression \[value the_cam]fstop(\[value the_frame])]"}}
  name DummyCam
  help "DummyCam by Adrian Pueyo\n\nCamera that apart from the matrices also grabs all the \"Projection\" values from the upstream camera that it's connected to. Turns into a default Camera if no Camera connected. Can also be used inside of groups and gizmos, as many levels deep as you want :D All using live and super fast TCL.\n\nUpdated v1.1: Now grabs the correct frame too (thanks Erwan Leroy for the idea).\n\nUpdated v1.3: Now accepts Nuke13's Camera3\n\nadrianpueyo.com, 2019-2021"
  onCreate "n = nuke.thisNode()\nfor k in \[\"projection_mode\",\"focal\",\"haperture\",\"vaperture\",\"near\",\"far\",\"win_translate\",\"win_scale\",\"winroll\",\"focal_point\",\"fstop\"]:\n    n\[k].setFlag(0x0000000010000000)"
  xpos 1630
  ypos 994
  addUserKnob {20 DummyCam l Defaults}
  addUserKnob {43 the_cam +INVISIBLE}
  the_cam "\[\n#DummyCam v1.3 - Updated 5 May 2021.\nset starting_point \"this.input0\"\nset default \"this.d_\"\n\n# If cam has no inputs, return the default.\nif \{\[exists \$starting_point]\} \{\n    set x \[node \$starting_point]\n\} \{ \n    return \$default\n\}\n\nset finished 0\nwhile \{\$finished != 1\} \{\n\n    # First look for a Cam or Input or topnode.\n    while \{\[class \$x] != \"Camera4\" && \[class \$x] != \"Camera3\" && \[class \$x] != \"Camera2\" && \[class \$x] != \"Camera\" && \[class \$x] != \"Input\" && \$x != \[topnode \$x]\} \{\n        set x \[node \$x.input0]\n    \}\n\n    # Then, check if node is a cam (and return), and otherwise, if it's an input, see if the parent exists and move to it.\n    if \{\[class \$x]==\"Camera4\"||\[class \$x]==\"Camera3\"||\[class \$x]==\"Camera2\"||\[class \$x]==\"Camera\"\} \{\n        set x \[append x \".\"]\n        return \$x\n    \} \{ \n        if \{ \[class \$x]==\"Input\" \} \{ \n            set inp \"\$x.parent.input\"\n            set inputNum \[value \$x.number]\n            set inp \[append inp \$inputNum]\n            if \{ \[exists \$inp] \} \{\n                set x \[node \$inp]\n            \} \{ \n                set finished 1\n            \}\n        \} \{ \n            set finished 1\n        \}\n    \}\n\}\nreturn \$default\n]"
  addUserKnob {43 the_frame +INVISIBLE}
  the_frame "\[\nset the_camera \[string trimright \[value the_cam] .]\nif \{\[exists \$the_camera]\} \{\n    return \[value \$the_camera.frame]\n\} \{ \n    return \[frame]\n\}\n]"
  addUserKnob {4 d_projection_mode l projection M {perspective orthographic uv spherical ""}}
  addUserKnob {7 d_focal l "focal length" R 0 100}
  d_focal 50
  addUserKnob {7 d_haperture l "horiz aperture" R 0 50}
  d_haperture 24.576
  addUserKnob {7 d_vaperture l "vert aperture" R 0 50}
  d_vaperture 18.672
  addUserKnob {7 d_near l near R 0 10}
  d_near 0.1
  addUserKnob {7 d_far l far R 0 10000}
  d_far 10000
  addUserKnob {30 d_win_translate l "window translate"}
  addUserKnob {30 d_win_scale l "window scale"}
  d_win_scale {1 1}
  addUserKnob {7 d_winroll l "window roll" R 0 45}
  addUserKnob {7 d_focal_point l "focal distance" R 0 10}
  d_focal_point 2
  addUserKnob {7 d_fstop l fstop R 0 30}
  d_fstop 16
  addUserKnob {26 version l " " t "Updated 5 May 2021" T "<span style=\"color:#666\"><br/><b>DummyCam v1.3</b> - <a href=\"http://www.adrianpueyo.com\" style=\"color:#666;text-decoration: none;\">adrianpueyo.com</a>, 2019-2021</span>"}
 }
 Keyer {
  inputs 0
  operation "luminance key"
  range {2 4 12 15}
  name depth_ramp_dummy
  xpos 1982
  ypos 784
 }
 Constant {
  inputs 0
  channels {rgba.red rgba.green rgba.blue -rgba.alpha}
  name format_
  xpos 1756
  ypos 678
 }
 Crop {
  box {{-parent.overscan} {-parent.overscan} {"width + parent.overscan"} {"height + parent.overscan"}}
  crop false
  name Crop4
  xpos 1756
  ypos 757
 }
 Noise {
  output {rgba.red -rgba.green -rgba.blue -rgba.alpha}
  cliptype bbox
  size 1
  zoffset 100
  nyquist false
  gain 0.95
  gamma 1
  center {512 389}
  name Noise5
  xpos 1756
  ypos 868
 }
 Noise {
  output {-rgba.red rgba.green -rgba.blue -rgba.alpha}
  cliptype bbox
  size 1
  zoffset 10
  nyquist {{parent.Noise5.nyquist}}
  gain {{parent.Noise5.gain}}
  gamma {{parent.Noise5.gamma}}
  center {512 389}
  name Noise6
  xpos 1756
  ypos 897
 }
 Noise {
  output {-rgba.red -rgba.green rgba.blue -rgba.alpha}
  cliptype bbox
  size 1
  zoffset 1000
  nyquist {{parent.Noise5.nyquist}}
  gain {{parent.Noise5.gain}}
  gamma {{parent.Noise5.gamma}}
  center {512 389}
  name Noise7
  xpos 1756
  ypos 926
 }
 Noise {
  output {-rgba.red -rgba.green -rgba.blue rgba.alpha}
  cliptype bbox
  size 1
  zoffset -100
  nyquist {{parent.Noise5.nyquist}}
  gain {{parent.Noise5.gain}}
  gamma {{parent.Noise5.gamma}}
  center {512 389}
  name Noise8
  xpos 1756
  ypos 955
 }
 Multiply {
  value 100
  name Multiply1
  xpos 1756
  ypos 993
 }
 Dot {
  name Dot2
  xpos 1790
  ypos 1114
 }
set Na9ad360 [stack 0]
 Dot {
  name Dot3
  xpos 1925
  ypos 1114
 }
set Na9b2390 [stack 0]
 Dot {
  name Dot11
  xpos 2114
  ypos 1114
 }
 BlinkScript {
  kernelSourceFile /home/ob1/software/nuke/blink_fog_3d/src/blink/kernels/blink_fog_single_sample.cpp
  kernelSource "// Copyright 2024 by Owen Bulka.\n// All rights reserved.\n// This file is released under the \"MIT License Agreement\".\n// Please see the LICENSE.md file that should have been included as part\n// of this package.\n\n\n//\n// Math operations\n//\n\n\n/**\n * The maximum component of a vector.\n *\n * @arg vector: The vector.\n *\n * @returns: The maximum component of the vector.\n */\ninline float maxComponent(const float3 &vector)\n\{\n    return max(vector.x, max(vector.y, vector.z));\n\}\n\n\n/**\n * The negative part of the vector. Ie. any positive values will be 0,\n * and the negative values will be positive.\n *\n * @arg vector: The vector.\n *\n * @returns: The negative part of the vector.\n */\ninline float negativePart(const float value)\n\{\n    return -min(value, 0.0f);\n\}\n\n\n/**\n * The positive part of the vector. Ie. any negative values will be 0.\n *\n * @arg vector: The vector.\n *\n * @returns: The positive part of the vector.\n */\ninline float3 positivePart(const float3 &vector)\n\{\n    return max(vector, float3(0));\n\}\n\n\n/**\n * Compute the fractional portion of the value. Ex. 3.5 returns 0.5\n *\n * @arg value: The value to get the fractional portion of.\n *\n * @returns: The fractional portion of the value.\n */\ninline float fract(const float value)\n\{\n    return value - floor(value);\n\}\n\n\n/**\n * Saturate a value ie. clamp between 0 and 1\n *\n * @arg value: The value to saturate\n *\n * @returns: The clamped value\n */\ninline float saturate(float value)\n\{\n    return clamp(value, 0.0f, 1.0f);\n\}\n\n\n/**\n * Multiply a 4d vector by a 4x4 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline void matmul(const float4x4 &m, const float4 &v, float4 &out)\n\{\n    for (int i=0; i < 4; i++)\n    \{\n        out\[i] = 0;\n\n        for (int j=0; j < 4; j++)\n        \{\n            out\[i] += m\[i]\[j] * v\[j];\n        \}\n    \}\n\}\n\n\n/**\n * Multiply a 4d vector by a 4x4 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline float4 matmul(const float4x4 &m, const float4 &v)\n\{\n    float4 out;\n    for (int i=0; i < 4; i++)\n    \{\n        out\[i] = 0;\n\n        for (int j=0; j < 4; j++)\n        \{\n            out\[i] += m\[i]\[j] * v\[j];\n        \}\n    \}\n\n    return out;\n\}\n\n\n/**\n * Multiply a 3d vector by a 3x3 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline float3 matmul(const float3x3 &m, const float3 &v)\n\{\n    return float3(\n        m\[0]\[0] * v.x + m\[0]\[1] * v.y + m\[0]\[2] * v.z,\n        m\[1]\[0] * v.x + m\[1]\[1] * v.y + m\[1]\[2] * v.z,\n        m\[2]\[0] * v.x + m\[2]\[1] * v.y + m\[2]\[2] * v.z\n    );\n\}\n\n\n/**\n * Convert the uv position in a latlong image to angles.\n *\n * @arg uvPosition: The UV position.\n *\n * @returns: The equivalent angles in radians.\n */\ninline float2 uvPositionToAngles(const float2 &uvPosition)\n\{\n    return float2(\n        (uvPosition.x + 1.0f) * PI,\n        (1.0f - uvPosition.y) * PI / 2.0f\n    );\n\}\n\n\n/**\n * Convert location of a pixel in an image into UV.\n *\n * @arg pixelLocation: The x, and y positions of the pixel.\n * @arg format: The image width, and height.\n *\n * @returns: The UV position.\n */\ninline float2 pixelsToUV(const float2 &pixelLocation, const float2 &format)\n\{\n    return float2(\n        2.0f * pixelLocation.x / format.x - 1.0f,\n        2.0f * pixelLocation.y / format.y - 1.0f\n    );\n\}\n\n\n/**\n * Convert a spherical unit vector (unit radius) to cartesion.\n *\n * @arg angles: The spherical angles in radians.\n *\n * @returns: The equivalent cartesion vector.\n */\ninline float3 sphericalUnitVectorToCartesion(const float2 &angles)\n\{\n    const float sinPhi = sin(angles.y);\n    return float3(\n        cos(angles.x) * sinPhi,\n        cos(angles.y),\n        sin(angles.x) * sinPhi\n    );\n\}\n\n\n/**\n * Get the position component of a world matrix.\n *\n * @arg worldMatrix: The world matrix.\n * @arg position: The location to store the position.\n */\ninline void positionFromWorldMatrix(const float4x4 &worldMatrix, float3 &position)\n\{\n    position = float3(\n        worldMatrix\[0]\[3],\n        worldMatrix\[1]\[3],\n        worldMatrix\[2]\[3]\n    );\n\}\n\n\n/**\n * Get the rotation component of a world matrix.\n *\n * @arg worldMatrix: The world matrix.\n * @arg rotation: The location to store the rotation.\n */\ninline void rotationFromWorldMatrix(const float4x4 &worldMatrix, float3x3 &rotationMatrix)\n\{\n    rotationMatrix\[0]\[0] = worldMatrix\[0]\[0];\n    rotationMatrix\[0]\[1] = worldMatrix\[0]\[1];\n    rotationMatrix\[0]\[2] = worldMatrix\[0]\[2];\n    rotationMatrix\[1]\[0] = worldMatrix\[1]\[0];\n    rotationMatrix\[1]\[1] = worldMatrix\[1]\[1];\n    rotationMatrix\[1]\[2] = worldMatrix\[1]\[2];\n    rotationMatrix\[2]\[0] = worldMatrix\[2]\[0];\n    rotationMatrix\[2]\[1] = worldMatrix\[2]\[1];\n    rotationMatrix\[2]\[2] = worldMatrix\[2]\[2];\n\}\n\n\n/**\n * Get a rotation matrix from radian angle values in ZYX order.\n *\n * @arg angles: The rotation angles in radians.\n * @arg out: The location to store the rotation matrix.\n */\ninline void rotationMatrix(const float3 &angles, float3x3 &out)\n\{\n    const float3 cosAngles = cos(angles);\n    const float3 sinAngles = sin(angles);\n\n    // Why tf can I not init a float3x3 normally??\n    out\[0]\[0] = cosAngles.y * cosAngles.z;\n    out\[0]\[1] = sinAngles.x * sinAngles.y * cosAngles.z - cosAngles.x * sinAngles.z;\n    out\[0]\[2] = cosAngles.x * sinAngles.y * cosAngles.z + sinAngles.x * sinAngles.z;\n    out\[1]\[0] = cosAngles.y * sinAngles.z;\n    out\[1]\[1] = sinAngles.x * sinAngles.y * sinAngles.z + cosAngles.x * cosAngles.z;\n    out\[1]\[2] = cosAngles.x * sinAngles.y * sinAngles.z - sinAngles.x * cosAngles.z;\n    out\[2]\[0] = -sinAngles.y;\n    out\[2]\[1] = sinAngles.x * cosAngles.y;\n    out\[2]\[2] = cosAngles.x * cosAngles.y;\n\}\n\n\n//\n// Randomization functions\n//\n\n\n// Some random constants on the interval \[1, 2]\n#define RAND_CONST_0 1.571411510193971f\n\n\n/**\n * Get a random value on the interval \[0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval \[0, 1].\n */\ninline float random(const float seed)\n\{\n    return fract(sin(73.1f * seed + 91.3458f) * 47453.5453f);\n\}\n\n\n/**\n * Get a random value on the interval \[0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval \[0, 1].\n */\ninline float2 random(const float2 &seed)\n\{\n    return float2(\n        fract(sin(13.157f * seed.x + 71.743f) * 7513.471f),\n        fract(sin(97.519f * seed.y + 113.591f) * 47453.5453f)\n    );\n\}\n\n\n/**\n * Create a random point that lies within the unit circle.\n *\n * @arg seed: The random seed.\n *\n * @returns: A random point, (radius, angle) in the unit circle.\n */\ninline float2 uniformPointInUnitCircle(const float2 &seed)\n\{\n    return float2(sqrt(random(seed.x)), 2.0f * PI * random(seed.y));\n\}\n\n\n/**\n * Sum the elements of a vector.\n *\n * @arg vector: The vector to sum the elements of.\n *\n * @returns: The sum of the vector elements.\n */\ninline float elementSum(const float4 &vector) \{\n    return vector.x + vector.y + vector.z + vector.w;\n\}\n\n\n#define FBM_NOISE 1\n\n\n//\n// Camera Utilities\n//\n\n\n/**\n * Compute the field of view from focal length.\n *\n * @arg focalLength: The focal length.\n *\n * @returns: The equivalent field of view.\n */\ninline float fieldOfView(const float focalLength)\n\{\n    return 2 * atan(1 / focalLength);\n\}\n\n\n/**\n * Compute the aspect ratio from image format.\n *\n * @arg height_: The height of the image.\n * @arg width_: The width of the image.\n *\n * @returns: The aspect ratio.\n */\ninline float aspectRatio(const float height_, const float width_)\n\{\n    return height_ / width_;\n\}\n\n\n/**\n *\n */\ninline float fStopToAperture(const float fStop, const float focalLength)\n\{\n    return focalLength / fStop / 1000.0f;\n\}\n\n\n/**\n * Create a projection matrix for a camera.\n *\n * @arg focalLength: The focal length of the camera.\n * @arg horizontalAperture: The horizontal aperture of the camera.\n * @arg aspect: The aspect ratio of the camera.\n * @arg nearPlane: The distance to the near plane of the camera.\n * @arg farPlane: The distance to the far plane of the camera.\n *\n * @returns: The camera's projection matrix.\n */\nfloat4x4 projectionMatrix(\n        const float focalLength,\n        const float horizontalAperture,\n        const float aspect,\n        const float nearPlane,\n        const float farPlane)\n\{\n    float farMinusNear = farPlane - nearPlane;\n    return float4x4(\n        2 * focalLength / horizontalAperture, 0, 0, 0,\n        0, 2 * focalLength / horizontalAperture / aspect, 0, 0,\n        0, 0, -(farPlane + nearPlane) / farMinusNear, -2 * (farPlane * nearPlane) / farMinusNear,\n        0, 0, -1, 0\n    );\n\}\n\n\n/**\n * Generate a ray out of a camera.\n *\n * @arg cameraWorldMatrix: The camera matrix.\n * @arg inverseProjectionMatrix: The inverse of the projection matrix.\n * @arg uvPosition: The UV position in the resulting image.\n * @arg rayOrigin: Will store the origin of the ray.\n * @arg rayDirection: Will store the direction of the ray.\n */\nvoid createCameraRay(\n        const float4x4 &cameraWorldMatrix,\n        const float4x4 &inverseProjectionMatrix,\n        const float2 &uvPosition,\n        float3 &rayOrigin,\n        float3 &rayDirection)\n\{\n    positionFromWorldMatrix(cameraWorldMatrix, rayOrigin);\n    float4 direction = matmul(\n        inverseProjectionMatrix,\n        float4(uvPosition.x, uvPosition.y, 0, 1)\n    );\n    matmul(\n        cameraWorldMatrix,\n        float4(direction.x, direction.y, direction.z, 0),\n        direction\n    );\n    rayDirection = normalize(float3(direction.x, direction.y, direction.z));\n\}\n\n\n/**\n * Generate a ray out of a camera.\n *\n * @arg cameraWorldMatrix: The camera matrix.\n * @arg inverseProjectionMatrix: The inverse of the projection matrix.\n * @arg uvPosition: The UV position in the resulting image.\n * @arg rayOrigin: Will store the origin of the ray.\n * @arg rayDirection: Will store the direction of the ray.\n */\nvoid createCameraRay(\n        const float4x4 &cameraWorldMatrix,\n        const float4x4 &inverseProjectionMatrix,\n        const float2 &uvPosition,\n        const float aperture,\n        const float focalDistance,\n        const float2 &seed,\n        float3 &rayOrigin,\n        float3 &rayDirection)\n\{\n    createCameraRay(\n        cameraWorldMatrix,\n        inverseProjectionMatrix,\n        uvPosition,\n        rayOrigin,\n        rayDirection\n    );\n\n    const float4 cameraForward4 = matmul(\n        cameraWorldMatrix,\n        float4(0, 0, -1, 0)\n    );\n    const float3 cameraForward = float3(\n        cameraForward4.x,\n        cameraForward4.y,\n        cameraForward4.z\n    );\n    const float4 cameraRight4 = matmul(\n        cameraWorldMatrix,\n        float4(1, 0, 0, 0)\n    );\n    const float3 cameraRight = float3(\n        cameraRight4.x,\n        cameraRight4.y,\n        cameraRight4.z\n    );\n    const float4 cameraUp4 = matmul(\n        cameraWorldMatrix,\n        float4(0, 1, 0, 0)\n    );\n    const float3 cameraUp = float3(\n        cameraUp4.x,\n        cameraUp4.y,\n        cameraUp4.z\n    );\n\n    const float3 focalPlanePoint = rayOrigin + cameraForward * focalDistance;\n    const float3 focalPlaneNormal = -cameraForward;\n\n    const float focalPointDistance = (\n        (dot(focalPlaneNormal, focalPlanePoint) - dot(rayOrigin, focalPlaneNormal))\n        / dot(rayDirection, focalPlaneNormal)\n    );\n    const float3 focalPoint = rayOrigin + focalPointDistance * rayDirection;\n\n    const float2 pointInUnitCircle = uniformPointInUnitCircle(seed);\n    const float2 offset = pointInUnitCircle.x * aperture * float2(\n        cos(pointInUnitCircle.y),\n        sin(pointInUnitCircle.y)\n    );\n\n    rayOrigin += cameraRight * offset.x + cameraUp * offset.y;\n    rayDirection = normalize(focalPoint - rayOrigin);\n\}\n\n\n/**\n * Generate a LatLong ray out of a camera.\n *\n * @arg cameraWorldMatrix: The camera matrix.\n * @arg uvPosition: The UV position in the resulting image.\n * @arg rayOrigin: Will store the origin of the ray.\n * @arg rayDirection: Will store the direction of the ray.\n */\nvoid createLatLongCameraRay(\n        const float4x4 &cameraWorldMatrix,\n        const float2 &uvPosition,\n        float3 &rayOrigin,\n        float3 &rayDirection)\n\{\n    positionFromWorldMatrix(cameraWorldMatrix, rayOrigin);\n    rayDirection = sphericalUnitVectorToCartesion(uvPositionToAngles(uvPosition));\n\n    float3x3 cameraRotation;\n    rotationFromWorldMatrix(cameraWorldMatrix, cameraRotation);\n    rayDirection = matmul(cameraRotation, rayDirection);\n\}\n\n\n// SDFs\n\n\n/**\n * Compute the signed distance along a vector\n *\n * @arg vector: A vector from a point to the nearest surface of an\n *     object.\n *\n * @returns: The signed length of the vector.\n */\ninline float sdfLength(const float3 &vector)\n\{\n    return (\n        length(positivePart(vector))\n        - negativePart(maxComponent(vector))\n    );\n\}\n\n\n/**\n * Compute the min distance from a point to a sphere.\n *\n * @arg position: The point to get the distance to, from the object.\n * @arg radius: The radius of the sphere.\n *\n * @returns: The minimum distance from the point to the shape.\n */\ninline float distanceToSphere(const float3 &position, const float radius)\n\{\n    return length(position) - radius;\n\}\n\n\n/**\n * Compute the min distance from a point to a plane.\n * Anything underneath the plane, as defined by the normal direction\n * pointing above, will be considered inside.\n *\n * @arg position: The point to get the distance to, from the object.\n * @arg normal: The normal direction of the plane.\n *\n * @returns: The minimum distance from the point to the shape.\n */\ninline float distanceToPlane(const float3 &position, const float3 &normal)\n\{\n    return dot(position, normal);\n\}\n\n\n/**\n * Compute the min distance from a point to a rectangular prism.\n * Centered at the origin.\n *\n * @arg position: The point to get the distance to, from the object.\n * @arg width: The width (x) of the prism.\n * @arg height: The height (y) of the prism.\n * @arg depth: The depth (z) of the prism.\n *\n * @returns: The minimum distance from the point to the shape.\n */\ninline float distanceToRectangularPrism(\n        const float3 &position,\n        const float width,\n        const float height,\n        const float depth)\n\{\n    // Only look at positive quadrant, using symmetry\n    const float3 prismToPosition = fabs(position) - float3(width, height, depth) / 2.0f;\n    // Clamp the components that are inside the prism to the surface\n    // before getting the distance\n    return sdfLength(prismToPosition);\n\}\n\n\nkernel SingleSampleFogKernel : ImageComputationKernel<ePixelWise>\n\{\n    // the input which specifies the format, process is called once per pixel\n    // in this image, which also provides random seeds\n    Image<eRead, eAccessPoint, eEdgeNone> seeds;\n\n    // the output image\n    Image<eWrite> dst;\n\n\n    param:\n        // These parameters are made available to the user.\n\n        // Camera params\n        float _focalLength;\n        float _horizontalAperture;\n        float _nearPlane;\n        float _farPlane;\n        float4x4 _cameraWorldMatrix;\n        float _focalDistance;\n        float _fStop;\n        bool _depthOfFieldEnabled;\n        bool _latLong;\n        bool _useCameraDepth;\n\n        // Image params\n        float _formatWidth;\n        float _formatHeight;\n        float _individualSample;\n        float _density;\n        int _samplesPerRay;\n\n        bool _enableDepthRamp;\n        float4 _depthRamp;\n\n        float4 _planarRamp;\n        bool _enablePlanarRamp;\n        float3 _planePosition;\n        float3 _planeNormal;\n        float _planarFalloffPower;\n        float _planarFalloffOffset;\n\n        bool _enableSphericalRamp;\n        float3 _sphericalRampPosition;\n        float2 _sphericalRampRadii;\n        float _sphericalFalloffPower;\n        float _sphericalFalloffOffset;\n\n        float3 _boxRampPosition;\n        float3 _boxRampRotation;\n        float3 _boxRampDimensions;\n        float _boxRampFalloff;\n        bool _enableBoxRamp;\n        float _boxFalloffPower;\n        float _boxFalloffOffset;\n\n        bool _secondSample;\n\n        // Noise Parameters\n        float _size;\n        int _noiseType;\n        float3 _translation;\n        float _octaves;\n        float _lacunarity;\n        float _gain;\n        float _gamma;\n        float4 _lowFrequencyScale;\n        float4 _highFrequencyScale;\n        float4 _lowFrequencyTranslation;\n        float4 _highFrequencyTranslation;\n\n        // Raymarch parameters\n        float _hitTolerance;\n        float _maxDistance;\n\n    local:\n        // These local variables are not exposed to the user.\n        float4x4 __inverseCameraProjectionMatrix;\n        float4x4 __inverseCameraWorldMatrix;\n        float __aperture;\n\n        float4 __translation;\n\n        int __simplex\[64]\[4];\n        int __perm\[512];\n        int __grad4\[32]\[4];\n\n        float __depthSampleStep;\n\n        float __sphericalRampFalloffDistance;\n\n        float3 __planeNormal;\n\n        float3x3 __inverseBoxRotMatrix;\n\n        bool __enableRaymarching;\n\n        float3 __offset0;\n        float3 __offset1;\n        float3 __offset2;\n        float3 __offset3;\n\n\n    /**\n     * Give the parameters labels and default values.\n     */\n    void define()\n    \{\n        // Camera params\n        defineParam(_focalLength, \"FocalLength\", 50.0f);\n        defineParam(_horizontalAperture, \"HorizontalAperture\", 24.576f);\n        defineParam(_nearPlane, \"NearPlane\", 0.1f);\n        defineParam(_farPlane, \"FarPlane\", 10000.0f);\n        defineParam(\n            _cameraWorldMatrix,\n            \"CameraWorldMatrix\",\n            float4x4(\n                1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1\n            )\n        );\n        defineParam(_focalDistance, \"FocalDistance\", 4.0f);\n        defineParam(_fStop, \"fstop\", 16.0f);\n        defineParam(_depthOfFieldEnabled, \"EnableDepthOfField\", true);\n        defineParam(_latLong, \"OutputLatLong\", false);\n        defineParam(_useCameraDepth, \"UseCameraDepth\", false);\n\n        // Image params\n        defineParam(_formatHeight, \"ScreenHeight\", 2160.0f);\n        defineParam(_formatWidth, \"ScreenWidth\", 3840.0f);\n        defineParam(_individualSample, \"IndividualSample\", 0.0f);\n        defineParam(_density, \"Density\", 1.0f);\n        defineParam(_samplesPerRay, \"SamplesPerRay\", 5);\n\n        defineParam(_enableDepthRamp, \"EnableDepthRamp\", true);\n        defineParam(_depthRamp, \"SampleDepthRamp\", float4(5.0f, 10.0f, 15.0f, 20.0f));\n\n        defineParam(_planarRamp, \"SamplePlanarRamp\", float4(5.0f, 10.0f, 15.0f, 20.0f));\n        defineParam(_enablePlanarRamp, \"EnablePlanarRamp\", false);\n        defineParam(_planePosition, \"PlanePosition\", float3(0.0f, 0.0f, 0.0f));\n        defineParam(_planeNormal, \"PlaneNormal\", float3(0.0f, 1.0f, 0.0f));\n        defineParam(_planarFalloffPower, \"PlanarFalloffPower\", 0.0f);\n        defineParam(_planarFalloffOffset, \"PlanarFalloffOffset\", 0.0f);\n\n        defineParam(_enableSphericalRamp, \"EnableSphericalRamp\", false);\n        defineParam(_sphericalRampPosition, \"SphericalRampPosition\", float3(0.0f, 0.0f, 0.0f));\n        defineParam(_sphericalRampRadii, \"SphericalRampRadii\", float2(1.0f, 2.0f));\n        defineParam(_sphericalFalloffPower, \"SphericalFalloffPower\", 0.0f);\n        defineParam(_sphericalFalloffOffset, \"SphericalFalloffOffset\", 0.0f);\n\n        defineParam(_boxRampPosition, \"BoxRampPosition\", float3(0.0f, 0.0f, 0.0f));\n        defineParam(_boxRampRotation, \"BoxRampRotation\", float3(0.0f, 0.0f, 0.0f));\n        defineParam(_boxRampDimensions, \"BoxRampDimensions\", float3(1.0f, 1.0f, 1.0f));\n        defineParam(_boxRampFalloff, \"BoxRampFalloff\", 1.0f);\n        defineParam(_enableBoxRamp, \"EnableBoxRamp\", false);\n        defineParam(_boxFalloffPower, \"BoxFalloffPower\", 0.0f);\n        defineParam(_boxFalloffOffset, \"BoxFalloffOffset\", 0.0f);\n\n        defineParam(_secondSample, \"DoSecondSample\", false);\n\n        defineParam(_hitTolerance, \"HitTolerance\", 0.001f);\n        defineParam(_maxDistance, \"MaxDistance\", 1000000.0f);\n\n        // Noise Parameters\n        defineParam(_size, \"Size\", 20.0f);\n        defineParam(_noiseType, \"NoiseType\", 0);\n        defineParam(_translation, \"Translation\", float3(0.0f, 0.0f, 0.0f));\n        defineParam(_octaves, \"Octaves\", 8.0f);\n        defineParam(_lacunarity, \"Lacunarity\", 3.0f);\n        defineParam(_gain, \"Gain\", 0.5f);\n        defineParam(_gamma, \"Gamma\", 0.5f);\n        defineParam(_lowFrequencyScale, \"LowFrequencyScale\", float4(0.0f, 0.0f, 0.0f, 0.0f));\n        defineParam(_highFrequencyScale, \"HighFrequencyScale\", float4(0.0f, 0.0f, 0.0f, 0.0f));\n        defineParam(_lowFrequencyTranslation, \"LowFrequencyTranslation\", float4(0.0f, 0.0f, 0.0f, 0.0f));\n        defineParam(_highFrequencyTranslation, \"HighFrequencyTranslation\", float4(0.0f, 0.0f, 0.0f, 0.0f));\n    \}\n\n\n    /**\n     * Initialize the local variables.\n     */\n    void init()\n    \{\n        const float aspect = aspectRatio(_formatHeight, _formatWidth);\n        __inverseCameraProjectionMatrix = projectionMatrix(\n            _focalLength,\n            _horizontalAperture,\n            aspect,\n            _nearPlane,\n            _farPlane\n        ).invert();\n        // Dumb af but trust that changing the following will either break nuke 12 or 15\n        __inverseCameraWorldMatrix = _cameraWorldMatrix;\n        __inverseCameraWorldMatrix = __inverseCameraWorldMatrix.invert();\n\n        __aperture = fStopToAperture(_fStop, _focalLength);\n\n        const int simplexInit\[64]\[4] = \{\n            \{0, 1, 2, 3\}, \{0, 1, 3, 2\}, \{0, 0, 0, 0\}, \{0, 2, 3, 1\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{1, 2, 3, 0\},\n            \{0, 2, 1, 3\}, \{0, 0, 0, 0\}, \{0, 3, 1, 2\}, \{0, 3, 2, 1\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{1, 3, 2, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{1, 2, 0, 3\}, \{0, 0, 0, 0\}, \{1, 3, 0, 2\}, \{0, 0, 0, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{2, 3, 0, 1\}, \{2, 3, 1, 0\},\n            \{1, 0, 2, 3\}, \{1, 0, 3, 2\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{0, 0, 0, 0\}, \{2, 0, 3, 1\}, \{0, 0, 0, 0\}, \{2, 1, 3, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{2, 0, 1, 3\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{3, 0, 1, 2\}, \{3, 0, 2, 1\}, \{0, 0, 0, 0\}, \{3, 1, 2, 0\},\n            \{2, 1, 0, 3\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{3, 1, 0, 2\}, \{0, 0, 0, 0\}, \{3, 2, 0, 1\}, \{3, 2, 1, 0\}\n        \};\n\n        for (int i = 0; i < 64; i++)\n        \{\n            for (int j = 0; j < 4; j++)\n            \{\n                __simplex\[i]\[j] = simplexInit\[i]\[j];\n            \}\n        \}\n\n        const int permInit\[256] = \{\n            151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233,\n            7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23,\n            190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219,\n            203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174,\n            20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48,\n            27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133,\n            230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65,\n            25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18,\n            169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198,\n            173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147,\n            118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17,\n            182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44,\n            154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22,\n            39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112,\n            104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12,\n            191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49,\n            192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121,\n            50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29,\n            24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180\n        \};\n\n        for (int i = 0; i < 512; i++)\n        \{\n            __perm\[i] = permInit\[i % 256];\n        \}\n\n        const int grad4Init\[32]\[4]= \{\n            \{0, 1, 1, 1\},  \{0, 1, 1, -1\},  \{0, 1, -1, 1\},  \{0, 1, -1, -1\},\n            \{0, -1, 1, 1\}, \{0, -1, 1, -1\}, \{0, -1, -1, 1\}, \{0, -1, -1, -1\},\n            \{1, 0, 1, 1\},  \{1, 0, 1, -1\},  \{1, 0, -1, 1\},  \{1, 0, -1, -1\},\n            \{-1, 0, 1, 1\}, \{-1, 0, 1, -1\}, \{-1, 0, -1, 1\}, \{-1, 0, -1, -1\},\n            \{1, 1, 0, 1\},  \{1, 1, 0, -1\},  \{1, -1, 0, 1\},  \{1, -1, 0, -1\},\n            \{-1, 1, 0, 1\}, \{-1, 1, 0, -1\}, \{-1, -1, 0, 1\}, \{-1, -1, 0, -1\},\n            \{1, 1, 1, 0\},  \{1, 1, -1, 0\},  \{1, -1, 1, 0\},  \{1, -1, -1, 0\},\n            \{-1, 1, 1, 0\}, \{-1, 1, -1, 0\}, \{-1, -1, 1, 0\}, \{-1, -1, -1, 0\}\n        \};\n\n        for (int i = 0; i < 32; i++)\n        \{\n            for (int j = 0; j < 4; j++)\n            \{\n                __grad4\[i]\[j] = grad4Init\[i]\[j];\n            \}\n        \}\n\n        __offset0 = 0.5773f * float3(1, -1, -1);\n        __offset1 = 0.5773f * float3(-1, -1, 1);\n        __offset2 = 0.5773f * float3(-1, 1, -1);\n        __offset3 = 0.5773f * float3(1, 1, 1);\n\n        __translation = float4(_translation.x, _translation.y, _translation.z, 0.0f);\n\n        __depthSampleStep = (_depthRamp.w - _depthRamp.x) / (float) _samplesPerRay;\n\n        __planeNormal = normalize(_planeNormal);\n\n        __sphericalRampFalloffDistance = _sphericalRampRadii.y - _sphericalRampRadii.x;\n\n        __enableRaymarching = _enableSphericalRamp || _enableBoxRamp || _enablePlanarRamp;\n\n        rotationMatrix(_boxRampRotation, __inverseBoxRotMatrix);\n        __inverseBoxRotMatrix.invert();\n    \}\n\n    /**\n     * 4D Perlin simplex noise\n     *\n     * Copyright (c) 2007-2012 Eliot Eshelman\n     *\n     * This program is free software: you can redistribute it and/or modify\n     * it under the terms of the GNU General Public License as published by\n     * the Free Software Foundation, either version 3 of the License, or\n     * (at your option) any later version.\n     *\n     * This program is distributed in the hope that it will be useful,\n     * but WITHOUT ANY WARRANTY; without even the implied warranty of\n     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n     * GNU General Public License for more details.\n     *\n     * You should have received a copy of the GNU General Public License\n     * along with this program. If not, see <http://www.gnu.org/licenses/>.\n     *\n     * @arg seed: The seed for the noise.\n     *\n     * @returns: Noise value in the range \[-1, 1], value of 0 on all integer\n     *     coordinates.\n     */\n    inline float perlinSimplexNoise(const float4 &seed) \{\n        const float G4 = 0.138196601f;\n        const float4 i = floor(seed + elementSum(seed) * 0.309016994f);\n        const float4 x0 = seed - i + elementSum(i) * G4;\n\n        const int c = (\n            ((x0.x > x0.y) << 5)\n            | ((x0.x > x0.z) << 4)\n            | ((x0.y > x0.z) << 3)\n            | ((x0.x > x0.w) << 2)\n            | ((x0.y > x0.w) << 1)\n            | (x0.z > x0.w)\n        );\n        const int4 i1 = int4(\n            __simplex\[c]\[0] >= 3,\n            __simplex\[c]\[1] >= 3,\n            __simplex\[c]\[2] >= 3,\n            __simplex\[c]\[3] >= 3\n        );\n        const int4 i2 = int4(\n            __simplex\[c]\[0] >= 2,\n            __simplex\[c]\[1] >= 2,\n            __simplex\[c]\[2] >= 2,\n            __simplex\[c]\[3] >= 2\n        );\n        const int4 i3 = int4(\n            __simplex\[c]\[0] >= 1,\n            __simplex\[c]\[1] >= 1,\n            __simplex\[c]\[2] >= 1,\n            __simplex\[c]\[3] >= 1\n        );\n\n        const float4 x1 = x0 - float4(i1.x, i1.y, i1.z, i1.w) + G4;\n        const float4 x2 = x0 - float4(i2.x, i2.y, i2.z, i2.w) + 2.0f * G4;\n        const float4 x3 = x0 - float4(i3.x, i3.y, i3.z, i3.w) + 3.0f * G4;\n        const float4 x4 = x0 - 1.0f + 4.0f * G4;\n\n        const int ii = (int) i.x & 255;\n        const int jj = (int) i.y & 255;\n        const int kk = (int) i.z & 255;\n        const int ll = (int) i.w & 255;\n\n        const int gi0 = __perm\[\n            ii + __perm\[jj + __perm\[kk + __perm\[ll]]]\n        ] % 32;\n        const int gi1 = __perm\[\n            ii + i1.x + __perm\[jj + i1.y + __perm\[kk + i1.z + __perm\[ll + i1.w]]]\n        ] % 32;\n        const int gi2 = __perm\[\n            ii + i2.x + __perm\[jj + i2.y + __perm\[kk + i2.z + __perm\[ll + i2.w]]]\n        ] % 32;\n        const int gi3 = __perm\[\n            ii + i3.x + __perm\[jj + i3.y + __perm\[kk + i3.z + __perm\[ll + i3.w]]]\n        ] % 32;\n        const int gi4 = __perm\[\n            ii + 1 + __perm\[jj + 1 + __perm\[kk + 1 + __perm\[ll + 1]]]\n        ] % 32;\n\n        float n0, n1, n2, n3, n4;\n        float t0 = 0.6f - dot(x0, x0);\n        if (t0 < 0)\n        \{\n            n0 = 0.0f;\n        \}\n        else\n        \{\n            t0 *= t0;\n            n0 = t0 * t0 * dot(\n                float4(__grad4\[gi0]\[0], __grad4\[gi0]\[1], __grad4\[gi0]\[2], __grad4\[gi0]\[3]),\n                x0\n            );\n        \}\n\n        float t1 = 0.6f - dot(x1, x1);\n        if (t1 < 0)\n        \{\n            n1 = 0.0f;\n        \}\n        else\n        \{\n            t1 *= t1;\n            n1 = t1 * t1 * dot(\n                float4(__grad4\[gi1]\[0], __grad4\[gi1]\[1], __grad4\[gi1]\[2], __grad4\[gi1]\[3]),\n                x1\n            );\n        \}\n\n        float t2 = 0.6f - dot(x2, x2);\n        if (t2 < 0)\n        \{\n            n2 = 0.0f;\n        \}\n        else\n        \{\n            t2 *= t2;\n            n2 = t2 * t2 * dot(\n                float4(__grad4\[gi2]\[0], __grad4\[gi2]\[1], __grad4\[gi2]\[2], __grad4\[gi2]\[3]),\n                x2\n            );\n        \}\n\n        float t3 = 0.6f - dot(x3, x3);\n        if (t3 < 0)\n        \{\n            n3 = 0.0f;\n        \}\n        else\n        \{\n            t3 *= t3;\n            n3 = t3 * t3 * dot(\n                float4(__grad4\[gi3]\[0], __grad4\[gi3]\[1], __grad4\[gi3]\[2], __grad4\[gi3]\[3]),\n                x3\n            );\n        \}\n\n        float t4 = 0.6f - dot(x4, x4);\n        if (t4 < 0)\n        \{\n            n4 = 0.0f;\n        \}\n        else \{\n            t4 *= t4;\n            n4 = t4 * t4 * dot(\n                float4(__grad4\[gi4]\[0], __grad4\[gi4]\[1], __grad4\[gi4]\[2], __grad4\[gi4]\[3]),\n                x4\n            );\n        \}\n\n        return 27.0f * (n0 + n1 + n2 + n3 + n4);\n    \}\n\n\n    //\n    // Use the perlin simplex noise\n    //\n\n\n    /**\n     * fBM noise.\n     *\n     * @arg position: The position to seed the noise.\n     *\n     * @returns: The noise value in the range \[-1, 1].\n     */\n    float fractalBrownianMotionNoise(const float3 &position)\n    \{\n        const float4 position4d = float4(\n            position.x,\n            position.y,\n            position.z,\n            0.0f\n        );\n        float output = 0.0f;\n        float frequency = _lacunarity;\n        float amplitude = 1.0f;\n        float denom = 0.0f;\n        float4 translation;\n        float4 scale;\n\n        for (int octave=0; octave < _octaves; octave++)\n        \{\n            const float octaveFraction = octave / _octaves;\n            scale = (\n                (_highFrequencyScale * octaveFraction)\n                + (_lowFrequencyScale * (1.0f - octaveFraction))\n            );       \n            translation = __translation + (\n                (_highFrequencyTranslation * octaveFraction)\n                + (_lowFrequencyTranslation * (1.0f - octaveFraction))\n            );\n\n            output += amplitude * perlinSimplexNoise(\n                (position4d * scale + translation) * frequency / _size\n            );\n\n            frequency *= _lacunarity;\n            denom += amplitude;\n            amplitude *= _gain;\n        \}\n\n        return pow(fabs(output / denom), 1.0f / _gamma);\n    \}\n\n\n    /**\n     * Turbulence noise.\n     *\n     * @arg position: The position to seed the noise.\n     *\n     * @returns: The noise value in the range \[0, 1].\n     */\n    float turbulenceNoise(const float3 &position)\n    \{\n        const float4 position4d = float4(\n            position.x,\n            position.y,\n            position.z,\n            0.0f\n        );\n        float output = 0.0f;\n        float frequency = _lacunarity;\n        float amplitude = 1.0f;\n        float denom = 0.0f;\n        float4 translation;\n        float4 scale;\n\n        for (int octave=0; octave < _octaves; octave++)\n        \{\n            const float octaveFraction = octave / _octaves;\n            scale = (\n                (_highFrequencyScale * octaveFraction)\n                + (_lowFrequencyScale * (1.0f - octaveFraction))\n            );       \n            translation = __translation + (\n                (_highFrequencyTranslation * octaveFraction)\n                + (_lowFrequencyTranslation * (1.0f - octaveFraction))\n            );\n\n            output += fabs(\n                amplitude * perlinSimplexNoise(\n                    (position4d * scale + translation) * frequency / _size\n                )\n            );\n\n            frequency *= _lacunarity;\n            denom += amplitude;\n            amplitude *= _gain;\n        \}\n\n        return pow(output / denom, 1.0f / _gamma);\n    \}\n\n\n    /**\n     * Create a ray out of the camera. It will be either a standard ray,\n     * a latlong ray, or a ray that will result in depth of field.\n     *\n     * @arg seed: The seed to use in randomization.\n     * @arg pixelLocation: The x, and y locations of the pixel.\n     * @arg rayOrigin: The location to store the origin of the new ray.\n     * @arg rayDirection: The location to store the direction of the new\n     *     ray.\n     */\n    void getCameraRay(\n            const float2 &seed,\n            const float2 &pixelLocation,\n            float3 &rayOrigin,\n            float3 &rayDirection)\n    \{\n        const float2 uvCoordinates = pixelsToUV(\n            pixelLocation + random(seed),\n            float2(_formatWidth, _formatHeight)\n        );\n        if (_latLong)\n        \{\n            createLatLongCameraRay(\n                _cameraWorldMatrix,\n                uvCoordinates,\n                rayOrigin,\n                rayDirection\n            );\n        \}\n        else if (_depthOfFieldEnabled)\n        \{\n            createCameraRay(\n                _cameraWorldMatrix,\n                __inverseCameraProjectionMatrix,\n                uvCoordinates,\n                __aperture,\n                _focalDistance,\n                seed,\n                rayOrigin,\n                rayDirection\n            );\n        \}\n        else\n        \{\n            createCameraRay(\n                _cameraWorldMatrix,\n                __inverseCameraProjectionMatrix,\n                uvCoordinates,\n                rayOrigin,\n                rayDirection\n            );\n        \}\n    \}\n\n\n    /**\n     * Compute the minimum distance to an object in the scene.\n     *\n     * @arg rayOrigin: The origin position of the ray.\n     * @arg pixelFootprint: A value proportional to the amount of world\n     *     space that fills a pixel, like the distance from camera.\n     *\n     * @returns: The minimum distance to an object in the scene.\n     */\n    float getMinDistanceToObjectInScene(const float3 &point)\n    \{\n        if (_enableSphericalRamp)\n        \{\n            return distanceToSphere(\n                point - _sphericalRampPosition,\n                _sphericalRampRadii.y\n            );\n        \}\n        else if (_enablePlanarRamp)\n        \{\n            return max(\n                distanceToPlane(\n                    point - (_planePosition + __planeNormal * min(_planarRamp.x, _planarRamp.w)),\n                    -__planeNormal\n                ),\n                distanceToPlane(\n                    point - (_planePosition + __planeNormal * max(_planarRamp.x, _planarRamp.w)),\n                    __planeNormal\n                )\n            );\n        \}\n        else\n        \{\n            const float3 toBoxCenter = point - _boxRampPosition;\n            return distanceToRectangularPrism(\n                matmul(__inverseBoxRotMatrix, toBoxCenter),\n                _boxRampDimensions.x,\n                _boxRampDimensions.y,\n                _boxRampDimensions.z\n            ) - _boxRampFalloff;\n        \}\n    \}\n\n\n    /**\n     * Estimate the surface normal at the closest point on the closest\n     * object to a point\n     *\n     * @arg point: The point near which to get the surface normal\n     * @arg pixelFootprint: A value proportional to the amount of world\n     *     space that fills a pixel, like the distance from camera.\n     *\n     * @returns: The normalized surface normal.\n     */\n    float3 estimateSurfaceNormal(const float3 &point)\n    \{\n        return normalize(\n            __offset0 * getMinDistanceToObjectInScene(\n                point + __offset0 * _hitTolerance\n            )\n            + __offset1 * getMinDistanceToObjectInScene(\n                point + __offset1 * _hitTolerance\n            )\n            + __offset2 * getMinDistanceToObjectInScene(\n                point + __offset2 * _hitTolerance\n            )\n            + __offset3 * getMinDistanceToObjectInScene(\n                point + __offset3 * _hitTolerance\n            )\n        );\n    \}\n\n\n    void computeDepthAndSampleStep(\n        const float2 &seed,\n        const float3 &rayOrigin,\n        const float3 &rayDirection,\n        float &initialDepth,\n        float &sampleStep\n    ) \{\n        if (_enableDepthRamp)\n        \{\n            sampleStep = __depthSampleStep;\n            initialDepth = _depthRamp.x;\n        \}\n        else if (!__enableRaymarching)\n        \{\n            initialDepth = 0.0f;\n        \}\n\n        if (!__enableRaymarching)\n        \{\n            initialDepth += random(seed.x + seed.y) * sampleStep;\n            return;\n        \}\n\n        float pixelFootprint = _hitTolerance;\n        float distance = 0.0f;\n        float stepDistance = 0.0f;\n        bool hitSurface = false;\n        float3 position = rayOrigin;\n\n        while (distance < fabs(_maxDistance))\n        \{\n            const float signedDistance = getMinDistanceToObjectInScene(position);\n\n            if(distance == 0.0f && signedDistance <= 0.0f)\n            \{\n                hitSurface = true;\n                initialDepth = 0.0f;\n            \}\n\n            stepDistance = fabs(signedDistance);\n            distance += stepDistance;\n            position += stepDistance * rayDirection;\n\n            if (stepDistance < pixelFootprint)\n            \{\n                if (hitSurface)\n                \{\n                    sampleStep = min(\n                        sampleStep,\n                        (distance - initialDepth) / (float) _samplesPerRay\n                    );\n                    if (sampleStep == 0.0f)\n                    \{\n                        sampleStep = _maxDistance / (float) _samplesPerRay;\n                    \}\n                    initialDepth += random(seed.x + seed.y) * sampleStep;\n                    return;\n                \}\n                hitSurface = true;\n                initialDepth = min(initialDepth, distance);\n\n                const float3 normal = estimateSurfaceNormal(position + stepDistance * rayDirection);\n                position += 2.0f * pixelFootprint * (rayDirection - normal);\n                pixelFootprint = _hitTolerance;\n                continue;\n            \}\n\n            pixelFootprint += _hitTolerance * stepDistance;\n        \}\n\n        if (hitSurface)\n        \{\n            sampleStep = min(\n                sampleStep,\n                (distance - initialDepth) / (float) _samplesPerRay\n            );\n            initialDepth += random(seed.x + seed.y) * sampleStep;\n        \}\n        else\n        \{\n            initialDepth = -1.0f;\n        \}\n    \}\n\n\n    /**\n     * Compute a noise value.\n     *\n     * @arg pos: The x, and y location we are currently processing.\n     */\n    void process(int2 pos)\n    \{\n        float2 pixelLocation = float2(pos.x, pos.y);\n        SampleType(seeds) seedPixel = seeds();\n        float2 seed = float2(seedPixel.x, seedPixel.y) + RAND_CONST_0 * pixelLocation;\n\n        float4 resultPixel = float4(0.0f);\n\n        // Generate a ray from the camera\n        float3 rayOrigin;\n        float3 rayDirection;\n        getCameraRay(\n            seed,\n            pixelLocation,\n            rayOrigin,\n            rayDirection\n        );\n\n        // Set the depth to the start of the depth ramp and add a random offset\n        // to eliminate layer lines\n        float depth = _maxDistance;\n        float sampleStep = _maxDistance / (float) _samplesPerRay;\n        computeDepthAndSampleStep(\n            seed,\n            rayOrigin + rayDirection * _nearPlane,\n            rayDirection,\n            depth,\n            sampleStep\n        );\n\n        if (depth < 0.0f)\n        \{\n            dst() = resultPixel;\n            return;\n        \}\n\n        rayOrigin += depth * rayDirection;\n\n        depth += (1.0f + _individualSample) * sampleStep;\n        rayOrigin += (1.0f + _individualSample) * rayDirection * sampleStep;\n        for (int sample=0; sample <= (int) _secondSample; sample++)\n        \{\n            float ramp = 1.0f;\n\n            float adjustedDepth = depth;\n            if (_useCameraDepth)\n            \{\n                adjustedDepth = fabs(matmul(\n                    __inverseCameraWorldMatrix,\n                    float4(rayOrigin.x, rayOrigin.y, rayOrigin.z, 1.0f)\n                )\[2]);\n            \}\n\n            resultPixel\[sample * 2 + 1] = adjustedDepth;\n\n            if (_enableSphericalRamp)\n            \{\n                const float minDistanceToSphere = distanceToSphere(\n                    rayOrigin - _sphericalRampPosition,\n                    _sphericalRampRadii.x\n                );\n                if (minDistanceToSphere >= __sphericalRampFalloffDistance)\n                \{\n                    resultPixel\[sample * 2] = 0.0f;\n                    continue;\n                \}\n                else if (minDistanceToSphere > 0.0f)\n                \{\n                    ramp *= (\n                        (__sphericalRampFalloffDistance - minDistanceToSphere)\n                        / __sphericalRampFalloffDistance\n                    );\n                \}\n                if (_sphericalFalloffPower != 0.0f)\n                \{\n                    ramp /= pow(\n                        max(\n                            1e-6,\n                            fabs(\n                                _sphericalFalloffOffset\n                                + minDistanceToSphere\n                                + _sphericalRampRadii.x\n                            )\n                        ),\n                        _sphericalFalloffPower\n                    );\n                \}\n            \}\n            else if (_enablePlanarRamp)\n            \{\n                // Apply the scaling specified by the planar ramp\n                const float minDistanceToPlane = distanceToPlane(\n                    rayOrigin - _planePosition,\n                    __planeNormal\n                );\n                if (\n                    minDistanceToPlane < _planarRamp.x\n                    || minDistanceToPlane >= _planarRamp.w\n                ) \{\n                    resultPixel\[sample * 2] = 0.0f;\n                    continue;\n                \}\n                else if (minDistanceToPlane < _planarRamp.y)\n                \{\n                    ramp *= (\n                        (minDistanceToPlane - _planarRamp.y)\n                        / (_planarRamp.y - _planarRamp.x)\n                        + 1.0f\n                    );\n                \}\n                else if (minDistanceToPlane > _planarRamp.z)\n                \{\n                    ramp *= (\n                        (_planarRamp.w - minDistanceToPlane)\n                        / (_planarRamp.w - _planarRamp.z)\n                    );\n                \}\n                if (_planarFalloffPower != 0.0f)\n                \{\n                    ramp /= pow(\n                        max(\n                            1e-6,\n                            fabs(_planarFalloffOffset + minDistanceToPlane)\n                        ),\n                        _planarFalloffPower\n                    );\n                \}\n            \}\n            else if (_enableBoxRamp)\n            \{\n                const float3 toBoxCenter = rayOrigin - _boxRampPosition;\n                const float minDistanceToBox = distanceToRectangularPrism(\n                    matmul(__inverseBoxRotMatrix, toBoxCenter),\n                    _boxRampDimensions.x,\n                    _boxRampDimensions.y,\n                    _boxRampDimensions.z\n                );\n                if (minDistanceToBox >= _boxRampFalloff)\n                \{\n                    resultPixel\[sample * 2] = 0.0f;\n                    continue;\n                \}\n                else if (minDistanceToBox > 0.0f)\n                \{\n                    ramp *= (_boxRampFalloff - minDistanceToBox) / _boxRampFalloff;\n                \}\n                if (_boxFalloffPower != 0.0f)\n                \{\n                    ramp /= pow(\n                        max(\n                            1e-6,\n                            _boxFalloffOffset + length(toBoxCenter)\n                        ),\n                        _boxFalloffPower\n                    );\n                \}\n            \}\n\n            if (_enableDepthRamp)\n            \{\n                // Apply the scaling specified by the depth ramp\n                if (adjustedDepth < _depthRamp.y)\n                \{\n                    ramp *= (\n                        (adjustedDepth - _depthRamp.y)\n                        / (_depthRamp.y - _depthRamp.x)\n                        + 1.0f\n                    );\n                \}\n                else if (adjustedDepth > _depthRamp.z)\n                \{\n                    ramp *= (_depthRamp.w - adjustedDepth) / (_depthRamp.w - _depthRamp.z);\n                \}\n            \}\n\n            // Compute the noise value at this position\n            float noiseValue = _density * ramp;\n            if (_noiseType == FBM_NOISE)\n            \{\n                noiseValue *= fractalBrownianMotionNoise(rayOrigin);\n            \}\n            else\n            \{\n                noiseValue *= turbulenceNoise(rayOrigin);\n            \}\n\n            resultPixel\[sample * 2] = noiseValue;\n\n            depth += sampleStep;\n            rayOrigin += rayDirection * sampleStep;\n        \}\n\n        dst() = resultPixel;\n    \}\n\};\n"
  rebuild ""
  SingleSampleFogKernel_FocalLength {{parent.DummyCam.focal(floor(frame))}}
  SingleSampleFogKernel_HorizontalAperture {{parent.DummyCam.haperture(floor(frame))}}
  SingleSampleFogKernel_NearPlane {{parent.DummyCam.near(floor(frame))}}
  SingleSampleFogKernel_FarPlane {{parent.DummyCam.far(floor(frame))}}
  SingleSampleFogKernel_CameraWorldMatrix {
      {{parent.DummyCam.world_matrix(floor(frame))} {parent.DummyCam.world_matrix(floor(frame))} {parent.DummyCam.world_matrix(floor(frame))} {parent.DummyCam.world_matrix(floor(frame))}}
      {{parent.DummyCam.world_matrix(floor(frame))} {parent.DummyCam.world_matrix(floor(frame))} {parent.DummyCam.world_matrix(floor(frame))} {parent.DummyCam.world_matrix(floor(frame))}}
      {{parent.DummyCam.world_matrix(floor(frame))} {parent.DummyCam.world_matrix(floor(frame))} {parent.DummyCam.world_matrix(floor(frame))} {parent.DummyCam.world_matrix(floor(frame))}}
      {{parent.DummyCam.world_matrix(floor(frame))} {parent.DummyCam.world_matrix(floor(frame))} {parent.DummyCam.world_matrix(floor(frame))} {parent.DummyCam.world_matrix(floor(frame))}}
    }
  SingleSampleFogKernel_FocalDistance {{parent.DummyCam.focal_point(floor(frame))}}
  SingleSampleFogKernel_fstop {{parent.DummyCam.fstop(floor(frame))}}
  SingleSampleFogKernel_EnableDepthOfField {{parent.depth_of_field}}
  SingleSampleFogKernel_OutputLatLong {{parent.latlong}}
  SingleSampleFogKernel_UseCameraDepth {{parent.camera_space}}
  SingleSampleFogKernel_ScreenWidth {{"proxy? input0.width*proxy_scale: input0.width"}}
  SingleSampleFogKernel_ScreenHeight {{"proxy? input0.height * proxy_scale : input0.height"}}
  SingleSampleFogKernel_IndividualSample {{"frame % 1 * parent.samples_per_ray"}}
  SingleSampleFogKernel_Density {{"parent.density * 50 / parent.samples_per_ray"}}
  SingleSampleFogKernel_SamplesPerRay {{parent.samples_per_ray}}
  SingleSampleFogKernel_EnableDepthRamp {{parent.enable_depth_ramp}}
  SingleSampleFogKernel_SampleDepthRamp {{parent.depth_ramp_dummy.range.A} {parent.depth_ramp_dummy.range.B} {parent.depth_ramp_dummy.range.C} {parent.depth_ramp_dummy.range.D}}
  SingleSampleFogKernel_SamplePlanarRamp {{-parent.in-parent.in_falloff} {-parent.in} {parent.out} {parent.out+parent.out_falloff}}
  SingleSampleFogKernel_EnablePlanarRamp {{parent.enable_planar_ramp}}
  SingleSampleFogKernel_PlanePosition {{parent.plane_point.x} {parent.plane_point.y} {parent.plane_point.z}}
  SingleSampleFogKernel_PlaneNormal {{parent.plane_normal.x} {parent.plane_normal.y} {parent.plane_normal.z}}
  SingleSampleFogKernel_PlanarFalloffPower {{parent.plane_falloff_power}}
  SingleSampleFogKernel_PlanarFalloffOffset {{parent.plane_falloff_offset}}
  SingleSampleFogKernel_EnableSphericalRamp {{parent.enable_spherical_ramp}}
  SingleSampleFogKernel_SphericalRampPosition {{parent.spherical_ramp_position.x} {parent.spherical_ramp_position.y} {parent.spherical_ramp_position.z}}
  SingleSampleFogKernel_SphericalRampRadii {{parent.spherical_ramp_start_radius} {parent.spherical_ramp_end_radius}}
  SingleSampleFogKernel_SphericalFalloffPower {{parent.sphere_falloff_power}}
  SingleSampleFogKernel_SphericalFalloffOffset {{parent.sphere_falloff_offset}}
  SingleSampleFogKernel_BoxRampPosition {{parent.box_ramp_position} {parent.box_ramp_position} {parent.box_ramp_position}}
  SingleSampleFogKernel_BoxRampRotation {{parent.box_ramp_rotation} {parent.box_ramp_rotation} {parent.box_ramp_rotation}}
  SingleSampleFogKernel_BoxRampDimensions {{parent.knob.width} {parent.knob.height} {parent.depth}}
  SingleSampleFogKernel_BoxRampFalloff {{parent.box_falloff_distance}}
  SingleSampleFogKernel_EnableBoxRamp {{parent.enable_box_ramp}}
  SingleSampleFogKernel_BoxFalloffPower {{parent.box_falloff_power}}
  SingleSampleFogKernel_BoxFalloffOffset {{parent.box_falloff_offset}}
  SingleSampleFogKernel_DoSecondSample {{"parent.samples_per_ray % 2 == 0 || frame % 1 * parent.samples_per_ray < parent.samples_per_ray - 1"}}
  SingleSampleFogKernel_Size {{parent.size}}
  SingleSampleFogKernel_NoiseType {{parent.type}}
  SingleSampleFogKernel_Translation {{-parent.translation} {-parent.translation} {-parent.translation}}
  SingleSampleFogKernel_Octaves {{parent.octaves}}
  SingleSampleFogKernel_Lacunarity {{parent.lacunarity}}
  SingleSampleFogKernel_Gain {{parent.gain}}
  SingleSampleFogKernel_Gamma {{parent.gamma}}
  SingleSampleFogKernel_LowFrequencyScale {{parent.low_frequency_scale} {parent.low_frequency_scale} {parent.low_frequency_scale} {parent.low_frequency_scale}}
  SingleSampleFogKernel_HighFrequencyScale {{parent.high_frequency_scale} {parent.high_frequency_scale} {parent.high_frequency_scale} {parent.high_frequency_scale}}
  SingleSampleFogKernel_LowFrequencyTranslation {{"parent.low_frequency_translation + parent.low_frequency_evolve * frame / 100"} {"parent.low_frequency_translation + parent.low_frequency_evolve * frame / 100"} {"parent.low_frequency_translation + parent.low_frequency_evolve * frame / 100"} {"parent.low_frequency_translation + parent.low_frequency_evolve * frame / 100"}}
  SingleSampleFogKernel_HighFrequencyTranslation {{"parent.high_frequency_translation + parent.high_frequency_evolve * frame / 100"} {"parent.high_frequency_translation + parent.high_frequency_evolve * frame / 100"} {"parent.high_frequency_translation + parent.high_frequency_evolve * frame / 100"} {"parent.high_frequency_translation + parent.high_frequency_evolve * frame / 100"}}
  SingleSampleFogKernel_HitTolerance {{parent.hit_tolerance}}
  SingleSampleFogKernel_MaxDistance {{parent.max_distance}}
  rebuild_finalise ""
  name BlinkScript5
  xpos 2080
  ypos 1148
 }
 Group {
  name deep_blender
  knobChanged "\n"
  xpos 2080
  ypos 1264
  addUserKnob {20 User}
  addUserKnob {3 samples_per_ray}
  samples_per_ray {{parent.samples_per_ray}}
 }
  Input {
   inputs 0
   name Input1
   xpos 574
   ypos 664
  }
  TimeWarp {
   lookup {{"frame + (1/parent.samples_per_ray*0)"}}
   time ""
   filter none
   name TimeWarp0
   xpos 574
   ypos 812
  }
  Expression {
   expr0 r
   expr1 r
   expr2 r
   channel3 depth
   expr3 1/g
   name Expression0
   xpos 575
   ypos 860
  }
  Expression {
   expr3 r
   name ExprAlpha0
   xpos 575
   ypos 908
  }
  DeepFromImage {
   premult true
   name DeepFromImage0
   xpos 575
   ypos 957
  }
  DeepMerge2 {
   drop_hidden true
   name DeepMerge
   xpos 575
   ypos 1056
  }
  Output {
   name Output1
   xpos 575
   ypos 1154
  }
 end_group
 Dot {
  name Dot16
  xpos 2114
  ypos 1391
 }
set Na2ba580 [stack 0]
 Dot {
  name Dot17
  xpos 2243
  ypos 1391
 }
 Dot {
  name Dot15
  xpos 2243
  ypos 1648
 }
 Input {
  inputs 0
  name deep_holdout
  xpos 1127
  ypos 615
  number 2
 }
 Dot {
  name Dot5
  xpos 1161
  ypos 744
 }
set Na2cdef0 [stack 0]
 Dot {
  name Dot6
  xpos 998
  ypos 744
 }
set Na2d2d90 [stack 0]
 Dot {
  name Dot12
  xpos 795
  ypos 744
 }
 Dot {
  name Dot13
  xpos 795
  ypos 1475
 }
push $Na2ba580
 DeepMerge2 {
  inputs 2
  operation holdout
  name DeepMerge1
  xpos 2080
  ypos 1472
 }
 DeepToImage2 {
  name DeepToImage3
  xpos 2080
  ypos 1502
 }
 Dot {
  name Dot14
  xpos 2114
  ypos 1588
 }
push $Na2d2d90
 DeepCrop {
  use_znear false
  zfar {{"parent.enable_depth_ramp ? parent.depth_ramp_dummy.range.A : parent.DummyCam.near"}}
  bbox {409.6000061 216 1638.400024 864}
  use_bbox false
  name DeepCrop2
  xpos 964
  ypos 801
 }
 DeepToImage2 {
  name DeepToImage2
  xpos 964
  ypos 852
 }
 Reformat {
  format {{{parent.format_.format}}}
  pbb true
  name Reformat3
  xpos 964
  ypos 936
 }
 Crop {
  box {{min(bbox.x,0)} {min(bbox.y,0)} {max(bbox.r,width)} {max(bbox.t,height)}}
  crop false
  name Crop3
  xpos 964
  ypos 960
 }
 Dot {
  name Dot7
  xpos 998
  ypos 1360
 }
push $Na2cdef0
 DeepCrop {
  znear {{"parent.enable_depth_ramp ? parent.depth_ramp_dummy.range.A : parent.DummyCam.near"}}
  zfar {{"parent.enable_depth_ramp ? parent.depth_ramp_dummy.range.D : parent.max_distance"}}
  bbox {409.6000061 216 1638.400024 864}
  use_bbox false
  name DeepCrop1
  xpos 1127
  ypos 800
 }
 DeepToImage2 {
  name DeepToImage1
  xpos 1127
  ypos 853
 }
 Shuffle {
  in depth
  in2 rgba
  alpha alpha2
  name shuffle1
  xpos 1127
  ypos 911
 }
 Reformat {
  format {{{parent.format_.format}}}
  pbb true
  name Reformat2
  xpos 1127
  ypos 935
 }
 Crop {
  box {{min(bbox.x,0)} {min(bbox.y,0)} {max(bbox.r,width)} {max(bbox.t,height)}}
  crop false
  name Crop2
  xpos 1127
  ypos 959
 }
 Crop {
  box {{parent.Crop4.box} {parent.Crop4.box} {parent.Crop4.box} {parent.Crop4.box}}
  crop false
  name Crop6
  xpos 1127
  ypos 983
 }
 NoTimeBlur {
  name NoTimeBlur2
  xpos 1127
  ypos 1025
  disable {{!parent.enable_motion_blur}}
 }
 Dot {
  name Dot8
  xpos 1161
  ypos 1072
 }
 Input {
  inputs 0
  name holdout
  xpos 1419
  ypos 620
  number 1
 }
 Dot {
  name Dot4
  xpos 1453
  ypos 744
 }
set Na384850 [stack 0]
 Dot {
  name Dot10
  xpos 1357
  ypos 744
 }
 Dot {
  name Dot9
  xpos 1357
  ypos 862
 }
push $Na384850
 Expression {
  expr1 0
  expr2 0
  name Expression1
  xpos 1419
  ypos 814
 }
 Copy {
  inputs 2
  from0 depth.Z
  to0 rgba.red
  name Copy1
  xpos 1419
  ypos 853
  disable {{"\[exists parent.input1] ? 0 : 1"}}
 }
 Reformat {
  format {{{parent.format_.format}}}
  pbb true
  name Reformat1
  xpos 1419
  ypos 930
 }
 Crop {
  box {{min(bbox.x,0)} {min(bbox.y,0)} {max(bbox.r,width)} {max(bbox.t,height)}}
  crop false
  name Crop1
  xpos 1419
  ypos 954
 }
 Crop {
  box {{parent.Crop4.box} {parent.Crop4.box} {parent.Crop4.box} {parent.Crop4.box}}
  crop false
  name Crop5
  xpos 1419
  ypos 978
 }
 NoTimeBlur {
  name NoTimeBlur1
  xpos 1419
  ypos 1025
  disable {{!parent.enable_motion_blur}}
 }
 Switch {
  inputs 2
  which {{parent.holdout_mode}}
  name Switch2
  xpos 1419
  ypos 1069
 }
 Dot {
  name Dot1
  xpos 1453
  ypos 1158
 }
push $Na9ad360
 BlinkScript {
  inputs 2
  kernelSourceFile /home/ob1/software/nuke/blink_fog_3d/src/blink/kernels/blink_fog_3d.cpp
  kernelSource "// Copyright 2024 by Owen Bulka.\n// All rights reserved.\n// This file is released under the \"MIT License Agreement\".\n// Please see the LICENSE.md file that should have been included as part\n// of this package.\n\n\n//\n// Math operations\n//\n\n\n/**\n * The maximum component of a vector.\n *\n * @arg vector: The vector.\n *\n * @returns: The maximum component of the vector.\n */\ninline float maxComponent(const float3 &vector)\n\{\n    return max(vector.x, max(vector.y, vector.z));\n\}\n\n\n/**\n * The negative part of the vector. Ie. any positive values will be 0,\n * and the negative values will be positive.\n *\n * @arg vector: The vector.\n *\n * @returns: The negative part of the vector.\n */\ninline float negativePart(const float value)\n\{\n    return -min(value, 0.0f);\n\}\n\n\n/**\n * The positive part of the vector. Ie. any negative values will be 0.\n *\n * @arg vector: The vector.\n *\n * @returns: The positive part of the vector.\n */\ninline float3 positivePart(const float3 &vector)\n\{\n    return max(vector, float3(0));\n\}\n\n\n/**\n * Compute the fractional portion of the value. Ex. 3.5 returns 0.5\n *\n * @arg value: The value to get the fractional portion of.\n *\n * @returns: The fractional portion of the value.\n */\ninline float fract(const float value)\n\{\n    return value - floor(value);\n\}\n\n\n/**\n * Saturate a value ie. clamp between 0 and 1\n *\n * @arg value: The value to saturate\n *\n * @returns: The clamped value\n */\ninline float saturate(float value)\n\{\n    return clamp(value, 0.0f, 1.0f);\n\}\n\n\n/**\n * Multiply a 4d vector by a 4x4 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline void matmul(const float4x4 &m, const float4 &v, float4 &out)\n\{\n    for (int i=0; i < 4; i++)\n    \{\n        out\[i] = 0;\n\n        for (int j=0; j < 4; j++)\n        \{\n            out\[i] += m\[i]\[j] * v\[j];\n        \}\n    \}\n\}\n\n\n/**\n * Multiply a 4d vector by a 4x4 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline float4 matmul(const float4x4 &m, const float4 &v)\n\{\n    float4 out;\n    for (int i=0; i < 4; i++)\n    \{\n        out\[i] = 0;\n\n        for (int j=0; j < 4; j++)\n        \{\n            out\[i] += m\[i]\[j] * v\[j];\n        \}\n    \}\n\n    return out;\n\}\n\n\n/**\n * Multiply a 3d vector by a 3x3 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline float3 matmul(const float3x3 &m, const float3 &v)\n\{\n    return float3(\n        m\[0]\[0] * v.x + m\[0]\[1] * v.y + m\[0]\[2] * v.z,\n        m\[1]\[0] * v.x + m\[1]\[1] * v.y + m\[1]\[2] * v.z,\n        m\[2]\[0] * v.x + m\[2]\[1] * v.y + m\[2]\[2] * v.z\n    );\n\}\n\n\n/**\n * Convert the uv position in a latlong image to angles.\n *\n * @arg uvPosition: The UV position.\n *\n * @returns: The equivalent angles in radians.\n */\ninline float2 uvPositionToAngles(const float2 &uvPosition)\n\{\n    return float2(\n        (uvPosition.x + 1.0f) * PI,\n        (1.0f - uvPosition.y) * PI / 2.0f\n    );\n\}\n\n\n/**\n * Convert location of a pixel in an image into UV.\n *\n * @arg pixelLocation: The x, and y positions of the pixel.\n * @arg format: The image width, and height.\n *\n * @returns: The UV position.\n */\ninline float2 pixelsToUV(const float2 &pixelLocation, const float2 &format)\n\{\n    return float2(\n        2.0f * pixelLocation.x / format.x - 1.0f,\n        2.0f * pixelLocation.y / format.y - 1.0f\n    );\n\}\n\n\n/**\n * Convert a spherical unit vector (unit radius) to cartesion.\n *\n * @arg angles: The spherical angles in radians.\n *\n * @returns: The equivalent cartesion vector.\n */\ninline float3 sphericalUnitVectorToCartesion(const float2 &angles)\n\{\n    const float sinPhi = sin(angles.y);\n    return float3(\n        cos(angles.x) * sinPhi,\n        cos(angles.y),\n        sin(angles.x) * sinPhi\n    );\n\}\n\n\n/**\n * Get the position component of a world matrix.\n *\n * @arg worldMatrix: The world matrix.\n * @arg position: The location to store the position.\n */\ninline void positionFromWorldMatrix(const float4x4 &worldMatrix, float3 &position)\n\{\n    position = float3(\n        worldMatrix\[0]\[3],\n        worldMatrix\[1]\[3],\n        worldMatrix\[2]\[3]\n    );\n\}\n\n\n/**\n * Get the rotation component of a world matrix.\n *\n * @arg worldMatrix: The world matrix.\n * @arg rotation: The location to store the rotation.\n */\ninline void rotationFromWorldMatrix(const float4x4 &worldMatrix, float3x3 &rotationMatrix)\n\{\n    rotationMatrix\[0]\[0] = worldMatrix\[0]\[0];\n    rotationMatrix\[0]\[1] = worldMatrix\[0]\[1];\n    rotationMatrix\[0]\[2] = worldMatrix\[0]\[2];\n    rotationMatrix\[1]\[0] = worldMatrix\[1]\[0];\n    rotationMatrix\[1]\[1] = worldMatrix\[1]\[1];\n    rotationMatrix\[1]\[2] = worldMatrix\[1]\[2];\n    rotationMatrix\[2]\[0] = worldMatrix\[2]\[0];\n    rotationMatrix\[2]\[1] = worldMatrix\[2]\[1];\n    rotationMatrix\[2]\[2] = worldMatrix\[2]\[2];\n\}\n\n\n/**\n * Get a rotation matrix from radian angle values in ZYX order.\n *\n * @arg angles: The rotation angles in radians.\n * @arg out: The location to store the rotation matrix.\n */\ninline void rotationMatrix(const float3 &angles, float3x3 &out)\n\{\n    const float3 cosAngles = cos(angles);\n    const float3 sinAngles = sin(angles);\n\n    // Why tf can I not init a float3x3 normally??\n    out\[0]\[0] = cosAngles.y * cosAngles.z;\n    out\[0]\[1] = sinAngles.x * sinAngles.y * cosAngles.z - cosAngles.x * sinAngles.z;\n    out\[0]\[2] = cosAngles.x * sinAngles.y * cosAngles.z + sinAngles.x * sinAngles.z;\n    out\[1]\[0] = cosAngles.y * sinAngles.z;\n    out\[1]\[1] = sinAngles.x * sinAngles.y * sinAngles.z + cosAngles.x * cosAngles.z;\n    out\[1]\[2] = cosAngles.x * sinAngles.y * sinAngles.z - sinAngles.x * cosAngles.z;\n    out\[2]\[0] = -sinAngles.y;\n    out\[2]\[1] = sinAngles.x * cosAngles.y;\n    out\[2]\[2] = cosAngles.x * cosAngles.y;\n\}\n\n\n//\n// Randomization functions\n//\n\n\n// Some random constants on the interval \[1, 2]\n#define RAND_CONST_0 1.571411510193971f\n#define RAND_CONST_1 1.268632820084931f\n#define RAND_CONST_2 1.7880365647937733f\n#define RAND_CONST_3 1.3546987471558234f\n#define RAND_CONST_4 1.4365958250848703f\n#define RAND_CONST_5 1.7045380669435368f\n\n\n/**\n * Get a random value on the interval \[0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval \[0, 1].\n */\ninline float random(const float seed)\n\{\n    return fract(sin(73.1f * seed + 91.3458f) * 47453.5453f);\n\}\n\n\n/**\n * Get a random value on the interval \[0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval \[0, 1].\n */\ninline float2 random(const float2 &seed)\n\{\n    return float2(\n        fract(sin(13.157f * seed.x + 71.743f) * 7513.471f),\n        fract(sin(97.519f * seed.y + 113.591f) * 47453.5453f)\n    );\n\}\n\n\n/**\n * Create a random point that lies within the unit circle.\n *\n * @arg seed: The random seed.\n *\n * @returns: A random point, (radius, angle) in the unit circle.\n */\ninline float2 uniformPointInUnitCircle(const float2 &seed)\n\{\n    return float2(sqrt(random(seed.x)), 2.0f * PI * random(seed.y));\n\}\n\n\n/**\n * Sum the elements of a vector.\n *\n * @arg vector: The vector to sum the elements of.\n *\n * @returns: The sum of the vector elements.\n */\ninline float elementSum(const float4 &vector) \{\n    return vector.x + vector.y + vector.z + vector.w;\n\}\n\n\n#define FBM_NOISE 1\n\n\n//\n// Camera Utilities\n//\n\n\n/**\n * Compute the field of view from focal length.\n *\n * @arg focalLength: The focal length.\n *\n * @returns: The equivalent field of view.\n */\ninline float fieldOfView(const float focalLength)\n\{\n    return 2 * atan(1 / focalLength);\n\}\n\n\n/**\n * Compute the aspect ratio from image format.\n *\n * @arg height_: The height of the image.\n * @arg width_: The width of the image.\n *\n * @returns: The aspect ratio.\n */\ninline float aspectRatio(const float height_, const float width_)\n\{\n    return height_ / width_;\n\}\n\n\n/**\n *\n */\ninline float fStopToAperture(const float fStop, const float focalLength)\n\{\n    return focalLength / fStop / 1000.0f;\n\}\n\n\n/**\n * Create a projection matrix for a camera.\n *\n * @arg focalLength: The focal length of the camera.\n * @arg horizontalAperture: The horizontal aperture of the camera.\n * @arg aspect: The aspect ratio of the camera.\n * @arg nearPlane: The distance to the near plane of the camera.\n * @arg farPlane: The distance to the far plane of the camera.\n *\n * @returns: The camera's projection matrix.\n */\nfloat4x4 projectionMatrix(\n        const float focalLength,\n        const float horizontalAperture,\n        const float aspect,\n        const float nearPlane,\n        const float farPlane)\n\{\n    float farMinusNear = farPlane - nearPlane;\n    return float4x4(\n        2 * focalLength / horizontalAperture, 0, 0, 0,\n        0, 2 * focalLength / horizontalAperture / aspect, 0, 0,\n        0, 0, -(farPlane + nearPlane) / farMinusNear, -2 * (farPlane * nearPlane) / farMinusNear,\n        0, 0, -1, 0\n    );\n\}\n\n\n/**\n * Generate a ray out of a camera.\n *\n * @arg cameraWorldMatrix: The camera matrix.\n * @arg inverseProjectionMatrix: The inverse of the projection matrix.\n * @arg uvPosition: The UV position in the resulting image.\n * @arg rayOrigin: Will store the origin of the ray.\n * @arg rayDirection: Will store the direction of the ray.\n */\nvoid createCameraRay(\n        const float4x4 &cameraWorldMatrix,\n        const float4x4 &inverseProjectionMatrix,\n        const float2 &uvPosition,\n        float3 &rayOrigin,\n        float3 &rayDirection)\n\{\n    positionFromWorldMatrix(cameraWorldMatrix, rayOrigin);\n    float4 direction = matmul(\n        inverseProjectionMatrix,\n        float4(uvPosition.x, uvPosition.y, 0, 1)\n    );\n    matmul(\n        cameraWorldMatrix,\n        float4(direction.x, direction.y, direction.z, 0),\n        direction\n    );\n    rayDirection = normalize(float3(direction.x, direction.y, direction.z));\n\}\n\n\n/**\n * Generate a ray out of a camera.\n *\n * @arg cameraWorldMatrix: The camera matrix.\n * @arg inverseProjectionMatrix: The inverse of the projection matrix.\n * @arg uvPosition: The UV position in the resulting image.\n * @arg rayOrigin: Will store the origin of the ray.\n * @arg rayDirection: Will store the direction of the ray.\n */\nvoid createCameraRay(\n        const float4x4 &cameraWorldMatrix,\n        const float4x4 &inverseProjectionMatrix,\n        const float2 &uvPosition,\n        const float aperture,\n        const float focalDistance,\n        const float2 &seed,\n        float3 &rayOrigin,\n        float3 &rayDirection)\n\{\n    createCameraRay(\n        cameraWorldMatrix,\n        inverseProjectionMatrix,\n        uvPosition,\n        rayOrigin,\n        rayDirection\n    );\n\n    const float4 cameraForward4 = matmul(\n        cameraWorldMatrix,\n        float4(0, 0, -1, 0)\n    );\n    const float3 cameraForward = float3(\n        cameraForward4.x,\n        cameraForward4.y,\n        cameraForward4.z\n    );\n    const float4 cameraRight4 = matmul(\n        cameraWorldMatrix,\n        float4(1, 0, 0, 0)\n    );\n    const float3 cameraRight = float3(\n        cameraRight4.x,\n        cameraRight4.y,\n        cameraRight4.z\n    );\n    const float4 cameraUp4 = matmul(\n        cameraWorldMatrix,\n        float4(0, 1, 0, 0)\n    );\n    const float3 cameraUp = float3(\n        cameraUp4.x,\n        cameraUp4.y,\n        cameraUp4.z\n    );\n\n    const float3 focalPlanePoint = rayOrigin + cameraForward * focalDistance;\n    const float3 focalPlaneNormal = -cameraForward;\n\n    const float focalPointDistance = (\n        (dot(focalPlaneNormal, focalPlanePoint) - dot(rayOrigin, focalPlaneNormal))\n        / dot(rayDirection, focalPlaneNormal)\n    );\n    const float3 focalPoint = rayOrigin + focalPointDistance * rayDirection;\n\n    const float2 pointInUnitCircle = uniformPointInUnitCircle(seed);\n    const float2 offset = pointInUnitCircle.x * aperture * float2(\n        cos(pointInUnitCircle.y),\n        sin(pointInUnitCircle.y)\n    );\n\n    rayOrigin += cameraRight * offset.x + cameraUp * offset.y;\n    rayDirection = normalize(focalPoint - rayOrigin);\n\}\n\n\n/**\n * Generate a LatLong ray out of a camera.\n *\n * @arg cameraWorldMatrix: The camera matrix.\n * @arg uvPosition: The UV position in the resulting image.\n * @arg rayOrigin: Will store the origin of the ray.\n * @arg rayDirection: Will store the direction of the ray.\n */\nvoid createLatLongCameraRay(\n        const float4x4 &cameraWorldMatrix,\n        const float2 &uvPosition,\n        float3 &rayOrigin,\n        float3 &rayDirection)\n\{\n    positionFromWorldMatrix(cameraWorldMatrix, rayOrigin);\n    rayDirection = sphericalUnitVectorToCartesion(uvPositionToAngles(uvPosition));\n\n    float3x3 cameraRotation;\n    rotationFromWorldMatrix(cameraWorldMatrix, cameraRotation);\n    rayDirection = matmul(cameraRotation, rayDirection);\n\}\n\n\n// SDFs\n\n\n/**\n * Compute the signed distance along a vector\n *\n * @arg vector: A vector from a point to the nearest surface of an\n *     object.\n *\n * @returns: The signed length of the vector.\n */\ninline float sdfLength(const float3 &vector)\n\{\n    return (\n        length(positivePart(vector))\n        - negativePart(maxComponent(vector))\n    );\n\}\n\n\n/**\n * Compute the min distance from a point to a sphere.\n *\n * @arg position: The point to get the distance to, from the object.\n * @arg radius: The radius of the sphere.\n *\n * @returns: The minimum distance from the point to the shape.\n */\ninline float distanceToSphere(const float3 &position, const float radius)\n\{\n    return length(position) - radius;\n\}\n\n\n/**\n * Compute the min distance from a point to a plane.\n * Anything underneath the plane, as defined by the normal direction\n * pointing above, will be considered inside.\n *\n * @arg position: The point to get the distance to, from the object.\n * @arg normal: The normal direction of the plane.\n *\n * @returns: The minimum distance from the point to the shape.\n */\ninline float distanceToPlane(const float3 &position, const float3 &normal)\n\{\n    return dot(position, normal);\n\}\n\n\n/**\n * Compute the min distance from a point to a rectangular prism.\n * Centered at the origin.\n *\n * @arg position: The point to get the distance to, from the object.\n * @arg width: The width (x) of the prism.\n * @arg height: The height (y) of the prism.\n * @arg depth: The depth (z) of the prism.\n *\n * @returns: The minimum distance from the point to the shape.\n */\ninline float distanceToRectangularPrism(\n        const float3 &position,\n        const float width,\n        const float height,\n        const float depth)\n\{\n    // Only look at positive quadrant, using symmetry\n    const float3 prismToPosition = fabs(position) - float3(width, height, depth) / 2.0f;\n    // Clamp the components that are inside the prism to the surface\n    // before getting the distance\n    return sdfLength(prismToPosition);\n\}\n\n\nkernel FogKernel : ImageComputationKernel<ePixelWise>\n\{\n    // the input which specifies the format, process is called once per pixel\n    // in this image, which also provides random seeds\n    Image<eRead, eAccessPoint, eEdgeNone> seeds;\n    Image<eRead, eAccessPoint, eEdgeNone> depthAOV;\n\n    // the output image\n    Image<eWrite> dst;\n\n\n    param:\n        // These parameters are made available to the user.\n\n        // Camera params\n        float _focalLength;\n        float _horizontalAperture;\n        float _nearPlane;\n        float _farPlane;\n        float4x4 _cameraWorldMatrix;\n        float _focalDistance;\n        float _fStop;\n        bool _depthOfFieldEnabled;\n        bool _latLong;\n        bool _useCameraDepth;\n\n        // Image params\n        float _formatWidth;\n        float _formatHeight;\n        int _raysPerPixel;\n        float _density;\n        int _samplesPerRay;\n\n        bool _enableDepthRamp;\n        float4 _depthRamp;\n\n        float4 _planarRamp;\n        bool _enablePlanarRamp;\n        float3 _planePosition;\n        float3 _planeNormal;\n        float _planarFalloffPower;\n        float _planarFalloffOffset;\n\n        bool _enableSphericalRamp;\n        float3 _sphericalRampPosition;\n        float2 _sphericalRampRadii;\n        float _sphericalFalloffPower;\n        float _sphericalFalloffOffset;\n\n        float3 _boxRampPosition;\n        float3 _boxRampRotation;\n        float3 _boxRampDimensions;\n        float _boxRampFalloff;\n        bool _enableBoxRamp;\n        float _boxFalloffPower;\n        float _boxFalloffOffset;\n\n        // Noise Parameters\n        float _size;\n        int _noiseType;\n        float3 _translation;\n        float _octaves;\n        float _lacunarity;\n        float _gain;\n        float _gamma;\n        float4 _lowFrequencyScale;\n        float4 _highFrequencyScale;\n        float4 _lowFrequencyTranslation;\n        float4 _highFrequencyTranslation;\n\n        bool _invertDepth;\n\n        // Raymarch parameters\n        float _hitTolerance;\n        float _maxDistance;\n\n    local:\n        // These local variables are not exposed to the user.\n        float4x4 __inverseCameraProjectionMatrix;\n        float4x4 __inverseCameraWorldMatrix;\n        float __aperture;\n\n        float4 __translation;\n\n        int __simplex\[64]\[4];\n        int __perm\[512];\n        int __grad4\[32]\[4];\n\n        float __depthSampleStep;\n\n        float __sphericalRampFalloffDistance;\n\n        float3 __planeNormal;\n\n        float3x3 __inverseBoxRotMatrix;\n\n        bool __enableRaymarching;\n\n        float3 __offset0;\n        float3 __offset1;\n        float3 __offset2;\n        float3 __offset3;\n\n\n    /**\n     * Give the parameters labels and default values.\n     */\n    void define()\n    \{\n        // Camera params\n        defineParam(_focalLength, \"FocalLength\", 50.0f);\n        defineParam(_horizontalAperture, \"HorizontalAperture\", 24.576f);\n        defineParam(_nearPlane, \"NearPlane\", 0.1f);\n        defineParam(_farPlane, \"FarPlane\", 10000.0f);\n        defineParam(\n            _cameraWorldMatrix,\n            \"CameraWorldMatrix\",\n            float4x4(\n                1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1\n            )\n        );\n        defineParam(_focalDistance, \"FocalDistance\", 4.0f);\n        defineParam(_fStop, \"fstop\", 16.0f);\n        defineParam(_depthOfFieldEnabled, \"EnableDepthOfField\", true);\n        defineParam(_latLong, \"OutputLatLong\", false);\n        defineParam(_useCameraDepth, \"UseCameraDepth\", false);\n\n        // Image params\n        defineParam(_formatHeight, \"ScreenHeight\", 2160.0f);\n        defineParam(_formatWidth, \"ScreenWidth\", 3840.0f);\n        defineParam(_density, \"Density\", 1.0f);\n        defineParam(_raysPerPixel, \"RaysPerPixel\", 1);\n        defineParam(_samplesPerRay, \"SamplesPerRay\", 5);\n\n        defineParam(_enableDepthRamp, \"EnableDepthRamp\", true);\n        defineParam(_depthRamp, \"SampleDepthRamp\", float4(5.0f, 10.0f, 15.0f, 20.0f));\n\n        defineParam(_planarRamp, \"SamplePlanarRamp\", float4(5.0f, 10.0f, 15.0f, 20.0f));\n        defineParam(_enablePlanarRamp, \"EnablePlanarRamp\", false);\n        defineParam(_planePosition, \"PlanePosition\", float3(0.0f, 0.0f, 0.0f));\n        defineParam(_planeNormal, \"PlaneNormal\", float3(0.0f, 1.0f, 0.0f));\n        defineParam(_planarFalloffPower, \"PlanarFalloffPower\", 0.0f);\n        defineParam(_planarFalloffOffset, \"PlanarFalloffOffset\", 0.0f);\n\n        defineParam(_enableSphericalRamp, \"EnableSphericalRamp\", false);\n        defineParam(_sphericalRampPosition, \"SphericalRampPosition\", float3(0.0f, 0.0f, 0.0f));\n        defineParam(_sphericalRampRadii, \"SphericalRampRadii\", float2(1.0f, 2.0f));\n        defineParam(_sphericalFalloffPower, \"SphericalFalloffPower\", 0.0f);\n        defineParam(_sphericalFalloffOffset, \"SphericalFalloffOffset\", 0.0f);\n\n        defineParam(_boxRampPosition, \"BoxRampPosition\", float3(0.0f, 0.0f, 0.0f));\n        defineParam(_boxRampRotation, \"BoxRampRotation\", float3(0.0f, 0.0f, 0.0f));\n        defineParam(_boxRampDimensions, \"BoxRampDimensions\", float3(1.0f, 1.0f, 1.0f));\n        defineParam(_boxRampFalloff, \"BoxRampFalloff\", 1.0f);\n        defineParam(_enableBoxRamp, \"EnableBoxRamp\", false);\n        defineParam(_boxFalloffPower, \"BoxFalloffPower\", 0.0f);\n        defineParam(_boxFalloffOffset, \"BoxFalloffOffset\", 0.0f);\n\n        defineParam(_hitTolerance, \"HitTolerance\", 0.001f);\n        defineParam(_maxDistance, \"MaxDistance\", 1000000.0f);\n\n        // Noise Parameters\n        defineParam(_size, \"Size\", 20.0f);\n        defineParam(_noiseType, \"NoiseType\", 0);\n        defineParam(_translation, \"Translation\", float3(0.0f, 0.0f, 0.0f));\n        defineParam(_octaves, \"Octaves\", 8.0f);\n        defineParam(_lacunarity, \"Lacunarity\", 3.0f);\n        defineParam(_gain, \"Gain\", 0.5f);\n        defineParam(_gamma, \"Gamma\", 0.5f);\n        defineParam(_lowFrequencyScale, \"LowFrequencyScale\", float4(0.0f, 0.0f, 0.0f, 0.0f));\n        defineParam(_highFrequencyScale, \"HighFrequencyScale\", float4(0.0f, 0.0f, 0.0f, 0.0f));\n        defineParam(_lowFrequencyTranslation, \"LowFrequencyTranslation\", float4(0.0f, 0.0f, 0.0f, 0.0f));\n        defineParam(_highFrequencyTranslation, \"HighFrequencyTranslation\", float4(0.0f, 0.0f, 0.0f, 0.0f));\n        defineParam(_invertDepth, \"InvertDepth\", false);\n    \}\n\n\n    /**\n     * Initialize the local variables.\n     */\n    void init()\n    \{\n        const float aspect = aspectRatio(_formatHeight, _formatWidth);\n        __inverseCameraProjectionMatrix = projectionMatrix(\n            _focalLength,\n            _horizontalAperture,\n            aspect,\n            _nearPlane,\n            _farPlane\n        ).invert();\n        // Dumb af but trust that changing the following will either break nuke 12 or 15\n        __inverseCameraWorldMatrix = _cameraWorldMatrix;\n        __inverseCameraWorldMatrix = __inverseCameraWorldMatrix.invert();\n\n        __aperture = fStopToAperture(_fStop, _focalLength);\n\n        const int simplexInit\[64]\[4] = \{\n            \{0, 1, 2, 3\}, \{0, 1, 3, 2\}, \{0, 0, 0, 0\}, \{0, 2, 3, 1\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{1, 2, 3, 0\},\n            \{0, 2, 1, 3\}, \{0, 0, 0, 0\}, \{0, 3, 1, 2\}, \{0, 3, 2, 1\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{1, 3, 2, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{1, 2, 0, 3\}, \{0, 0, 0, 0\}, \{1, 3, 0, 2\}, \{0, 0, 0, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{2, 3, 0, 1\}, \{2, 3, 1, 0\},\n            \{1, 0, 2, 3\}, \{1, 0, 3, 2\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{0, 0, 0, 0\}, \{2, 0, 3, 1\}, \{0, 0, 0, 0\}, \{2, 1, 3, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{2, 0, 1, 3\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{3, 0, 1, 2\}, \{3, 0, 2, 1\}, \{0, 0, 0, 0\}, \{3, 1, 2, 0\},\n            \{2, 1, 0, 3\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{3, 1, 0, 2\}, \{0, 0, 0, 0\}, \{3, 2, 0, 1\}, \{3, 2, 1, 0\}\n        \};\n\n        for (int i = 0; i < 64; i++)\n        \{\n            for (int j = 0; j < 4; j++)\n            \{\n                __simplex\[i]\[j] = simplexInit\[i]\[j];\n            \}\n        \}\n\n        const int permInit\[256] = \{\n            151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233,\n            7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23,\n            190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219,\n            203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174,\n            20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48,\n            27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133,\n            230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65,\n            25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18,\n            169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198,\n            173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147,\n            118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17,\n            182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44,\n            154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22,\n            39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112,\n            104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12,\n            191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49,\n            192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121,\n            50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29,\n            24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180\n        \};\n\n        for (int i = 0; i < 512; i++)\n        \{\n            __perm\[i] = permInit\[i % 256];\n        \}\n\n        const int grad4Init\[32]\[4]= \{\n            \{0, 1, 1, 1\},  \{0, 1, 1, -1\},  \{0, 1, -1, 1\},  \{0, 1, -1, -1\},\n            \{0, -1, 1, 1\}, \{0, -1, 1, -1\}, \{0, -1, -1, 1\}, \{0, -1, -1, -1\},\n            \{1, 0, 1, 1\},  \{1, 0, 1, -1\},  \{1, 0, -1, 1\},  \{1, 0, -1, -1\},\n            \{-1, 0, 1, 1\}, \{-1, 0, 1, -1\}, \{-1, 0, -1, 1\}, \{-1, 0, -1, -1\},\n            \{1, 1, 0, 1\},  \{1, 1, 0, -1\},  \{1, -1, 0, 1\},  \{1, -1, 0, -1\},\n            \{-1, 1, 0, 1\}, \{-1, 1, 0, -1\}, \{-1, -1, 0, 1\}, \{-1, -1, 0, -1\},\n            \{1, 1, 1, 0\},  \{1, 1, -1, 0\},  \{1, -1, 1, 0\},  \{1, -1, -1, 0\},\n            \{-1, 1, 1, 0\}, \{-1, 1, -1, 0\}, \{-1, -1, 1, 0\}, \{-1, -1, -1, 0\}\n        \};\n\n        for (int i = 0; i < 32; i++)\n        \{\n            for (int j = 0; j < 4; j++)\n            \{\n                __grad4\[i]\[j] = grad4Init\[i]\[j];\n            \}\n        \}\n\n        __offset0 = 0.5773f * float3(1, -1, -1);\n        __offset1 = 0.5773f * float3(-1, -1, 1);\n        __offset2 = 0.5773f * float3(-1, 1, -1);\n        __offset3 = 0.5773f * float3(1, 1, 1);\n\n        __translation = float4(_translation.x, _translation.y, _translation.z, 0.0f);\n\n        __depthSampleStep = (_depthRamp.w - _depthRamp.x) / (float) _samplesPerRay;\n\n        __planeNormal = normalize(_planeNormal);\n\n        __sphericalRampFalloffDistance = _sphericalRampRadii.y - _sphericalRampRadii.x;\n\n        __enableRaymarching = _enableSphericalRamp || _enableBoxRamp || _enablePlanarRamp;\n\n        rotationMatrix(_boxRampRotation, __inverseBoxRotMatrix);\n        __inverseBoxRotMatrix.invert();\n    \}\n\n    /**\n     * 4D Perlin simplex noise\n     *\n     * Copyright (c) 2007-2012 Eliot Eshelman\n     *\n     * This program is free software: you can redistribute it and/or modify\n     * it under the terms of the GNU General Public License as published by\n     * the Free Software Foundation, either version 3 of the License, or\n     * (at your option) any later version.\n     *\n     * This program is distributed in the hope that it will be useful,\n     * but WITHOUT ANY WARRANTY; without even the implied warranty of\n     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n     * GNU General Public License for more details.\n     *\n     * You should have received a copy of the GNU General Public License\n     * along with this program. If not, see <http://www.gnu.org/licenses/>.\n     *\n     * @arg seed: The seed for the noise.\n     *\n     * @returns: Noise value in the range \[-1, 1], value of 0 on all integer\n     *     coordinates.\n     */\n    inline float perlinSimplexNoise(const float4 &seed) \{\n        const float G4 = 0.138196601f;\n        const float4 i = floor(seed + elementSum(seed) * 0.309016994f);\n        const float4 x0 = seed - i + elementSum(i) * G4;\n\n        const int c = (\n            ((x0.x > x0.y) << 5)\n            | ((x0.x > x0.z) << 4)\n            | ((x0.y > x0.z) << 3)\n            | ((x0.x > x0.w) << 2)\n            | ((x0.y > x0.w) << 1)\n            | (x0.z > x0.w)\n        );\n        const int4 i1 = int4(\n            __simplex\[c]\[0] >= 3,\n            __simplex\[c]\[1] >= 3,\n            __simplex\[c]\[2] >= 3,\n            __simplex\[c]\[3] >= 3\n        );\n        const int4 i2 = int4(\n            __simplex\[c]\[0] >= 2,\n            __simplex\[c]\[1] >= 2,\n            __simplex\[c]\[2] >= 2,\n            __simplex\[c]\[3] >= 2\n        );\n        const int4 i3 = int4(\n            __simplex\[c]\[0] >= 1,\n            __simplex\[c]\[1] >= 1,\n            __simplex\[c]\[2] >= 1,\n            __simplex\[c]\[3] >= 1\n        );\n\n        const float4 x1 = x0 - float4(i1.x, i1.y, i1.z, i1.w) + G4;\n        const float4 x2 = x0 - float4(i2.x, i2.y, i2.z, i2.w) + 2.0f * G4;\n        const float4 x3 = x0 - float4(i3.x, i3.y, i3.z, i3.w) + 3.0f * G4;\n        const float4 x4 = x0 - 1.0f + 4.0f * G4;\n\n        const int ii = (int) i.x & 255;\n        const int jj = (int) i.y & 255;\n        const int kk = (int) i.z & 255;\n        const int ll = (int) i.w & 255;\n\n        const int gi0 = __perm\[\n            ii + __perm\[jj + __perm\[kk + __perm\[ll]]]\n        ] % 32;\n        const int gi1 = __perm\[\n            ii + i1.x + __perm\[jj + i1.y + __perm\[kk + i1.z + __perm\[ll + i1.w]]]\n        ] % 32;\n        const int gi2 = __perm\[\n            ii + i2.x + __perm\[jj + i2.y + __perm\[kk + i2.z + __perm\[ll + i2.w]]]\n        ] % 32;\n        const int gi3 = __perm\[\n            ii + i3.x + __perm\[jj + i3.y + __perm\[kk + i3.z + __perm\[ll + i3.w]]]\n        ] % 32;\n        const int gi4 = __perm\[\n            ii + 1 + __perm\[jj + 1 + __perm\[kk + 1 + __perm\[ll + 1]]]\n        ] % 32;\n\n        float n0, n1, n2, n3, n4;\n        float t0 = 0.6f - dot(x0, x0);\n        if (t0 < 0)\n        \{\n            n0 = 0.0f;\n        \}\n        else\n        \{\n            t0 *= t0;\n            n0 = t0 * t0 * dot(\n                float4(__grad4\[gi0]\[0], __grad4\[gi0]\[1], __grad4\[gi0]\[2], __grad4\[gi0]\[3]),\n                x0\n            );\n        \}\n\n        float t1 = 0.6f - dot(x1, x1);\n        if (t1 < 0)\n        \{\n            n1 = 0.0f;\n        \}\n        else\n        \{\n            t1 *= t1;\n            n1 = t1 * t1 * dot(\n                float4(__grad4\[gi1]\[0], __grad4\[gi1]\[1], __grad4\[gi1]\[2], __grad4\[gi1]\[3]),\n                x1\n            );\n        \}\n\n        float t2 = 0.6f - dot(x2, x2);\n        if (t2 < 0)\n        \{\n            n2 = 0.0f;\n        \}\n        else\n        \{\n            t2 *= t2;\n            n2 = t2 * t2 * dot(\n                float4(__grad4\[gi2]\[0], __grad4\[gi2]\[1], __grad4\[gi2]\[2], __grad4\[gi2]\[3]),\n                x2\n            );\n        \}\n\n        float t3 = 0.6f - dot(x3, x3);\n        if (t3 < 0)\n        \{\n            n3 = 0.0f;\n        \}\n        else\n        \{\n            t3 *= t3;\n            n3 = t3 * t3 * dot(\n                float4(__grad4\[gi3]\[0], __grad4\[gi3]\[1], __grad4\[gi3]\[2], __grad4\[gi3]\[3]),\n                x3\n            );\n        \}\n\n        float t4 = 0.6f - dot(x4, x4);\n        if (t4 < 0)\n        \{\n            n4 = 0.0f;\n        \}\n        else \{\n            t4 *= t4;\n            n4 = t4 * t4 * dot(\n                float4(__grad4\[gi4]\[0], __grad4\[gi4]\[1], __grad4\[gi4]\[2], __grad4\[gi4]\[3]),\n                x4\n            );\n        \}\n\n        return 27.0f * (n0 + n1 + n2 + n3 + n4);\n    \}\n\n\n    //\n    // Use the perlin simplex noise\n    //\n\n\n    /**\n     * fBM noise.\n     *\n     * @arg position: The position to seed the noise.\n     *\n     * @returns: The noise value in the range \[-1, 1].\n     */\n    float fractalBrownianMotionNoise(const float3 &position)\n    \{\n        const float4 position4d = float4(\n            position.x,\n            position.y,\n            position.z,\n            0.0f\n        );\n        float output = 0.0f;\n        float frequency = _lacunarity;\n        float amplitude = 1.0f;\n        float denom = 0.0f;\n        float4 translation;\n        float4 scale;\n\n        for (int octave=0; octave < _octaves; octave++)\n        \{\n            const float octaveFraction = octave / _octaves;\n            scale = (\n                (_highFrequencyScale * octaveFraction)\n                + (_lowFrequencyScale * (1.0f - octaveFraction))\n            );       \n            translation = __translation + (\n                (_highFrequencyTranslation * octaveFraction)\n                + (_lowFrequencyTranslation * (1.0f - octaveFraction))\n            );\n\n            output += amplitude * perlinSimplexNoise(\n                (position4d * scale + translation) * frequency / _size\n            );\n\n            frequency *= _lacunarity;\n            denom += amplitude;\n            amplitude *= _gain;\n        \}\n\n        return pow(fabs(output / denom), 1.0f / _gamma);\n    \}\n\n\n    /**\n     * Turbulence noise.\n     *\n     * @arg position: The position to seed the noise.\n     *\n     * @returns: The noise value in the range \[0, 1].\n     */\n    float turbulenceNoise(const float3 &position)\n    \{\n        const float4 position4d = float4(\n            position.x,\n            position.y,\n            position.z,\n            0.0f\n        );\n        float output = 0.0f;\n        float frequency = _lacunarity;\n        float amplitude = 1.0f;\n        float denom = 0.0f;\n        float4 translation;\n        float4 scale;\n\n        for (int octave=0; octave < _octaves; octave++)\n        \{\n            const float octaveFraction = octave / _octaves;\n            scale = (\n                (_highFrequencyScale * octaveFraction)\n                + (_lowFrequencyScale * (1.0f - octaveFraction))\n            );       \n            translation = __translation + (\n                (_highFrequencyTranslation * octaveFraction)\n                + (_lowFrequencyTranslation * (1.0f - octaveFraction))\n            );\n\n            output += fabs(\n                amplitude * perlinSimplexNoise(\n                    (position4d * scale + translation) * frequency / _size\n                )\n            );\n\n            frequency *= _lacunarity;\n            denom += amplitude;\n            amplitude *= _gain;\n        \}\n\n        return pow(output / denom, 1.0f / _gamma);\n    \}\n\n\n    /**\n     * Create a ray out of the camera. It will be either a standard ray,\n     * a latlong ray, or a ray that will result in depth of field.\n     *\n     * @arg seed: The seed to use in randomization.\n     * @arg pixelLocation: The x, and y locations of the pixel.\n     * @arg rayOrigin: The location to store the origin of the new ray.\n     * @arg rayDirection: The location to store the direction of the new\n     *     ray.\n     */\n    void getCameraRay(\n            const float2 &seed,\n            const float2 &pixelLocation,\n            float3 &rayOrigin,\n            float3 &rayDirection)\n    \{\n        const float2 uvCoordinates = pixelsToUV(\n            pixelLocation + random(seed),\n            float2(_formatWidth, _formatHeight)\n        );\n        if (_latLong)\n        \{\n            createLatLongCameraRay(\n                _cameraWorldMatrix,\n                uvCoordinates,\n                rayOrigin,\n                rayDirection\n            );\n        \}\n        else if (_depthOfFieldEnabled)\n        \{\n            createCameraRay(\n                _cameraWorldMatrix,\n                __inverseCameraProjectionMatrix,\n                uvCoordinates,\n                __aperture,\n                _focalDistance,\n                seed,\n                rayOrigin,\n                rayDirection\n            );\n        \}\n        else\n        \{\n            createCameraRay(\n                _cameraWorldMatrix,\n                __inverseCameraProjectionMatrix,\n                uvCoordinates,\n                rayOrigin,\n                rayDirection\n            );\n        \}\n    \}\n\n\n    /**\n     * Compute the minimum distance to an object in the scene.\n     *\n     * @arg rayOrigin: The origin position of the ray.\n     * @arg pixelFootprint: A value proportional to the amount of world\n     *     space that fills a pixel, like the distance from camera.\n     *\n     * @returns: The minimum distance to an object in the scene.\n     */\n    float getMinDistanceToObjectInScene(const float3 &point)\n    \{\n        if (_enableSphericalRamp)\n        \{\n            return distanceToSphere(\n                point - _sphericalRampPosition,\n                _sphericalRampRadii.y\n            );\n        \}\n        else if (_enablePlanarRamp)\n        \{\n            return max(\n                distanceToPlane(\n                    point - (_planePosition + __planeNormal * min(_planarRamp.x, _planarRamp.w)),\n                    -__planeNormal\n                ),\n                distanceToPlane(\n                    point - (_planePosition + __planeNormal * max(_planarRamp.x, _planarRamp.w)),\n                    __planeNormal\n                )\n            );\n        \}\n        else\n        \{\n            const float3 toBoxCenter = point - _boxRampPosition;\n            return distanceToRectangularPrism(\n                matmul(__inverseBoxRotMatrix, toBoxCenter),\n                _boxRampDimensions.x,\n                _boxRampDimensions.y,\n                _boxRampDimensions.z\n            ) - _boxRampFalloff;\n        \}\n    \}\n\n\n    /**\n     * Estimate the surface normal at the closest point on the closest\n     * object to a point\n     *\n     * @arg point: The point near which to get the surface normal\n     * @arg pixelFootprint: A value proportional to the amount of world\n     *     space that fills a pixel, like the distance from camera.\n     *\n     * @returns: The normalized surface normal.\n     */\n    float3 estimateSurfaceNormal(const float3 &point)\n    \{\n        return normalize(\n            __offset0 * getMinDistanceToObjectInScene(\n                point + __offset0 * _hitTolerance\n            )\n            + __offset1 * getMinDistanceToObjectInScene(\n                point + __offset1 * _hitTolerance\n            )\n            + __offset2 * getMinDistanceToObjectInScene(\n                point + __offset2 * _hitTolerance\n            )\n            + __offset3 * getMinDistanceToObjectInScene(\n                point + __offset3 * _hitTolerance\n            )\n        );\n    \}\n\n\n    void computeDepthAndSampleStep(\n        const float2 &seed,\n        const float3 &rayOrigin,\n        const float3 &rayDirection,\n        float &initialDepth,\n        float &sampleStep\n    ) \{\n        if (_enableDepthRamp)\n        \{\n            sampleStep = __depthSampleStep;\n            initialDepth = _depthRamp.x;\n        \}\n        else if (!__enableRaymarching)\n        \{\n            initialDepth = 0.0f;\n        \}\n\n        if (!__enableRaymarching)\n        \{\n            initialDepth += random(seed.x + seed.y) * sampleStep;\n            return;\n        \}\n\n        float pixelFootprint = _hitTolerance;\n        float distance = 0.0f;\n        float stepDistance = 0.0f;\n        bool hitSurface = false;\n        float3 position = rayOrigin;\n\n        while (distance < fabs(_maxDistance))\n        \{\n            const float signedDistance = getMinDistanceToObjectInScene(position);\n\n            if(distance == 0.0f && signedDistance <= 0.0f)\n            \{\n                hitSurface = true;\n                initialDepth = 0.0f;\n            \}\n\n            stepDistance = fabs(signedDistance);\n            distance += stepDistance;\n            position += stepDistance * rayDirection;\n\n            if (stepDistance < pixelFootprint)\n            \{\n                if (hitSurface)\n                \{\n                    sampleStep = min(\n                        sampleStep,\n                        (distance - initialDepth) / (float) _samplesPerRay\n                    );\n                    if (sampleStep == 0.0f)\n                    \{\n                        sampleStep = _maxDistance / (float) _samplesPerRay;\n                    \}\n                    initialDepth += random(seed.x + seed.y) * sampleStep;\n                    return;\n                \}\n                hitSurface = true;\n                initialDepth = min(initialDepth, distance);\n\n                const float3 normal = estimateSurfaceNormal(position + stepDistance * rayDirection);\n                position += 2.0f * pixelFootprint * (rayDirection - normal);\n                pixelFootprint = _hitTolerance;\n                continue;\n            \}\n\n            pixelFootprint += _hitTolerance * stepDistance;\n        \}\n\n        if (hitSurface)\n        \{\n            sampleStep = min(\n                sampleStep,\n                (distance - initialDepth) / (float) _samplesPerRay\n            );\n            initialDepth += random(seed.x + seed.y) * sampleStep;\n        \}\n        else\n        \{\n            initialDepth = -1.0f;\n        \}\n    \}\n\n\n    /**\n     * Compute a noise value.\n     *\n     * @arg pos: The x, and y location we are currently processing.\n     */\n    void process(int2 pos)\n    \{\n        float pixelDepth = depthAOV(0);\n        pixelDepth = (\n            pixelDepth > 0.0f ? (_invertDepth ? 1.0f / pixelDepth : pixelDepth) : _maxDistance\n        );\n        const float pixelDepthAlpha = 1.0f - depthAOV(3);\n\n        float2 pixelLocation = float2(pos.x, pos.y);\n        SampleType(seeds) seedPixel = seeds();\n        float2 seed0 = float2(seedPixel.x, seedPixel.y) + RAND_CONST_0 * pixelLocation;\n        float2 seed1 = float2(seedPixel.z, seedPixel.w) + RAND_CONST_1 * pixelLocation;\n\n        float4 resultPixel = float4(0.0f);\n\n        for (int path=1; path <= _raysPerPixel; path++)\n        \{\n            // Generate a ray from the camera\n            float3 rayOrigin;\n            float3 rayDirection;\n            getCameraRay(\n                seed0,\n                pixelLocation,\n                rayOrigin,\n                rayDirection\n            );\n\n            // Set the depth to the start of the depth ramp and add a random offset\n            // to eliminate layer lines\n            float depth = _maxDistance;\n            float sampleStep = _maxDistance / (float) _samplesPerRay;\n            computeDepthAndSampleStep(\n                seed0,\n                rayOrigin + rayDirection * _nearPlane,\n                rayDirection,\n                depth,\n                sampleStep\n            );\n\n            if (depth < 0.0f)\n            \{\n                continue;\n            \}\n\n            rayOrigin += depth * rayDirection;\n\n            float invertedLastSample = 1.0f;\n            for (int step=0; step < _samplesPerRay; step++)\n            \{\n                float ramp = 1.0f;\n                depth += sampleStep;\n                rayOrigin += rayDirection * sampleStep;\n                float adjustedDepth = depth;\n                if (_useCameraDepth)\n                \{\n                    adjustedDepth = fabs(matmul(\n                        __inverseCameraWorldMatrix,\n                        float4(rayOrigin.x, rayOrigin.y, rayOrigin.z, 1.0f)\n                    )\[2]);\n                \}\n                if (adjustedDepth > pixelDepth)\n                \{\n                    if (pixelDepthAlpha <= 0.0f)\n                    \{\n                        break;\n                    \}\n                    ramp *= pixelDepthAlpha;\n                \}\n\n                if (_enableSphericalRamp)\n                \{\n                    const float minDistanceToSphere = distanceToSphere(\n                        rayOrigin - _sphericalRampPosition,\n                        _sphericalRampRadii.x\n                    );\n                    if (minDistanceToSphere >= __sphericalRampFalloffDistance)\n                    \{\n                        continue;\n                    \}\n                    else if (minDistanceToSphere > 0.0f)\n                    \{\n                        ramp *= (\n                            (__sphericalRampFalloffDistance - minDistanceToSphere)\n                            / __sphericalRampFalloffDistance\n                        );\n                    \}\n                    if (_sphericalFalloffPower != 0.0f)\n                    \{\n                        ramp /= pow(\n                            max(\n                                1e-6,\n                                fabs(\n                                    _sphericalFalloffOffset\n                                    + minDistanceToSphere\n                                    + _sphericalRampRadii.x\n                                )\n                            ),\n                            _sphericalFalloffPower\n                        );\n                    \}\n                \}\n                else if (_enablePlanarRamp)\n                \{\n                    // Apply the scaling specified by the planar ramp\n                    const float minDistanceToPlane = distanceToPlane(\n                        rayOrigin - _planePosition,\n                        __planeNormal\n                    );\n                    if (\n                        minDistanceToPlane < _planarRamp.x\n                        || minDistanceToPlane >= _planarRamp.w\n                    ) \{\n                        continue;\n                    \}\n                    else if (minDistanceToPlane < _planarRamp.y)\n                    \{\n                        ramp *= (\n                            (minDistanceToPlane - _planarRamp.y)\n                            / (_planarRamp.y - _planarRamp.x)\n                            + 1.0f\n                        );\n                    \}\n                    else if (minDistanceToPlane > _planarRamp.z)\n                    \{\n                        ramp *= (\n                            (_planarRamp.w - minDistanceToPlane)\n                            / (_planarRamp.w - _planarRamp.z)\n                        );\n                    \}\n                    if (_planarFalloffPower != 0.0f)\n                    \{\n                        ramp /= pow(\n                            max(\n                                1e-6,\n                                fabs(_planarFalloffOffset + minDistanceToPlane)\n                            ),\n                            _planarFalloffPower\n                        );\n                    \}\n                \}\n                else if (_enableBoxRamp)\n                \{\n                    const float3 toBoxCenter = rayOrigin - _boxRampPosition;\n                    const float minDistanceToBox = distanceToRectangularPrism(\n                        matmul(__inverseBoxRotMatrix, toBoxCenter),\n                        _boxRampDimensions.x,\n                        _boxRampDimensions.y,\n                        _boxRampDimensions.z\n                    );\n                    if (minDistanceToBox >= _boxRampFalloff)\n                    \{\n                        continue;\n                    \}\n                    else if (minDistanceToBox > 0.0f)\n                    \{\n                        ramp *= (_boxRampFalloff - minDistanceToBox) / _boxRampFalloff;\n                    \}\n                    if (_boxFalloffPower != 0.0f)\n                    \{\n                        ramp /= pow(\n                            max(\n                                1e-6,\n                                _boxFalloffOffset + length(toBoxCenter)\n                            ),\n                            _boxFalloffPower\n                        );\n                    \}\n                \}\n\n                if (_enableDepthRamp)\n                \{\n                    // Apply the scaling specified by the depth ramp\n                    if (adjustedDepth < _depthRamp.y)\n                    \{\n                        ramp *= (\n                            (adjustedDepth - _depthRamp.y)\n                            / (_depthRamp.y - _depthRamp.x)\n                            + 1.0f\n                        );\n                    \}\n                    else if (adjustedDepth > _depthRamp.z)\n                    \{\n                        ramp *= (_depthRamp.w - adjustedDepth) / (_depthRamp.w - _depthRamp.z);\n                    \}\n                \}\n\n                // Compute the noise value at this position\n                float noiseValue = _density * ramp;\n                if (_noiseType == FBM_NOISE)\n                \{\n                    noiseValue *= fractalBrownianMotionNoise(rayOrigin);\n                \}\n                else\n                \{\n                    noiseValue *= turbulenceNoise(rayOrigin);\n                \}\n\n                // Over the noise values\n                resultPixel += noiseValue * invertedLastSample;\n                invertedLastSample *= saturate(1.0f - noiseValue);\n            \}\n\n            const float2 lastSeed = seed0;\n            seed0 = RAND_CONST_2 * float2(seed1.y, seed1.x) + RAND_CONST_3 * path;\n            seed1 = RAND_CONST_4 * lastSeed + RAND_CONST_5 * path;\n        \}\n\n        dst() = resultPixel / float(_raysPerPixel);\n    \}\n\};\n"
  rebuild ""
  FogKernel_FocalLength {{parent.DummyCam.focal}}
  FogKernel_HorizontalAperture {{parent.DummyCam.haperture}}
  FogKernel_NearPlane {{parent.DummyCam.near}}
  FogKernel_FarPlane {{parent.DummyCam.far}}
  FogKernel_CameraWorldMatrix {
      {{parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix}}
      {{parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix}}
      {{parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix}}
      {{parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix}}
    }
  FogKernel_FocalDistance {{parent.DummyCam.focal_point}}
  FogKernel_fstop {{parent.DummyCam.fstop}}
  FogKernel_EnableDepthOfField {{parent.depth_of_field}}
  FogKernel_OutputLatLong {{parent.latlong}}
  FogKernel_UseCameraDepth {{parent.camera_space}}
  FogKernel_ScreenWidth {{"proxy? input0.width*proxy_scale: input0.width"}}
  FogKernel_ScreenHeight {{"proxy? input0.height * proxy_scale : input0.height"}}
  FogKernel_RaysPerPixel {{parent.rays_per_pixel}}
  FogKernel_Density {{"parent.density * 50 / parent.samples_per_ray"}}
  FogKernel_SamplesPerRay {{parent.samples_per_ray}}
  FogKernel_EnableDepthRamp {{parent.enable_depth_ramp}}
  FogKernel_SampleDepthRamp {{parent.depth_ramp_dummy.range.A} {parent.depth_ramp_dummy.range.B} {parent.depth_ramp_dummy.range.C} {parent.depth_ramp_dummy.range.D}}
  FogKernel_SamplePlanarRamp {{-parent.in-parent.in_falloff} {-parent.in} {parent.out} {parent.out+parent.out_falloff}}
  FogKernel_EnablePlanarRamp {{parent.enable_planar_ramp}}
  FogKernel_PlanePosition {{parent.plane_point.x} {parent.plane_point.y} {parent.plane_point.z}}
  FogKernel_PlaneNormal {{parent.plane_normal.x} {parent.plane_normal.y} {parent.plane_normal.z}}
  FogKernel_PlanarFalloffPower {{parent.plane_falloff_power}}
  FogKernel_PlanarFalloffOffset {{parent.plane_falloff_offset}}
  FogKernel_EnableSphericalRamp {{parent.enable_spherical_ramp}}
  FogKernel_SphericalRampPosition {{parent.spherical_ramp_position.x} {parent.spherical_ramp_position.y} {parent.spherical_ramp_position.z}}
  FogKernel_SphericalRampRadii {{parent.spherical_ramp_start_radius} {parent.spherical_ramp_end_radius}}
  FogKernel_SphericalFalloffPower {{parent.sphere_falloff_power}}
  FogKernel_SphericalFalloffOffset {{parent.sphere_falloff_offset}}
  FogKernel_BoxRampPosition {{parent.box_ramp_position} {parent.box_ramp_position} {parent.box_ramp_position}}
  FogKernel_BoxRampRotation {{"parent.box_ramp_rotation * pi / 180"} {"parent.box_ramp_rotation * pi / 180"} {"parent.box_ramp_rotation * pi / 180"}}
  FogKernel_BoxRampDimensions {{parent.knob.width} {parent.knob.height} {parent.depth}}
  FogKernel_BoxRampFalloff {{parent.box_falloff_distance}}
  FogKernel_EnableBoxRamp {{parent.enable_box_ramp}}
  FogKernel_BoxFalloffPower {{parent.box_falloff_power}}
  FogKernel_BoxFalloffOffset {{parent.box_falloff_offset}}
  FogKernel_Size {{parent.size}}
  FogKernel_NoiseType {{parent.type}}
  FogKernel_Translation {{-parent.translation} {-parent.translation} {-parent.translation}}
  FogKernel_Octaves {{parent.octaves}}
  FogKernel_Lacunarity {{parent.lacunarity}}
  FogKernel_Gain {{parent.gain}}
  FogKernel_Gamma {{parent.gamma}}
  FogKernel_LowFrequencyScale {{parent.low_frequency_scale} {parent.low_frequency_scale} {parent.low_frequency_scale} {parent.low_frequency_scale}}
  FogKernel_HighFrequencyScale {{parent.high_frequency_scale} {parent.high_frequency_scale} {parent.high_frequency_scale} {parent.high_frequency_scale}}
  FogKernel_LowFrequencyTranslation {{"parent.low_frequency_translation + parent.low_frequency_evolve * frame / 100"} {"parent.low_frequency_translation + parent.low_frequency_evolve * frame / 100"} {"parent.low_frequency_translation + parent.low_frequency_evolve * frame / 100"} {"parent.low_frequency_translation + parent.low_frequency_evolve * frame / 100"}}
  FogKernel_HighFrequencyTranslation {{parent.high_frequency_translation.r} {parent.high_frequency_translation.g} {parent.high_frequency_translation.b} {parent.high_frequency_translation.a}}
  FogKernel_InvertDepth {{"parent.holdout_mode? 1: parent.invert_depth"}}
  FogKernel_HitTolerance {{parent.hit_tolerance}}
  FogKernel_MaxDistance {{parent.max_distance}}
  rebuild_finalise ""
  name BlinkScript1
  xpos 1756
  ypos 1148
 }
push $Na9b2390
 BlinkScript {
  kernelSourceFile /home/ob1/software/nuke/blink_fog_3d/src/blink/kernels/blink_fog_3d_no_depth.cpp
  kernelSource "// Copyright 2024 by Owen Bulka.\n// All rights reserved.\n// This file is released under the \"MIT License Agreement\".\n// Please see the LICENSE.md file that should have been included as part\n// of this package.\n\n\n//\n// Math operations\n//\n\n\n/**\n * The maximum component of a vector.\n *\n * @arg vector: The vector.\n *\n * @returns: The maximum component of the vector.\n */\ninline float maxComponent(const float3 &vector)\n\{\n    return max(vector.x, max(vector.y, vector.z));\n\}\n\n\n/**\n * The negative part of the vector. Ie. any positive values will be 0,\n * and the negative values will be positive.\n *\n * @arg vector: The vector.\n *\n * @returns: The negative part of the vector.\n */\ninline float negativePart(const float value)\n\{\n    return -min(value, 0.0f);\n\}\n\n\n/**\n * The positive part of the vector. Ie. any negative values will be 0.\n *\n * @arg vector: The vector.\n *\n * @returns: The positive part of the vector.\n */\ninline float3 positivePart(const float3 &vector)\n\{\n    return max(vector, float3(0));\n\}\n\n\n/**\n * Compute the fractional portion of the value. Ex. 3.5 returns 0.5\n *\n * @arg value: The value to get the fractional portion of.\n *\n * @returns: The fractional portion of the value.\n */\ninline float fract(const float value)\n\{\n    return value - floor(value);\n\}\n\n\n/**\n * Saturate a value ie. clamp between 0 and 1\n *\n * @arg value: The value to saturate\n *\n * @returns: The clamped value\n */\ninline float saturate(float value)\n\{\n    return clamp(value, 0.0f, 1.0f);\n\}\n\n\n/**\n * Multiply a 4d vector by a 4x4 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline void matmul(const float4x4 &m, const float4 &v, float4 &out)\n\{\n    for (int i=0; i < 4; i++)\n    \{\n        out\[i] = 0;\n\n        for (int j=0; j < 4; j++)\n        \{\n            out\[i] += m\[i]\[j] * v\[j];\n        \}\n    \}\n\}\n\n\n/**\n * Multiply a 4d vector by a 4x4 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline float4 matmul(const float4x4 &m, const float4 &v)\n\{\n    float4 out;\n    for (int i=0; i < 4; i++)\n    \{\n        out\[i] = 0;\n\n        for (int j=0; j < 4; j++)\n        \{\n            out\[i] += m\[i]\[j] * v\[j];\n        \}\n    \}\n\n    return out;\n\}\n\n\n/**\n * Multiply a 3d vector by a 3x3 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline float3 matmul(const float3x3 &m, const float3 &v)\n\{\n    return float3(\n        m\[0]\[0] * v.x + m\[0]\[1] * v.y + m\[0]\[2] * v.z,\n        m\[1]\[0] * v.x + m\[1]\[1] * v.y + m\[1]\[2] * v.z,\n        m\[2]\[0] * v.x + m\[2]\[1] * v.y + m\[2]\[2] * v.z\n    );\n\}\n\n\n/**\n * Convert the uv position in a latlong image to angles.\n *\n * @arg uvPosition: The UV position.\n *\n * @returns: The equivalent angles in radians.\n */\ninline float2 uvPositionToAngles(const float2 &uvPosition)\n\{\n    return float2(\n        (uvPosition.x + 1.0f) * PI,\n        (1.0f - uvPosition.y) * PI / 2.0f\n    );\n\}\n\n\n/**\n * Convert location of a pixel in an image into UV.\n *\n * @arg pixelLocation: The x, and y positions of the pixel.\n * @arg format: The image width, and height.\n *\n * @returns: The UV position.\n */\ninline float2 pixelsToUV(const float2 &pixelLocation, const float2 &format)\n\{\n    return float2(\n        2.0f * pixelLocation.x / format.x - 1.0f,\n        2.0f * pixelLocation.y / format.y - 1.0f\n    );\n\}\n\n\n/**\n * Convert a spherical unit vector (unit radius) to cartesion.\n *\n * @arg angles: The spherical angles in radians.\n *\n * @returns: The equivalent cartesion vector.\n */\ninline float3 sphericalUnitVectorToCartesion(const float2 &angles)\n\{\n    const float sinPhi = sin(angles.y);\n    return float3(\n        cos(angles.x) * sinPhi,\n        cos(angles.y),\n        sin(angles.x) * sinPhi\n    );\n\}\n\n\n/**\n * Get the position component of a world matrix.\n *\n * @arg worldMatrix: The world matrix.\n * @arg position: The location to store the position.\n */\ninline void positionFromWorldMatrix(const float4x4 &worldMatrix, float3 &position)\n\{\n    position = float3(\n        worldMatrix\[0]\[3],\n        worldMatrix\[1]\[3],\n        worldMatrix\[2]\[3]\n    );\n\}\n\n\n/**\n * Get the rotation component of a world matrix.\n *\n * @arg worldMatrix: The world matrix.\n * @arg rotation: The location to store the rotation.\n */\ninline void rotationFromWorldMatrix(const float4x4 &worldMatrix, float3x3 &rotationMatrix)\n\{\n    rotationMatrix\[0]\[0] = worldMatrix\[0]\[0];\n    rotationMatrix\[0]\[1] = worldMatrix\[0]\[1];\n    rotationMatrix\[0]\[2] = worldMatrix\[0]\[2];\n    rotationMatrix\[1]\[0] = worldMatrix\[1]\[0];\n    rotationMatrix\[1]\[1] = worldMatrix\[1]\[1];\n    rotationMatrix\[1]\[2] = worldMatrix\[1]\[2];\n    rotationMatrix\[2]\[0] = worldMatrix\[2]\[0];\n    rotationMatrix\[2]\[1] = worldMatrix\[2]\[1];\n    rotationMatrix\[2]\[2] = worldMatrix\[2]\[2];\n\}\n\n\n/**\n * Get a rotation matrix from radian angle values in ZYX order.\n *\n * @arg angles: The rotation angles in radians.\n * @arg out: The location to store the rotation matrix.\n */\ninline void rotationMatrix(const float3 &angles, float3x3 &out)\n\{\n    const float3 cosAngles = cos(angles);\n    const float3 sinAngles = sin(angles);\n\n    // Why tf can I not init a float3x3 normally??\n    out\[0]\[0] = cosAngles.y * cosAngles.z;\n    out\[0]\[1] = sinAngles.x * sinAngles.y * cosAngles.z - cosAngles.x * sinAngles.z;\n    out\[0]\[2] = cosAngles.x * sinAngles.y * cosAngles.z + sinAngles.x * sinAngles.z;\n    out\[1]\[0] = cosAngles.y * sinAngles.z;\n    out\[1]\[1] = sinAngles.x * sinAngles.y * sinAngles.z + cosAngles.x * cosAngles.z;\n    out\[1]\[2] = cosAngles.x * sinAngles.y * sinAngles.z - sinAngles.x * cosAngles.z;\n    out\[2]\[0] = -sinAngles.y;\n    out\[2]\[1] = sinAngles.x * cosAngles.y;\n    out\[2]\[2] = cosAngles.x * cosAngles.y;\n\}\n\n\n//\n// Randomization functions\n//\n\n\n// Some random constants on the interval \[1, 2]\n#define RAND_CONST_0 1.571411510193971f\n#define RAND_CONST_1 1.268632820084931f\n#define RAND_CONST_2 1.7880365647937733f\n#define RAND_CONST_3 1.3546987471558234f\n#define RAND_CONST_4 1.4365958250848703f\n#define RAND_CONST_5 1.7045380669435368f\n\n\n/**\n * Get a random value on the interval \[0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval \[0, 1].\n */\ninline float random(const float seed)\n\{\n    return fract(sin(73.1f * seed + 91.3458f) * 47453.5453f);\n\}\n\n\n/**\n * Get a random value on the interval \[0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval \[0, 1].\n */\ninline float2 random(const float2 &seed)\n\{\n    return float2(\n        fract(sin(13.157f * seed.x + 71.743f) * 7513.471f),\n        fract(sin(97.519f * seed.y + 113.591f) * 47453.5453f)\n    );\n\}\n\n\n/**\n * Create a random point that lies within the unit circle.\n *\n * @arg seed: The random seed.\n *\n * @returns: A random point, (radius, angle) in the unit circle.\n */\ninline float2 uniformPointInUnitCircle(const float2 &seed)\n\{\n    return float2(sqrt(random(seed.x)), 2.0f * PI * random(seed.y));\n\}\n\n\n/**\n * Sum the elements of a vector.\n *\n * @arg vector: The vector to sum the elements of.\n *\n * @returns: The sum of the vector elements.\n */\ninline float elementSum(const float4 &vector) \{\n    return vector.x + vector.y + vector.z + vector.w;\n\}\n\n\n#define FBM_NOISE 1\n\n\n//\n// Camera Utilities\n//\n\n\n/**\n * Compute the field of view from focal length.\n *\n * @arg focalLength: The focal length.\n *\n * @returns: The equivalent field of view.\n */\ninline float fieldOfView(const float focalLength)\n\{\n    return 2 * atan(1 / focalLength);\n\}\n\n\n/**\n * Compute the aspect ratio from image format.\n *\n * @arg height_: The height of the image.\n * @arg width_: The width of the image.\n *\n * @returns: The aspect ratio.\n */\ninline float aspectRatio(const float height_, const float width_)\n\{\n    return height_ / width_;\n\}\n\n\n/**\n *\n */\ninline float fStopToAperture(const float fStop, const float focalLength)\n\{\n    return focalLength / fStop / 1000.0f;\n\}\n\n\n/**\n * Create a projection matrix for a camera.\n *\n * @arg focalLength: The focal length of the camera.\n * @arg horizontalAperture: The horizontal aperture of the camera.\n * @arg aspect: The aspect ratio of the camera.\n * @arg nearPlane: The distance to the near plane of the camera.\n * @arg farPlane: The distance to the far plane of the camera.\n *\n * @returns: The camera's projection matrix.\n */\nfloat4x4 projectionMatrix(\n        const float focalLength,\n        const float horizontalAperture,\n        const float aspect,\n        const float nearPlane,\n        const float farPlane)\n\{\n    float farMinusNear = farPlane - nearPlane;\n    return float4x4(\n        2 * focalLength / horizontalAperture, 0, 0, 0,\n        0, 2 * focalLength / horizontalAperture / aspect, 0, 0,\n        0, 0, -(farPlane + nearPlane) / farMinusNear, -2 * (farPlane * nearPlane) / farMinusNear,\n        0, 0, -1, 0\n    );\n\}\n\n\n/**\n * Generate a ray out of a camera.\n *\n * @arg cameraWorldMatrix: The camera matrix.\n * @arg inverseProjectionMatrix: The inverse of the projection matrix.\n * @arg uvPosition: The UV position in the resulting image.\n * @arg rayOrigin: Will store the origin of the ray.\n * @arg rayDirection: Will store the direction of the ray.\n */\nvoid createCameraRay(\n        const float4x4 &cameraWorldMatrix,\n        const float4x4 &inverseProjectionMatrix,\n        const float2 &uvPosition,\n        float3 &rayOrigin,\n        float3 &rayDirection)\n\{\n    positionFromWorldMatrix(cameraWorldMatrix, rayOrigin);\n    float4 direction = matmul(\n        inverseProjectionMatrix,\n        float4(uvPosition.x, uvPosition.y, 0, 1)\n    );\n    matmul(\n        cameraWorldMatrix,\n        float4(direction.x, direction.y, direction.z, 0),\n        direction\n    );\n    rayDirection = normalize(float3(direction.x, direction.y, direction.z));\n\}\n\n\n/**\n * Generate a ray out of a camera.\n *\n * @arg cameraWorldMatrix: The camera matrix.\n * @arg inverseProjectionMatrix: The inverse of the projection matrix.\n * @arg uvPosition: The UV position in the resulting image.\n * @arg rayOrigin: Will store the origin of the ray.\n * @arg rayDirection: Will store the direction of the ray.\n */\nvoid createCameraRay(\n        const float4x4 &cameraWorldMatrix,\n        const float4x4 &inverseProjectionMatrix,\n        const float2 &uvPosition,\n        const float aperture,\n        const float focalDistance,\n        const float2 &seed,\n        float3 &rayOrigin,\n        float3 &rayDirection)\n\{\n    createCameraRay(\n        cameraWorldMatrix,\n        inverseProjectionMatrix,\n        uvPosition,\n        rayOrigin,\n        rayDirection\n    );\n\n    const float4 cameraForward4 = matmul(\n        cameraWorldMatrix,\n        float4(0, 0, -1, 0)\n    );\n    const float3 cameraForward = float3(\n        cameraForward4.x,\n        cameraForward4.y,\n        cameraForward4.z\n    );\n    const float4 cameraRight4 = matmul(\n        cameraWorldMatrix,\n        float4(1, 0, 0, 0)\n    );\n    const float3 cameraRight = float3(\n        cameraRight4.x,\n        cameraRight4.y,\n        cameraRight4.z\n    );\n    const float4 cameraUp4 = matmul(\n        cameraWorldMatrix,\n        float4(0, 1, 0, 0)\n    );\n    const float3 cameraUp = float3(\n        cameraUp4.x,\n        cameraUp4.y,\n        cameraUp4.z\n    );\n\n    const float3 focalPlanePoint = rayOrigin + cameraForward * focalDistance;\n    const float3 focalPlaneNormal = -cameraForward;\n\n    const float focalPointDistance = (\n        (dot(focalPlaneNormal, focalPlanePoint) - dot(rayOrigin, focalPlaneNormal))\n        / dot(rayDirection, focalPlaneNormal)\n    );\n    const float3 focalPoint = rayOrigin + focalPointDistance * rayDirection;\n\n    const float2 pointInUnitCircle = uniformPointInUnitCircle(seed);\n    const float2 offset = pointInUnitCircle.x * aperture * float2(\n        cos(pointInUnitCircle.y),\n        sin(pointInUnitCircle.y)\n    );\n\n    rayOrigin += cameraRight * offset.x + cameraUp * offset.y;\n    rayDirection = normalize(focalPoint - rayOrigin);\n\}\n\n\n/**\n * Generate a LatLong ray out of a camera.\n *\n * @arg cameraWorldMatrix: The camera matrix.\n * @arg uvPosition: The UV position in the resulting image.\n * @arg rayOrigin: Will store the origin of the ray.\n * @arg rayDirection: Will store the direction of the ray.\n */\nvoid createLatLongCameraRay(\n        const float4x4 &cameraWorldMatrix,\n        const float2 &uvPosition,\n        float3 &rayOrigin,\n        float3 &rayDirection)\n\{\n    positionFromWorldMatrix(cameraWorldMatrix, rayOrigin);\n    rayDirection = sphericalUnitVectorToCartesion(uvPositionToAngles(uvPosition));\n\n    float3x3 cameraRotation;\n    rotationFromWorldMatrix(cameraWorldMatrix, cameraRotation);\n    rayDirection = matmul(cameraRotation, rayDirection);\n\}\n\n\n// SDFs\n\n\n/**\n * Compute the signed distance along a vector\n *\n * @arg vector: A vector from a point to the nearest surface of an\n *     object.\n *\n * @returns: The signed length of the vector.\n */\ninline float sdfLength(const float3 &vector)\n\{\n    return (\n        length(positivePart(vector))\n        - negativePart(maxComponent(vector))\n    );\n\}\n\n\n/**\n * Compute the min distance from a point to a sphere.\n *\n * @arg position: The point to get the distance to, from the object.\n * @arg radius: The radius of the sphere.\n *\n * @returns: The minimum distance from the point to the shape.\n */\ninline float distanceToSphere(const float3 &position, const float radius)\n\{\n    return length(position) - radius;\n\}\n\n\n/**\n * Compute the min distance from a point to a plane.\n * Anything underneath the plane, as defined by the normal direction\n * pointing above, will be considered inside.\n *\n * @arg position: The point to get the distance to, from the object.\n * @arg normal: The normal direction of the plane.\n *\n * @returns: The minimum distance from the point to the shape.\n */\ninline float distanceToPlane(const float3 &position, const float3 &normal)\n\{\n    return dot(position, normal);\n\}\n\n\n/**\n * Compute the min distance from a point to a rectangular prism.\n * Centered at the origin.\n *\n * @arg position: The point to get the distance to, from the object.\n * @arg width: The width (x) of the prism.\n * @arg height: The height (y) of the prism.\n * @arg depth: The depth (z) of the prism.\n *\n * @returns: The minimum distance from the point to the shape.\n */\ninline float distanceToRectangularPrism(\n        const float3 &position,\n        const float width,\n        const float height,\n        const float depth)\n\{\n    // Only look at positive quadrant, using symmetry\n    const float3 prismToPosition = fabs(position) - float3(width, height, depth) / 2.0f;\n    // Clamp the components that are inside the prism to the surface\n    // before getting the distance\n    return sdfLength(prismToPosition);\n\}\n\n\nkernel FogKernelNoDepth : ImageComputationKernel<ePixelWise>\n\{\n    // the input which specifies the format, process is called once per pixel\n    // in this image, which also provides random seeds\n    Image<eRead, eAccessPoint, eEdgeNone> seeds;\n\n    // the output image\n    Image<eWrite> dst;\n\n\n    param:\n        // These parameters are made available to the user.\n\n        // Camera params\n        float _focalLength;\n        float _horizontalAperture;\n        float _nearPlane;\n        float _farPlane;\n        float4x4 _cameraWorldMatrix;\n        float _focalDistance;\n        float _fStop;\n        bool _depthOfFieldEnabled;\n        bool _latLong;\n        bool _useCameraDepth;\n\n        // Image params\n        float _formatWidth;\n        float _formatHeight;\n        int _raysPerPixel;\n        float _density;\n        int _samplesPerRay;\n\n        bool _enableDepthRamp;\n        float4 _depthRamp;\n\n        float4 _planarRamp;\n        bool _enablePlanarRamp;\n        float3 _planePosition;\n        float3 _planeNormal;\n        float _planarFalloffPower;\n        float _planarFalloffOffset;\n\n        bool _enableSphericalRamp;\n        float3 _sphericalRampPosition;\n        float2 _sphericalRampRadii;\n        float _sphericalFalloffPower;\n        float _sphericalFalloffOffset;\n\n        float3 _boxRampPosition;\n        float3 _boxRampRotation;\n        float3 _boxRampDimensions;\n        float _boxRampFalloff;\n        bool _enableBoxRamp;\n        float _boxFalloffPower;\n        float _boxFalloffOffset;\n\n        // Noise Parameters\n        float _size;\n        int _noiseType;\n        float3 _translation;\n        float _octaves;\n        float _lacunarity;\n        float _gain;\n        float _gamma;\n        float4 _lowFrequencyScale;\n        float4 _highFrequencyScale;\n        float4 _lowFrequencyTranslation;\n        float4 _highFrequencyTranslation;\n\n        // Raymarch parameters\n        float _hitTolerance;\n        float _maxDistance;\n\n    local:\n        // These local variables are not exposed to the user.\n        float4x4 __inverseCameraProjectionMatrix;\n        float4x4 __inverseCameraWorldMatrix;\n        float __aperture;\n\n        float4 __translation;\n\n        int __simplex\[64]\[4];\n        int __perm\[512];\n        int __grad4\[32]\[4];\n\n        float __depthSampleStep;\n\n        float __sphericalRampFalloffDistance;\n\n        float3 __planeNormal;\n\n        float3x3 __inverseBoxRotMatrix;\n\n        bool __enableRaymarching;\n\n        float3 __offset0;\n        float3 __offset1;\n        float3 __offset2;\n        float3 __offset3;\n\n\n    /**\n     * Give the parameters labels and default values.\n     */\n    void define()\n    \{\n        // Camera params\n        defineParam(_focalLength, \"FocalLength\", 50.0f);\n        defineParam(_horizontalAperture, \"HorizontalAperture\", 24.576f);\n        defineParam(_nearPlane, \"NearPlane\", 0.1f);\n        defineParam(_farPlane, \"FarPlane\", 10000.0f);\n        defineParam(\n            _cameraWorldMatrix,\n            \"CameraWorldMatrix\",\n            float4x4(\n                1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1\n            )\n        );\n        defineParam(_focalDistance, \"FocalDistance\", 4.0f);\n        defineParam(_fStop, \"fstop\", 16.0f);\n        defineParam(_depthOfFieldEnabled, \"EnableDepthOfField\", true);\n        defineParam(_latLong, \"OutputLatLong\", false);\n        defineParam(_useCameraDepth, \"UseCameraDepth\", false);\n\n        // Image params\n        defineParam(_formatHeight, \"ScreenHeight\", 2160.0f);\n        defineParam(_formatWidth, \"ScreenWidth\", 3840.0f);\n        defineParam(_density, \"Density\", 1.0f);\n        defineParam(_raysPerPixel, \"RaysPerPixel\", 1);\n        defineParam(_samplesPerRay, \"SamplesPerRay\", 5);\n\n        defineParam(_enableDepthRamp, \"EnableDepthRamp\", true);\n        defineParam(_depthRamp, \"SampleDepthRamp\", float4(5.0f, 10.0f, 15.0f, 20.0f));\n\n        defineParam(_planarRamp, \"SamplePlanarRamp\", float4(5.0f, 10.0f, 15.0f, 20.0f));\n        defineParam(_enablePlanarRamp, \"EnablePlanarRamp\", false);\n        defineParam(_planePosition, \"PlanePosition\", float3(0.0f, 0.0f, 0.0f));\n        defineParam(_planeNormal, \"PlaneNormal\", float3(0.0f, 1.0f, 0.0f));\n        defineParam(_planarFalloffPower, \"PlanarFalloffPower\", 0.0f);\n        defineParam(_planarFalloffOffset, \"PlanarFalloffOffset\", 0.0f);\n\n        defineParam(_enableSphericalRamp, \"EnableSphericalRamp\", false);\n        defineParam(_sphericalRampPosition, \"SphericalRampPosition\", float3(0.0f, 0.0f, 0.0f));\n        defineParam(_sphericalRampRadii, \"SphericalRampRadii\", float2(1.0f, 2.0f));\n        defineParam(_sphericalFalloffPower, \"SphericalFalloffPower\", 0.0f);\n        defineParam(_sphericalFalloffOffset, \"SphericalFalloffOffset\", 0.0f);\n\n        defineParam(_boxRampPosition, \"BoxRampPosition\", float3(0.0f, 0.0f, 0.0f));\n        defineParam(_boxRampRotation, \"BoxRampRotation\", float3(0.0f, 0.0f, 0.0f));\n        defineParam(_boxRampDimensions, \"BoxRampDimensions\", float3(1.0f, 1.0f, 1.0f));\n        defineParam(_boxRampFalloff, \"BoxRampFalloff\", 1.0f);\n        defineParam(_enableBoxRamp, \"EnableBoxRamp\", false);\n        defineParam(_boxFalloffPower, \"BoxFalloffPower\", 0.0f);\n        defineParam(_boxFalloffOffset, \"BoxFalloffOffset\", 0.0f);\n\n        defineParam(_hitTolerance, \"HitTolerance\", 0.001f);\n        defineParam(_maxDistance, \"MaxDistance\", 1000000.0f);\n\n        // Noise Parameters\n        defineParam(_size, \"Size\", 20.0f);\n        defineParam(_noiseType, \"NoiseType\", 0);\n        defineParam(_translation, \"Translation\", float3(0.0f, 0.0f, 0.0f));\n        defineParam(_octaves, \"Octaves\", 8.0f);\n        defineParam(_lacunarity, \"Lacunarity\", 3.0f);\n        defineParam(_gain, \"Gain\", 0.5f);\n        defineParam(_gamma, \"Gamma\", 0.5f);\n        defineParam(_lowFrequencyScale, \"LowFrequencyScale\", float4(0.0f, 0.0f, 0.0f, 0.0f));\n        defineParam(_highFrequencyScale, \"HighFrequencyScale\", float4(0.0f, 0.0f, 0.0f, 0.0f));\n        defineParam(_lowFrequencyTranslation, \"LowFrequencyTranslation\", float4(0.0f, 0.0f, 0.0f, 0.0f));\n        defineParam(_highFrequencyTranslation, \"HighFrequencyTranslation\", float4(0.0f, 0.0f, 0.0f, 0.0f));\n    \}\n\n\n    /**\n     * Initialize the local variables.\n     */\n    void init()\n    \{\n        const float aspect = aspectRatio(_formatHeight, _formatWidth);\n        __inverseCameraProjectionMatrix = projectionMatrix(\n            _focalLength,\n            _horizontalAperture,\n            aspect,\n            _nearPlane,\n            _farPlane\n        ).invert();\n        // Dumb af but trust that changing the following will either break nuke 12 or 15\n        __inverseCameraWorldMatrix = _cameraWorldMatrix;\n        __inverseCameraWorldMatrix = __inverseCameraWorldMatrix.invert();\n\n        __aperture = fStopToAperture(_fStop, _focalLength);\n\n        const int simplexInit\[64]\[4] = \{\n            \{0, 1, 2, 3\}, \{0, 1, 3, 2\}, \{0, 0, 0, 0\}, \{0, 2, 3, 1\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{1, 2, 3, 0\},\n            \{0, 2, 1, 3\}, \{0, 0, 0, 0\}, \{0, 3, 1, 2\}, \{0, 3, 2, 1\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{1, 3, 2, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{1, 2, 0, 3\}, \{0, 0, 0, 0\}, \{1, 3, 0, 2\}, \{0, 0, 0, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{2, 3, 0, 1\}, \{2, 3, 1, 0\},\n            \{1, 0, 2, 3\}, \{1, 0, 3, 2\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{0, 0, 0, 0\}, \{2, 0, 3, 1\}, \{0, 0, 0, 0\}, \{2, 1, 3, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{2, 0, 1, 3\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{3, 0, 1, 2\}, \{3, 0, 2, 1\}, \{0, 0, 0, 0\}, \{3, 1, 2, 0\},\n            \{2, 1, 0, 3\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{3, 1, 0, 2\}, \{0, 0, 0, 0\}, \{3, 2, 0, 1\}, \{3, 2, 1, 0\}\n        \};\n\n        for (int i = 0; i < 64; i++)\n        \{\n            for (int j = 0; j < 4; j++)\n            \{\n                __simplex\[i]\[j] = simplexInit\[i]\[j];\n            \}\n        \}\n\n        const int permInit\[256] = \{\n            151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233,\n            7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23,\n            190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219,\n            203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174,\n            20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48,\n            27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133,\n            230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65,\n            25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18,\n            169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198,\n            173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147,\n            118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17,\n            182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44,\n            154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22,\n            39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112,\n            104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12,\n            191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49,\n            192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121,\n            50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29,\n            24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180\n        \};\n\n        for (int i = 0; i < 512; i++)\n        \{\n            __perm\[i] = permInit\[i % 256];\n        \}\n\n        const int grad4Init\[32]\[4]= \{\n            \{0, 1, 1, 1\},  \{0, 1, 1, -1\},  \{0, 1, -1, 1\},  \{0, 1, -1, -1\},\n            \{0, -1, 1, 1\}, \{0, -1, 1, -1\}, \{0, -1, -1, 1\}, \{0, -1, -1, -1\},\n            \{1, 0, 1, 1\},  \{1, 0, 1, -1\},  \{1, 0, -1, 1\},  \{1, 0, -1, -1\},\n            \{-1, 0, 1, 1\}, \{-1, 0, 1, -1\}, \{-1, 0, -1, 1\}, \{-1, 0, -1, -1\},\n            \{1, 1, 0, 1\},  \{1, 1, 0, -1\},  \{1, -1, 0, 1\},  \{1, -1, 0, -1\},\n            \{-1, 1, 0, 1\}, \{-1, 1, 0, -1\}, \{-1, -1, 0, 1\}, \{-1, -1, 0, -1\},\n            \{1, 1, 1, 0\},  \{1, 1, -1, 0\},  \{1, -1, 1, 0\},  \{1, -1, -1, 0\},\n            \{-1, 1, 1, 0\}, \{-1, 1, -1, 0\}, \{-1, -1, 1, 0\}, \{-1, -1, -1, 0\}\n        \};\n\n        for (int i = 0; i < 32; i++)\n        \{\n            for (int j = 0; j < 4; j++)\n            \{\n                __grad4\[i]\[j] = grad4Init\[i]\[j];\n            \}\n        \}\n\n        __offset0 = 0.5773f * float3(1, -1, -1);\n        __offset1 = 0.5773f * float3(-1, -1, 1);\n        __offset2 = 0.5773f * float3(-1, 1, -1);\n        __offset3 = 0.5773f * float3(1, 1, 1);\n\n        __translation = float4(_translation.x, _translation.y, _translation.z, 0.0f);\n\n        __depthSampleStep = (_depthRamp.w - _depthRamp.x) / (float) _samplesPerRay;\n\n        __planeNormal = normalize(_planeNormal);\n\n        __sphericalRampFalloffDistance = _sphericalRampRadii.y - _sphericalRampRadii.x;\n\n        __enableRaymarching = _enableSphericalRamp || _enableBoxRamp || _enablePlanarRamp;\n\n        rotationMatrix(_boxRampRotation, __inverseBoxRotMatrix);\n        __inverseBoxRotMatrix.invert();\n    \}\n\n    /**\n     * 4D Perlin simplex noise\n     *\n     * Copyright (c) 2007-2012 Eliot Eshelman\n     *\n     * This program is free software: you can redistribute it and/or modify\n     * it under the terms of the GNU General Public License as published by\n     * the Free Software Foundation, either version 3 of the License, or\n     * (at your option) any later version.\n     *\n     * This program is distributed in the hope that it will be useful,\n     * but WITHOUT ANY WARRANTY; without even the implied warranty of\n     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n     * GNU General Public License for more details.\n     *\n     * You should have received a copy of the GNU General Public License\n     * along with this program. If not, see <http://www.gnu.org/licenses/>.\n     *\n     * @arg seed: The seed for the noise.\n     *\n     * @returns: Noise value in the range \[-1, 1], value of 0 on all integer\n     *     coordinates.\n     */\n    inline float perlinSimplexNoise(const float4 &seed) \{\n        const float G4 = 0.138196601f;\n        const float4 i = floor(seed + elementSum(seed) * 0.309016994f);\n        const float4 x0 = seed - i + elementSum(i) * G4;\n\n        const int c = (\n            ((x0.x > x0.y) << 5)\n            | ((x0.x > x0.z) << 4)\n            | ((x0.y > x0.z) << 3)\n            | ((x0.x > x0.w) << 2)\n            | ((x0.y > x0.w) << 1)\n            | (x0.z > x0.w)\n        );\n        const int4 i1 = int4(\n            __simplex\[c]\[0] >= 3,\n            __simplex\[c]\[1] >= 3,\n            __simplex\[c]\[2] >= 3,\n            __simplex\[c]\[3] >= 3\n        );\n        const int4 i2 = int4(\n            __simplex\[c]\[0] >= 2,\n            __simplex\[c]\[1] >= 2,\n            __simplex\[c]\[2] >= 2,\n            __simplex\[c]\[3] >= 2\n        );\n        const int4 i3 = int4(\n            __simplex\[c]\[0] >= 1,\n            __simplex\[c]\[1] >= 1,\n            __simplex\[c]\[2] >= 1,\n            __simplex\[c]\[3] >= 1\n        );\n\n        const float4 x1 = x0 - float4(i1.x, i1.y, i1.z, i1.w) + G4;\n        const float4 x2 = x0 - float4(i2.x, i2.y, i2.z, i2.w) + 2.0f * G4;\n        const float4 x3 = x0 - float4(i3.x, i3.y, i3.z, i3.w) + 3.0f * G4;\n        const float4 x4 = x0 - 1.0f + 4.0f * G4;\n\n        const int ii = (int) i.x & 255;\n        const int jj = (int) i.y & 255;\n        const int kk = (int) i.z & 255;\n        const int ll = (int) i.w & 255;\n\n        const int gi0 = __perm\[\n            ii + __perm\[jj + __perm\[kk + __perm\[ll]]]\n        ] % 32;\n        const int gi1 = __perm\[\n            ii + i1.x + __perm\[jj + i1.y + __perm\[kk + i1.z + __perm\[ll + i1.w]]]\n        ] % 32;\n        const int gi2 = __perm\[\n            ii + i2.x + __perm\[jj + i2.y + __perm\[kk + i2.z + __perm\[ll + i2.w]]]\n        ] % 32;\n        const int gi3 = __perm\[\n            ii + i3.x + __perm\[jj + i3.y + __perm\[kk + i3.z + __perm\[ll + i3.w]]]\n        ] % 32;\n        const int gi4 = __perm\[\n            ii + 1 + __perm\[jj + 1 + __perm\[kk + 1 + __perm\[ll + 1]]]\n        ] % 32;\n\n        float n0, n1, n2, n3, n4;\n        float t0 = 0.6f - dot(x0, x0);\n        if (t0 < 0)\n        \{\n            n0 = 0.0f;\n        \}\n        else\n        \{\n            t0 *= t0;\n            n0 = t0 * t0 * dot(\n                float4(__grad4\[gi0]\[0], __grad4\[gi0]\[1], __grad4\[gi0]\[2], __grad4\[gi0]\[3]),\n                x0\n            );\n        \}\n\n        float t1 = 0.6f - dot(x1, x1);\n        if (t1 < 0)\n        \{\n            n1 = 0.0f;\n        \}\n        else\n        \{\n            t1 *= t1;\n            n1 = t1 * t1 * dot(\n                float4(__grad4\[gi1]\[0], __grad4\[gi1]\[1], __grad4\[gi1]\[2], __grad4\[gi1]\[3]),\n                x1\n            );\n        \}\n\n        float t2 = 0.6f - dot(x2, x2);\n        if (t2 < 0)\n        \{\n            n2 = 0.0f;\n        \}\n        else\n        \{\n            t2 *= t2;\n            n2 = t2 * t2 * dot(\n                float4(__grad4\[gi2]\[0], __grad4\[gi2]\[1], __grad4\[gi2]\[2], __grad4\[gi2]\[3]),\n                x2\n            );\n        \}\n\n        float t3 = 0.6f - dot(x3, x3);\n        if (t3 < 0)\n        \{\n            n3 = 0.0f;\n        \}\n        else\n        \{\n            t3 *= t3;\n            n3 = t3 * t3 * dot(\n                float4(__grad4\[gi3]\[0], __grad4\[gi3]\[1], __grad4\[gi3]\[2], __grad4\[gi3]\[3]),\n                x3\n            );\n        \}\n\n        float t4 = 0.6f - dot(x4, x4);\n        if (t4 < 0)\n        \{\n            n4 = 0.0f;\n        \}\n        else \{\n            t4 *= t4;\n            n4 = t4 * t4 * dot(\n                float4(__grad4\[gi4]\[0], __grad4\[gi4]\[1], __grad4\[gi4]\[2], __grad4\[gi4]\[3]),\n                x4\n            );\n        \}\n\n        return 27.0f * (n0 + n1 + n2 + n3 + n4);\n    \}\n\n\n    //\n    // Use the perlin simplex noise\n    //\n\n\n    /**\n     * fBM noise.\n     *\n     * @arg position: The position to seed the noise.\n     *\n     * @returns: The noise value in the range \[-1, 1].\n     */\n    float fractalBrownianMotionNoise(const float3 &position)\n    \{\n        const float4 position4d = float4(\n            position.x,\n            position.y,\n            position.z,\n            0.0f\n        );\n        float output = 0.0f;\n        float frequency = _lacunarity;\n        float amplitude = 1.0f;\n        float denom = 0.0f;\n        float4 translation;\n        float4 scale;\n\n        for (int octave=0; octave < _octaves; octave++)\n        \{\n            const float octaveFraction = octave / _octaves;\n            scale = (\n                (_highFrequencyScale * octaveFraction)\n                + (_lowFrequencyScale * (1.0f - octaveFraction))\n            );       \n            translation = __translation + (\n                (_highFrequencyTranslation * octaveFraction)\n                + (_lowFrequencyTranslation * (1.0f - octaveFraction))\n            );\n\n            output += amplitude * perlinSimplexNoise(\n                (position4d * scale + translation) * frequency / _size\n            );\n\n            frequency *= _lacunarity;\n            denom += amplitude;\n            amplitude *= _gain;\n        \}\n\n        return pow(fabs(output / denom), 1.0f / _gamma);\n    \}\n\n\n    /**\n     * Turbulence noise.\n     *\n     * @arg position: The position to seed the noise.\n     *\n     * @returns: The noise value in the range \[0, 1].\n     */\n    float turbulenceNoise(const float3 &position)\n    \{\n        const float4 position4d = float4(\n            position.x,\n            position.y,\n            position.z,\n            0.0f\n        );\n        float output = 0.0f;\n        float frequency = _lacunarity;\n        float amplitude = 1.0f;\n        float denom = 0.0f;\n        float4 translation;\n        float4 scale;\n\n        for (int octave=0; octave < _octaves; octave++)\n        \{\n            const float octaveFraction = octave / _octaves;\n            scale = (\n                (_highFrequencyScale * octaveFraction)\n                + (_lowFrequencyScale * (1.0f - octaveFraction))\n            );       \n            translation = __translation + (\n                (_highFrequencyTranslation * octaveFraction)\n                + (_lowFrequencyTranslation * (1.0f - octaveFraction))\n            );\n\n            output += fabs(\n                amplitude * perlinSimplexNoise(\n                    (position4d * scale + translation) * frequency / _size\n                )\n            );\n\n            frequency *= _lacunarity;\n            denom += amplitude;\n            amplitude *= _gain;\n        \}\n\n        return pow(output / denom, 1.0f / _gamma);\n    \}\n\n\n    /**\n     * Create a ray out of the camera. It will be either a standard ray,\n     * a latlong ray, or a ray that will result in depth of field.\n     *\n     * @arg seed: The seed to use in randomization.\n     * @arg pixelLocation: The x, and y locations of the pixel.\n     * @arg rayOrigin: The location to store the origin of the new ray.\n     * @arg rayDirection: The location to store the direction of the new\n     *     ray.\n     */\n    void getCameraRay(\n            const float2 &seed,\n            const float2 &pixelLocation,\n            float3 &rayOrigin,\n            float3 &rayDirection)\n    \{\n        const float2 uvCoordinates = pixelsToUV(\n            pixelLocation + random(seed),\n            float2(_formatWidth, _formatHeight)\n        );\n        if (_latLong)\n        \{\n            createLatLongCameraRay(\n                _cameraWorldMatrix,\n                uvCoordinates,\n                rayOrigin,\n                rayDirection\n            );\n        \}\n        else if (_depthOfFieldEnabled)\n        \{\n            createCameraRay(\n                _cameraWorldMatrix,\n                __inverseCameraProjectionMatrix,\n                uvCoordinates,\n                __aperture,\n                _focalDistance,\n                seed,\n                rayOrigin,\n                rayDirection\n            );\n        \}\n        else\n        \{\n            createCameraRay(\n                _cameraWorldMatrix,\n                __inverseCameraProjectionMatrix,\n                uvCoordinates,\n                rayOrigin,\n                rayDirection\n            );\n        \}\n    \}\n\n\n    /**\n     * Compute the minimum distance to an object in the scene.\n     *\n     * @arg rayOrigin: The origin position of the ray.\n     * @arg pixelFootprint: A value proportional to the amount of world\n     *     space that fills a pixel, like the distance from camera.\n     *\n     * @returns: The minimum distance to an object in the scene.\n     */\n    float getMinDistanceToObjectInScene(const float3 &point)\n    \{\n        if (_enableSphericalRamp)\n        \{\n            return distanceToSphere(\n                point - _sphericalRampPosition,\n                _sphericalRampRadii.y\n            );\n        \}\n        else if (_enablePlanarRamp)\n        \{\n            return max(\n                distanceToPlane(\n                    point - (_planePosition + __planeNormal * min(_planarRamp.x, _planarRamp.w)),\n                    -__planeNormal\n                ),\n                distanceToPlane(\n                    point - (_planePosition + __planeNormal * max(_planarRamp.x, _planarRamp.w)),\n                    __planeNormal\n                )\n            );\n        \}\n        else\n        \{\n            const float3 toBoxCenter = point - _boxRampPosition;\n            return distanceToRectangularPrism(\n                matmul(__inverseBoxRotMatrix, toBoxCenter),\n                _boxRampDimensions.x,\n                _boxRampDimensions.y,\n                _boxRampDimensions.z\n            ) - _boxRampFalloff;\n        \}\n    \}\n\n\n    /**\n     * Estimate the surface normal at the closest point on the closest\n     * object to a point\n     *\n     * @arg point: The point near which to get the surface normal\n     * @arg pixelFootprint: A value proportional to the amount of world\n     *     space that fills a pixel, like the distance from camera.\n     *\n     * @returns: The normalized surface normal.\n     */\n    float3 estimateSurfaceNormal(const float3 &point)\n    \{\n        return normalize(\n            __offset0 * getMinDistanceToObjectInScene(\n                point + __offset0 * _hitTolerance\n            )\n            + __offset1 * getMinDistanceToObjectInScene(\n                point + __offset1 * _hitTolerance\n            )\n            + __offset2 * getMinDistanceToObjectInScene(\n                point + __offset2 * _hitTolerance\n            )\n            + __offset3 * getMinDistanceToObjectInScene(\n                point + __offset3 * _hitTolerance\n            )\n        );\n    \}\n\n\n    void computeDepthAndSampleStep(\n        const float2 &seed,\n        const float3 &rayOrigin,\n        const float3 &rayDirection,\n        float &initialDepth,\n        float &sampleStep\n    ) \{\n        if (_enableDepthRamp)\n        \{\n            sampleStep = __depthSampleStep;\n            initialDepth = _depthRamp.x;\n        \}\n        else if (!__enableRaymarching)\n        \{\n            initialDepth = 0.0f;\n        \}\n\n        if (!__enableRaymarching)\n        \{\n            initialDepth += random(seed.x + seed.y) * sampleStep;\n            return;\n        \}\n\n        float pixelFootprint = _hitTolerance;\n        float distance = 0.0f;\n        float stepDistance = 0.0f;\n        bool hitSurface = false;\n        float3 position = rayOrigin;\n\n        while (distance < fabs(_maxDistance))\n        \{\n            const float signedDistance = getMinDistanceToObjectInScene(position);\n\n            if(distance == 0.0f && signedDistance <= 0.0f)\n            \{\n                hitSurface = true;\n                initialDepth = 0.0f;\n            \}\n\n            stepDistance = fabs(signedDistance);\n            distance += stepDistance;\n            position += stepDistance * rayDirection;\n\n            if (stepDistance < pixelFootprint)\n            \{\n                if (hitSurface)\n                \{\n                    sampleStep = min(\n                        sampleStep,\n                        (distance - initialDepth) / (float) _samplesPerRay\n                    );\n                    if (sampleStep == 0.0f)\n                    \{\n                        sampleStep = _maxDistance / (float) _samplesPerRay;\n                    \}\n                    initialDepth += random(seed.x + seed.y) * sampleStep;\n                    return;\n                \}\n                hitSurface = true;\n                initialDepth = min(initialDepth, distance);\n\n                const float3 normal = estimateSurfaceNormal(position + stepDistance * rayDirection);\n                position += 2.0f * pixelFootprint * (rayDirection - normal);\n                pixelFootprint = _hitTolerance;\n                continue;\n            \}\n\n            pixelFootprint += _hitTolerance * stepDistance;\n        \}\n\n        if (hitSurface)\n        \{\n            sampleStep = min(\n                sampleStep,\n                (distance - initialDepth) / (float) _samplesPerRay\n            );\n            initialDepth += random(seed.x + seed.y) * sampleStep;\n        \}\n        else\n        \{\n            initialDepth = -1.0f;\n        \}\n    \}\n\n\n    /**\n     * Compute a noise value.\n     *\n     * @arg pos: The x, and y location we are currently processing.\n     */\n    void process(int2 pos)\n    \{\n        float2 pixelLocation = float2(pos.x, pos.y);\n        SampleType(seeds) seedPixel = seeds();\n        float2 seed0 = float2(seedPixel.x, seedPixel.y) + RAND_CONST_0 * pixelLocation;\n        float2 seed1 = float2(seedPixel.z, seedPixel.w) + RAND_CONST_1 * pixelLocation;\n\n        float4 resultPixel = float4(0.0f);\n\n        for (int path=1; path <= _raysPerPixel; path++)\n        \{\n            // Generate a ray from the camera\n            float3 rayOrigin;\n            float3 rayDirection;\n            getCameraRay(\n                seed0,\n                pixelLocation,\n                rayOrigin,\n                rayDirection\n            );\n\n            // Set the depth to the start of the depth ramp and add a random offset\n            // to eliminate layer lines\n            float depth = _maxDistance;\n            float sampleStep = _maxDistance / (float) _samplesPerRay;\n            computeDepthAndSampleStep(\n                seed0,\n                rayOrigin + rayDirection * _nearPlane,\n                rayDirection,\n                depth,\n                sampleStep\n            );\n\n            if (depth < 0.0f)\n            \{\n                continue;\n            \}\n\n            rayOrigin += depth * rayDirection;\n\n            float invertedLastSample = 1.0f;\n            for (int step=0; step < _samplesPerRay; step++)\n            \{\n                float ramp = 1.0f;\n                depth += sampleStep;\n                rayOrigin += rayDirection * sampleStep;\n                float adjustedDepth = depth;\n                if (_useCameraDepth)\n                \{\n                    adjustedDepth = fabs(matmul(\n                        __inverseCameraWorldMatrix,\n                        float4(rayOrigin.x, rayOrigin.y, rayOrigin.z, 1.0f)\n                    )\[2]);\n                \}\n\n                if (_enableSphericalRamp)\n                \{\n                    const float minDistanceToSphere = distanceToSphere(\n                        rayOrigin - _sphericalRampPosition,\n                        _sphericalRampRadii.x\n                    );\n                    if (minDistanceToSphere >= __sphericalRampFalloffDistance)\n                    \{\n                        continue;\n                    \}\n                    else if (minDistanceToSphere > 0.0f)\n                    \{\n                        ramp *= (\n                            (__sphericalRampFalloffDistance - minDistanceToSphere)\n                            / __sphericalRampFalloffDistance\n                        );\n                    \}\n                    if (_sphericalFalloffPower != 0.0f)\n                    \{\n                        ramp /= pow(\n                            max(\n                                1e-6,\n                                fabs(\n                                    _sphericalFalloffOffset\n                                    + minDistanceToSphere\n                                    + _sphericalRampRadii.x\n                                )\n                            ),\n                            _sphericalFalloffPower\n                        );\n                    \}\n                \}\n                else if (_enablePlanarRamp)\n                \{\n                    // Apply the scaling specified by the planar ramp\n                    const float minDistanceToPlane = distanceToPlane(\n                        rayOrigin - _planePosition,\n                        __planeNormal\n                    );\n                    if (\n                        minDistanceToPlane < _planarRamp.x\n                        || minDistanceToPlane >= _planarRamp.w\n                    ) \{\n                        continue;\n                    \}\n                    else if (minDistanceToPlane < _planarRamp.y)\n                    \{\n                        ramp *= (\n                            (minDistanceToPlane - _planarRamp.y)\n                            / (_planarRamp.y - _planarRamp.x)\n                            + 1.0f\n                        );\n                    \}\n                    else if (minDistanceToPlane > _planarRamp.z)\n                    \{\n                        ramp *= (\n                            (_planarRamp.w - minDistanceToPlane)\n                            / (_planarRamp.w - _planarRamp.z)\n                        );\n                    \}\n                    if (_planarFalloffPower != 0.0f)\n                    \{\n                        ramp /= pow(\n                            max(\n                                1e-6,\n                                fabs(_planarFalloffOffset + minDistanceToPlane)\n                            ),\n                            _planarFalloffPower\n                        );\n                    \}\n                \}\n                else if (_enableBoxRamp)\n                \{\n                    const float3 toBoxCenter = rayOrigin - _boxRampPosition;\n                    const float minDistanceToBox = distanceToRectangularPrism(\n                        matmul(__inverseBoxRotMatrix, toBoxCenter),\n                        _boxRampDimensions.x,\n                        _boxRampDimensions.y,\n                        _boxRampDimensions.z\n                    );\n                    if (minDistanceToBox >= _boxRampFalloff)\n                    \{\n                        continue;\n                    \}\n                    else if (minDistanceToBox > 0.0f)\n                    \{\n                        ramp *= (_boxRampFalloff - minDistanceToBox) / _boxRampFalloff;\n                    \}\n                    if (_boxFalloffPower != 0.0f)\n                    \{\n                        ramp /= pow(\n                            max(\n                                1e-6,\n                                _boxFalloffOffset + length(toBoxCenter)\n                            ),\n                            _boxFalloffPower\n                        );\n                    \}\n                \}\n\n                if (_enableDepthRamp)\n                \{\n                    // Apply the scaling specified by the depth ramp\n                    if (adjustedDepth < _depthRamp.y)\n                    \{\n                        ramp *= (\n                            (adjustedDepth - _depthRamp.y)\n                            / (_depthRamp.y - _depthRamp.x)\n                            + 1.0f\n                        );\n                    \}\n                    else if (adjustedDepth > _depthRamp.z)\n                    \{\n                        ramp *= (_depthRamp.w - adjustedDepth) / (_depthRamp.w - _depthRamp.z);\n                    \}\n                \}\n\n                // Compute the noise value at this position\n                float noiseValue = _density * ramp;\n                if (_noiseType == FBM_NOISE)\n                \{\n                    noiseValue *= fractalBrownianMotionNoise(rayOrigin);\n                \}\n                else\n                \{\n                    noiseValue *= turbulenceNoise(rayOrigin);\n                \}\n\n                // Over the noise values\n                resultPixel += noiseValue * invertedLastSample;\n                invertedLastSample *= saturate(1.0f - noiseValue);\n            \}\n\n            const float2 lastSeed = seed0;\n            seed0 = RAND_CONST_2 * float2(seed1.y, seed1.x) + RAND_CONST_3 * path;\n            seed1 = RAND_CONST_4 * lastSeed + RAND_CONST_5 * path;\n        \}\n\n        dst() = resultPixel / float(_raysPerPixel);\n    \}\n\};\n"
  rebuild ""
  FogKernelNoDepth_FocalLength {{parent.DummyCam.focal}}
  FogKernelNoDepth_HorizontalAperture {{parent.DummyCam.haperture}}
  FogKernelNoDepth_NearPlane {{parent.DummyCam.near}}
  FogKernelNoDepth_FarPlane {{parent.DummyCam.far}}
  FogKernelNoDepth_CameraWorldMatrix {
      {{parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix}}
      {{parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix}}
      {{parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix}}
      {{parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix}}
    }
  FogKernelNoDepth_FocalDistance {{parent.DummyCam.focal_point}}
  FogKernelNoDepth_fstop {{parent.DummyCam.fstop}}
  FogKernelNoDepth_EnableDepthOfField {{parent.depth_of_field}}
  FogKernelNoDepth_OutputLatLong {{parent.latlong}}
  FogKernelNoDepth_UseCameraDepth {{parent.camera_space}}
  FogKernelNoDepth_ScreenWidth {{"proxy? input0.width*proxy_scale: input0.width"}}
  FogKernelNoDepth_ScreenHeight {{"proxy? input0.height * proxy_scale : input0.height"}}
  FogKernelNoDepth_RaysPerPixel {{parent.rays_per_pixel}}
  FogKernelNoDepth_Density {{"parent.density * 50 / parent.samples_per_ray"}}
  FogKernelNoDepth_SamplesPerRay {{parent.samples_per_ray}}
  FogKernelNoDepth_EnableDepthRamp {{parent.enable_depth_ramp}}
  FogKernelNoDepth_SampleDepthRamp {{parent.depth_ramp_dummy.range.A} {parent.depth_ramp_dummy.range.B} {parent.depth_ramp_dummy.range.C} {parent.depth_ramp_dummy.range.D}}
  FogKernelNoDepth_SamplePlanarRamp {{-parent.in-parent.in_falloff} {-parent.in} {parent.out} {parent.out+parent.out_falloff}}
  FogKernelNoDepth_EnablePlanarRamp {{parent.enable_planar_ramp}}
  FogKernelNoDepth_PlanePosition {{parent.plane_point.x} {parent.plane_point.y} {parent.plane_point.z}}
  FogKernelNoDepth_PlaneNormal {{parent.plane_normal.x} {parent.plane_normal.y} {parent.plane_normal.z}}
  FogKernelNoDepth_PlanarFalloffPower {{parent.plane_falloff_power}}
  FogKernelNoDepth_PlanarFalloffOffset {{parent.plane_falloff_offset}}
  FogKernelNoDepth_EnableSphericalRamp {{parent.enable_spherical_ramp}}
  FogKernelNoDepth_SphericalRampPosition {{parent.spherical_ramp_position.x} {parent.spherical_ramp_position.y} {parent.spherical_ramp_position.z}}
  FogKernelNoDepth_SphericalRampRadii {{parent.spherical_ramp_start_radius} {parent.spherical_ramp_end_radius}}
  FogKernelNoDepth_SphericalFalloffPower {{parent.sphere_falloff_power}}
  FogKernelNoDepth_SphericalFalloffOffset {{parent.sphere_falloff_offset}}
  FogKernelNoDepth_BoxRampPosition {{parent.box_ramp_position} {parent.box_ramp_position} {parent.box_ramp_position}}
  FogKernelNoDepth_BoxRampRotation {{"parent.box_ramp_rotation * pi / 180"} {"parent.box_ramp_rotation * pi / 180"} {"parent.box_ramp_rotation * pi / 180"}}
  FogKernelNoDepth_BoxRampDimensions {{parent.knob.width} {parent.knob.height} {parent.depth}}
  FogKernelNoDepth_BoxRampFalloff {{parent.box_falloff_distance}}
  FogKernelNoDepth_EnableBoxRamp {{parent.enable_box_ramp}}
  FogKernelNoDepth_BoxFalloffPower {{parent.box_falloff_power}}
  FogKernelNoDepth_BoxFalloffOffset {{parent.box_falloff_offset}}
  FogKernelNoDepth_Size {{parent.size}}
  FogKernelNoDepth_NoiseType {{parent.type}}
  FogKernelNoDepth_Translation {{-parent.translation} {-parent.translation} {-parent.translation}}
  FogKernelNoDepth_Octaves {{parent.octaves}}
  FogKernelNoDepth_Lacunarity {{parent.lacunarity}}
  FogKernelNoDepth_Gain {{parent.gain}}
  FogKernelNoDepth_Gamma {{parent.gamma}}
  FogKernelNoDepth_LowFrequencyScale {{parent.low_frequency_scale} {parent.low_frequency_scale} {parent.low_frequency_scale} {parent.low_frequency_scale}}
  FogKernelNoDepth_HighFrequencyScale {{parent.high_frequency_scale} {parent.high_frequency_scale} {parent.high_frequency_scale} {parent.high_frequency_scale}}
  FogKernelNoDepth_LowFrequencyTranslation {{"parent.low_frequency_translation + parent.low_frequency_evolve * frame / 100"} {"parent.low_frequency_translation + parent.low_frequency_evolve * frame / 100"} {"parent.low_frequency_translation + parent.low_frequency_evolve * frame / 100"} {"parent.low_frequency_translation + parent.low_frequency_evolve * frame / 100"}}
  FogKernelNoDepth_HighFrequencyTranslation {{"parent.high_frequency_translation + parent.high_frequency_evolve * frame / 100"} {"parent.high_frequency_translation + parent.high_frequency_evolve * frame / 100"} {"parent.high_frequency_translation + parent.high_frequency_evolve * frame / 100"} {"parent.high_frequency_translation + parent.high_frequency_evolve * frame / 100"}}
  FogKernelNoDepth_HitTolerance {{parent.hit_tolerance}}
  FogKernelNoDepth_MaxDistance {{parent.max_distance}}
  rebuild_finalise ""
  name BlinkScript2
  xpos 1891
  ypos 1150
 }
 Switch {
  inputs 2
  which {{"\[exists parent.input1] || \[exists parent.input2]"}}
  name Switch1
  xpos 1891
  ypos 1227
 }
 TimeBlur {
  divisions 5
  shutteroffset centred
  shuttercustomoffset 0
  name TimeBlur1
  xpos 1891
  ypos 1253
  disable {{!parent.enable_motion_blur}}
 }
 Merge2 {
  inputs 2
  operation stencil
  bbox B
  name Merge2
  xpos 1891
  ypos 1357
  disable {{1-parent.holdout_mode}}
 }
 Switch {
  inputs 2
  which {{"parent.holdout_mode == 2"}}
  name Switch3
  xpos 1891
  ypos 1585
 }
 Switch {
  inputs 2
  which {{parent.output_deep}}
  name Switch4
  xpos 1891
  ypos 1645
 }
 Output {
  name Output1
  xpos 1891
  ypos 1700
 }
end_group
Dot {
 name Dot3
 selected true
 xpos -209
 ypos -4
}
