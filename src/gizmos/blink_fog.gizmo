#! /usr/local/Nuke13.2v2/libnuke-13.2.2.so -nx
version 13.2 v2
Gizmo {
 tile_color 0xffffffff
 addUserKnob {20 User l BlinkFog}
 addUserKnob {3 rays_per_pixel l "rays per pixel"}
 rays_per_pixel 1
 addUserKnob {3 samples_per_ray l "samples per ray"}
 samples_per_ray 5
 addUserKnob {7 density R 0 10}
 density 1
 addUserKnob {19 depth_ramp l "depth ramp" R 0 100}
 depth_ramp {10 12 20 22}
 addUserKnob {6 depth_of_field l "depth of field" +STARTLINE}
 addUserKnob {6 latlong -STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {7 size t "The size of the noise." R 1 300}
 size 10
 addUserKnob {4 type t "The noise type." M {turbulence fBm "" ""}}
 type fBm
 addUserKnob {13 translation t "Translate the noise by this amount."}
 addUserKnob {3 octaves t "The number of different frequencies to use."}
 octaves 4
 addUserKnob {7 lacunarity t "The per octave frequency multiplier." R 1 10}
 lacunarity 4
 addUserKnob {7 gain t "The per octave amplitude multiplier."}
 gain 0.5
 addUserKnob {7 gamma t "The result will be raised to 1 over this power."}
 gamma 0.5
 addUserKnob {19 low_frequency_scale l "low frequency scale"}
 low_frequency_scale {1 1 1 1}
 addUserKnob {19 high_frequency_scale l "high frequency scale"}
 high_frequency_scale {1 1 1 1}
 addUserKnob {19 low_frequency_translation l "low frequency translation"}
 low_frequency_translation {0 0 0 0}
 addUserKnob {19 high_frequency_translation l "high frequency translation"}
 high_frequency_translation {0 0 0 0}
 addUserKnob {26 div0 l "" +STARTLINE}
 addUserKnob {26 info l "" +STARTLINE T "v1.0.0 - (c) Owen Bulka & Riley Gray - 2024"}
}
 Input {
  inputs 0
  name camera
  xpos 1598
  ypos 900
 }
 Camera {
  projection_mode {{"\[expression \[value the_cam]projection_mode(\[value the_frame])]"}}
  focal {{"\[expression \[value the_cam]focal(\[value the_frame])]"}}
  haperture {{"\[expression \[value the_cam]haperture(\[value the_frame])]"}}
  vaperture {{"\[expression \[value the_cam]vaperture(\[value the_frame])]"}}
  near {{"\[expression \[value the_cam]near(\[value the_frame])]"}}
  far {{"\[expression \[value the_cam]far(\[value the_frame])]"}}
  win_translate {{"\[expression \[value the_cam]win_translate.u(\[value the_frame])]"} {"\[expression \[value the_cam]win_translate.v(\[value the_frame])]"}}
  win_scale {{"\[expression \[value the_cam]win_scale.u(\[value the_frame])]"} {"\[expression \[value the_cam]win_scale.v(\[value the_frame])]"}}
  winroll {{"\[expression \[value the_cam]winroll(\[value the_frame])]"}}
  focal_point {{"\[expression \[value the_cam]focal_point(\[value the_frame])]"}}
  fstop {{"\[expression \[value the_cam]fstop(\[value the_frame])]"}}
  name DummyCam
  help "DummyCam by Adrian Pueyo\n\nCamera that apart from the matrices also grabs all the \"Projection\" values from the upstream camera that it's connected to. Turns into a default Camera if no Camera connected. Can also be used inside of groups and gizmos, as many levels deep as you want :D All using live and super fast TCL.\n\nUpdated v1.1: Now grabs the correct frame too (thanks Erwan Leroy for the idea).\n\nUpdated v1.3: Now accepts Nuke13's Camera3\n\nadrianpueyo.com, 2019-2021"
  onCreate "n = nuke.thisNode()\nfor k in \[\"projection_mode\",\"focal\",\"haperture\",\"vaperture\",\"near\",\"far\",\"win_translate\",\"win_scale\",\"winroll\",\"focal_point\",\"fstop\"]:\n    n\[k].setFlag(0x0000000010000000)"
  xpos 1608
  ypos 1000
  addUserKnob {20 DummyCam l Defaults}
  addUserKnob {43 the_cam +INVISIBLE}
  the_cam "\[\n#DummyCam v1.3 - Updated 5 May 2021.\nset starting_point \"this.input0\"\nset default \"this.d_\"\n\n# If cam has no inputs, return the default.\nif \{\[exists \$starting_point]\} \{\n    set x \[node \$starting_point]\n\} \{ \n    return \$default\n\}\n\nset finished 0\nwhile \{\$finished != 1\} \{\n\n    # First look for a Cam or Input or topnode.\n    while \{\[class \$x] != \"Camera3\" && \[class \$x] != \"Camera2\" && \[class \$x] != \"Camera\" && \[class \$x] != \"Input\" && \$x != \[topnode \$x]\} \{\n        set x \[node \$x.input0]\n    \}\n\n    # Then, check if node is a cam (and return), and otherwise, if it's an input, see if the parent exists and move to it.\n    if \{\[class \$x]==\"Camera3\"||\[class \$x]==\"Camera2\"||\[class \$x]==\"Camera\"\} \{\n        set x \[append x \".\"]\n        return \$x\n    \} \{ \n        if \{ \[class \$x]==\"Input\" \} \{ \n            set inp \"\$x.parent.input\"\n            set inputNum \[value \$x.number]\n            set inp \[append inp \$inputNum]\n            if \{ \[exists \$inp] \} \{\n                set x \[node \$inp]\n            \} \{ \n                set finished 1\n            \}\n        \} \{ \n            set finished 1\n        \}\n    \}\n\}\nreturn \$default\n]"
  addUserKnob {43 the_frame +INVISIBLE}
  the_frame "\[\nset the_camera \[string trimright \[value the_cam] .]\nif \{\[exists \$the_camera]\} \{\n    return \[value \$the_camera.frame]\n\} \{ \n    return \[frame]\n\}\n]"
  addUserKnob {4 d_projection_mode l projection M {perspective orthographic uv spherical ""}}
  addUserKnob {7 d_focal l "focal length" R 0 100}
  d_focal 50
  addUserKnob {7 d_haperture l "horiz aperture" R 0 50}
  d_haperture 24.576
  addUserKnob {7 d_vaperture l "vert aperture" R 0 50}
  d_vaperture 18.672
  addUserKnob {7 d_near l near R 0 10}
  d_near 0.1
  addUserKnob {7 d_far l far R 0 10000}
  d_far 10000
  addUserKnob {30 d_win_translate l "window translate"}
  addUserKnob {30 d_win_scale l "window scale"}
  d_win_scale {1 1}
  addUserKnob {7 d_winroll l "window roll" R 0 45}
  addUserKnob {7 d_focal_point l "focal distance" R 0 10}
  d_focal_point 2
  addUserKnob {7 d_fstop l fstop R 0 30}
  d_fstop 16
  addUserKnob {26 version l " " t "Updated 5 May 2021" T "<span style=\"color:#666\"><br/><b>DummyCam v1.3</b> - <a href=\"http://www.adrianpueyo.com\" style=\"color:#666;text-decoration: none;\">adrianpueyo.com</a>, 2019-2021</span>"}
 }
 Constant {
  inputs 0
  channels {rgba.red rgba.green rgba.blue -rgba.alpha}
  name format_
  xpos 1755
  ypos 897
 }
 Noise {
  output {rgba.red -rgba.green -rgba.blue -rgba.alpha}
  type turbulence
  size 1
  zoffset 1.72
  lacunarity 1.6
  center {512 389}
  name Noise1
  xpos 1755
  ypos 968
 }
 Noise {
  output {-rgba.red rgba.green -rgba.blue -rgba.alpha}
  type turbulence
  size 1
  zoffset 1.82
  center {512 389}
  name Noise2
  xpos 1755
  ypos 992
 }
 Noise {
  output {-rgba.red -rgba.green rgba.blue -rgba.alpha}
  type turbulence
  size 1
  zoffset 4.12
  lacunarity 2.14
  center {512 389}
  name Noise3
  xpos 1755
  ypos 1016
 }
 Noise {
  output {-rgba.red -rgba.green -rgba.blue rgba.alpha}
  type turbulence
  size 1
  zoffset 0.14
  lacunarity 2.14
  center {512 389}
  name Noise4
  xpos 1755
  ypos 1042
 }
 BlinkScript {
  kernelSourceFile /home/ob1/software/nuke/dev/fog/src/blink/kernels/random.blink
  recompileCount 11
  ProgramGroup 1
  KernelDescription "2 \"Random\" iterate pixelWise 3f1c9af5a0660665ff261b4618c0b62fe5317414e0e936f0cb46bd242700f88e 2 \"seed\" Read Point \"dst\" Write Point 1 \"Inclusive Range\" Float 2 AAAAAAAAgD8= 1 \"_inclusiveRange\" 2 1 1 \"__rangeLength\" Float 1 1 AAAAAA=="
  kernelSource "// Copyright 2022 by Owen Bulka.\n// All rights reserved.\n// This file is released under the \"MIT License Agreement\".\n// Please see the LICENSE.md file that should have been included as part\n// of this package.\n\n\n/**\n * Compute the fractional portion of the value. Ex. 3.5 returns 0.5\n *\n * @arg value: The value to get the fractional portion of.\n *\n * @returns: The fractional portion of the value.\n */\ninline float fract(const float value)\n\{\n    return value - floor(value);\n\}\n\n\n/**\n * Get a random value on the interval \[0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval \[0, 1].\n */\ninline float random(const float seed)\n\{\n    return fract(sin(seed * 91.3458f) * 47453.5453f);\n\}\n\n\n/**\n * Get a random value on the interval \[0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval \[0, 1].\n */\ninline float3 random(const float3 &seed)\n\{\n    return float3(\n        random(seed.x),\n        random(seed.y),\n        random(seed.z)\n    );\n\}\n\n\n/**\n * Get a random value on the interval \[0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval \[0, 1].\n */\ninline float4 random(const float4 &seed)\n\{\n    return float4(\n        random(seed.x),\n        random(seed.y),\n        random(seed.z),\n        random(seed.w)\n    );\n\}\n\n\nkernel Random : ImageComputationKernel<ePixelWise>\n\{\n    Image<eRead, eAccessPoint, eEdgeNone> seed; // the input image\n    Image<eWrite> dst; // the output image\n\n\n    param:\n        float2 _inclusiveRange;\n\n    local:\n        float __rangeLength;\n\n\n    /**\n     * Give the parameters labels and default values.\n     */\n    void define()\n    \{\n        defineParam(_inclusiveRange, \"Inclusive Range\", float2(0, 1));\n    \}\n\n\n    /**\n     * Initialize the local variables.\n     */\n    void init()\n    \{\n        __rangeLength = _inclusiveRange.y - _inclusiveRange.x;\n    \}\n\n\n    /**\n     * Compute a random pixel value.\n     */\n    void process()\n    \{\n        dst() = __rangeLength * random(seed()) + _inclusiveRange.x;\n    \}\n\};\n"
  rebuild ""
  rebuild_finalise ""
  name BlinkScript7
  xpos 1755
  ypos 1080
 }
 BlinkScript {
  kernelSourceFile /home/ob1/software/nuke/dev/fog/src/blink/kernels/fog.blink
  recompileCount 70
  ProgramGroup 1
  KernelDescription "2 \"FogKernel\" iterate pixelWise 2419d17ccdd4cbc2aa41f58ad0b7f3acbd8b0e259c3dbe97f2282edfffeeab8f 2 \"noise\" Read Point \"dst\" Write Point 26 \"Focal Length\" Float 1 AABIQg== \"Horizontal Aperture\" Float 1 ppvEQQ== \"Near Plane\" Float 1 zczMPQ== \"Far Plane\" Float 1 AEAcRg== \"Camera World Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"Focal Distance\" Float 1 AACAQA== \"fstop\" Float 1 AACAQQ== \"Enable Depth Of Field\" Bool 1 AQ== \"Output LatLong\" Bool 1 AA== \"Screen Width\" Float 1 AABwRQ== \"Screen Height\" Float 1 AAAHRQ== \"Rays Per Pixel\" Int 1 AQAAAA== \"Density\" Float 1 AACAPw== \"Samples Per Ray\" Int 1 BQAAAA== \"Sample Depth Ramp\" Float 4 AACgQAAAIEEAAHBBAACgQQ== \"Size\" Float 1 AACgQQ== \"Noise Type\" Int 1 AAAAAA== \"Translation\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"Octaves\" Float 1 AAAAQQ== \"Lacunarity\" Float 1 AABAQA== \"Gain\" Float 1 AAAAPw== \"Gamma\" Float 1 AAAAPw== \"Low Frequency Scale\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"High Frequency Scale\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"Low Frequency Translation\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"High Frequency Translation\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== 26 \"_focalLength\" 1 1 \"_horizontalAperture\" 1 1 \"_nearPlane\" 1 1 \"_farPlane\" 1 1 \"_cameraWorldMatrix\" 16 1 \"_focalDistance\" 1 1 \"_fStop\" 1 1 \"_depthOfFieldEnabled\" 1 1 \"_latLong\" 1 1 \"_formatWidth\" 1 1 \"_formatHeight\" 1 1 \"_raysPerPixel\" 1 1 \"_density\" 1 1 \"_samplesPerRay\" 1 1 \"_depthRamp\" 4 1 \"_size\" 1 1 \"_noiseType\" 1 1 \"_translation\" 3 1 \"_octaves\" 1 1 \"_lacunarity\" 1 1 \"_gain\" 1 1 \"_gamma\" 1 1 \"_lowFrequencyScale\" 4 1 \"_highFrequencyScale\" 4 1 \"_lowFrequencyTranslation\" 4 1 \"_highFrequencyTranslation\" 4 1 5 \"__inverseCameraProjectionMatrix\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"__aperture\" Float 1 1 AAAAAA== \"__simplex\" Int 1 256 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"__perm\" Int 1 512 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"__grad4\" Int 1 128 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
  kernelSource "// Copyright 2024 by Owen Bulka.\n// All rights reserved.\n// This file is released under the \"MIT License Agreement\".\n// Please see the LICENSE.md file that should have been included as part\n// of this package.\n\n\n//\n// Math operations\n//\n\n\n/**\n * Compute the fractional portion of the value. Ex. 3.5 returns 0.5\n *\n * @arg value: The value to get the fractional portion of.\n *\n * @returns: The fractional portion of the value.\n */\ninline float fract(const float value)\n\{\n    return value - floor(value);\n\}\n\n\n/**\n * Saturate a value ie. clamp between 0 and 1\n *\n * @arg value: The value to saturate\n *\n * @returns: The clamped value\n */\ninline float saturate(float value)\n\{\n    return clamp(value, 0.0f, 1.0f);\n\}\n\n\n/**\n * Get a rotation matrix from radian angle values in ZYX order.\n *\n * @arg angles: The rotation angles in radians.\n * @arg out: The location to store the rotation matrix.\n */\ninline void rotationMatrix(const float3 &angles, float3x3 &out)\n\{\n    const float3 cosAngles = cos(angles);\n    const float3 sinAngles = sin(angles);\n\n    // Why tf can I not init a float3x3 normally??\n    out\[0]\[0] = cosAngles.y * cosAngles.z;\n    out\[0]\[1] = sinAngles.x * sinAngles.y * cosAngles.z - cosAngles.x * sinAngles.z;\n    out\[0]\[2] = cosAngles.x * sinAngles.y * cosAngles.z + sinAngles.x * sinAngles.z;\n    out\[1]\[0] = cosAngles.y * sinAngles.z;\n    out\[1]\[1] = sinAngles.x * sinAngles.y * sinAngles.z + cosAngles.x * cosAngles.z;\n    out\[1]\[2] = cosAngles.x * sinAngles.y * sinAngles.z - sinAngles.x * cosAngles.z;\n    out\[2]\[0] = -sinAngles.y;\n    out\[2]\[1] = sinAngles.x * cosAngles.y;\n    out\[2]\[2] = cosAngles.x * cosAngles.y;\n\}\n\n\n/**\n * Multiply a 4d vector by a 4x4 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline void matmul(const float4x4 &m, const float4 &v, float4 &out)\n\{\n    for (int i=0; i < 4; i++)\n    \{\n        out\[i] = 0;\n\n        for (int j=0; j < 4; j++)\n        \{\n            out\[i] += m\[i]\[j] * v\[j];\n        \}\n    \}\n\}\n\n\n/**\n * Multiply a 3d vector by a 3x3 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline void matmul(const float3x3 &m, const float3 &v, float3 &out)\n\{\n    out = float3(\n        m\[0]\[0] * v.x + m\[0]\[1] * v.y + m\[0]\[2] * v.z,\n        m\[1]\[0] * v.x + m\[1]\[1] * v.y + m\[1]\[2] * v.z,\n        m\[2]\[0] * v.x + m\[2]\[1] * v.y + m\[2]\[2] * v.z\n    );\n\}\n\n\n/**\n * Multiply a 4d vector by a 4x4 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline float4 matmul(const float4x4 &m, const float4 &v)\n\{\n    float4 out;\n    for (int i=0; i < 4; i++)\n    \{\n        out\[i] = 0;\n\n        for (int j=0; j < 4; j++)\n        \{\n            out\[i] += m\[i]\[j] * v\[j];\n        \}\n    \}\n\n    return out;\n\}\n\n\n/**\n * Multiply a 3d vector by a 3x3 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline float3 matmul(const float3x3 &m, const float3 &v)\n\{\n    return float3(\n        m\[0]\[0] * v.x + m\[0]\[1] * v.y + m\[0]\[2] * v.z,\n        m\[1]\[0] * v.x + m\[1]\[1] * v.y + m\[1]\[2] * v.z,\n        m\[2]\[0] * v.x + m\[2]\[1] * v.y + m\[2]\[2] * v.z\n    );\n\}\n\n\n/**\n * Convert the uv position in a latlong image to angles.\n *\n * @arg uvPosition: The UV position.\n *\n * @returns: The equivalent angles in radians.\n */\ninline float2 uvPositionToAngles(const float2 &uvPosition)\n\{\n    return float2(\n        (uvPosition.x + 1.0f) * PI,\n        (1.0f - uvPosition.y) * PI / 2.0f\n    );\n\}\n\n\n/**\n * Convert location of a pixel in an image into UV.\n *\n * @arg pixelLocation: The x, and y positions of the pixel.\n * @arg format: The image width, and height.\n *\n * @returns: The UV position.\n */\ninline float2 pixelsToUV(const float2 &pixelLocation, const float2 &format)\n\{\n    return float2(\n        2.0f * pixelLocation.x / format.x - 1.0f,\n        2.0f * pixelLocation.y / format.y - 1.0f\n    );\n\}\n\n\n/**\n * Convert a spherical unit vector (unit radius) to cartesion.\n *\n * @arg angles: The spherical angles in radians.\n *\n * @returns: The equivalent cartesion vector.\n */\ninline float3 sphericalUnitVectorToCartesion(const float2 &angles)\n\{\n    const float sinPhi = sin(angles.y);\n    return float3(\n        cos(angles.x) * sinPhi,\n        cos(angles.y),\n        sin(angles.x) * sinPhi\n    );\n\}\n\n\n/**\n * Get the position component of a world matrix.\n *\n * @arg worldMatrix: The world matrix.\n * @arg position: The location to store the position.\n */\ninline void positionFromWorldMatrix(const float4x4 &worldMatrix, float3 &position)\n\{\n    position = float3(\n        worldMatrix\[0]\[3],\n        worldMatrix\[1]\[3],\n        worldMatrix\[2]\[3]\n    );\n\}\n\n\n/**\n * Get the rotation component of a world matrix.\n *\n * @arg worldMatrix: The world matrix.\n * @arg rotation: The location to store the rotation.\n */\ninline void rotationFromWorldMatrix(const float4x4 &worldMatrix, float3x3 &rotationMatrix)\n\{\n    rotationMatrix\[0]\[0] = worldMatrix\[0]\[0];\n    rotationMatrix\[0]\[1] = worldMatrix\[0]\[1];\n    rotationMatrix\[0]\[2] = worldMatrix\[0]\[2];\n    rotationMatrix\[1]\[0] = worldMatrix\[1]\[0];\n    rotationMatrix\[1]\[1] = worldMatrix\[1]\[1];\n    rotationMatrix\[1]\[2] = worldMatrix\[1]\[2];\n    rotationMatrix\[2]\[0] = worldMatrix\[2]\[0];\n    rotationMatrix\[2]\[1] = worldMatrix\[2]\[1];\n    rotationMatrix\[2]\[2] = worldMatrix\[2]\[2];\n\}\n\n\n//\n// Randomization functions\n//\n\n\n// Some random constants on the interval \[1, 2]\n#define RAND_CONST_0 1.571411510193971f\n#define RAND_CONST_1 1.268632820084931f\n#define RAND_CONST_2 1.7880365647937733f\n#define RAND_CONST_3 1.3546987471558234f\n#define RAND_CONST_4 1.4365958250848703f\n#define RAND_CONST_5 1.7045380669435368f\n\n\n/**\n * Get a random value on the interval \[0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval \[0, 1].\n */\ninline float random(const float seed)\n\{\n    return fract(sin(73.1f * seed + 91.3458f) * 47453.5453f);\n\}\n\n\n/**\n * Get a random value on the interval \[0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval \[0, 1].\n */\ninline float2 random(const float2 &seed)\n\{\n    return float2(\n        fract(sin(13.157f * seed.x + 71.743f) * 7513.471f),\n        fract(sin(97.519f * seed.y + 113.591f) * 47453.5453f)\n    );\n\}\n\n\n/**\n * Create a random point that lies within the unit circle.\n *\n * @arg seed: The random seed.\n *\n * @returns: A random point, (radius, angle) in the unit circle.\n */\ninline float2 uniformPointInUnitCircle(const float2 &seed)\n\{\n    return float2(sqrt(random(seed.x)), 2.0f * PI * random(seed.y));\n\}\n\n\n#define FBM_NOISE 1\n\n\n/**\n * 4D Perlin simplex noise\n *\n * Copyright (c) 2007-2012 Eliot Eshelman\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n * @arg seed: The seed for the noise.\n * @arg simplex: The simplex LUT.\n * @arg perm: The perm LUT.\n * @arg grad4: The grad4 LUT.\n *\n * @returns: Noise value in the range \[-1, 1], value of 0 on all integer\n *     coordinates.\n */\ninline float perlinSimplexNoise(\n        const float4 &seed,\n        const int simplex\[64]\[4],\n        const int perm\[512],\n        const int grad4\[32]\[4])\n\{\n    const float F4 = (sqrt(5.0f) - 1.0f) / 4.0f;\n    const float G4 = (5.0f - sqrt(5.0f)) / 20.0f;\n\n    const float x = seed.x;\n    const float y = seed.y;\n    const float z = seed.z;\n    const float w = seed.w;\n\n    const float s = (x + y + z + w) * F4;\n    const int i = floor(x + s);\n    const int j = floor(y + s);\n    const int k = floor(z + s);\n    const int l = floor(w + s);\n    const float t = (i + j + k + l) * G4;\n    const float X0 = i - t;\n    const float Y0 = j - t;\n    const float Z0 = k - t;\n    const float W0 = l - t;\n\n    const float x0 = x - X0;\n    const float y0 = y - Y0;\n    const float z0 = z - Z0;\n    const float w0 = w - W0;\n    const int c1 = (x0 > y0) ? 32 : 0;\n    const int c2 = (x0 > z0) ? 16 : 0;\n    const int c3 = (y0 > z0) ? 8 : 0;\n    const int c4 = (x0 > w0) ? 4 : 0;\n    const int c5 = (y0 > w0) ? 2 : 0;\n    const int c6 = (z0 > w0) ? 1 : 0;\n    const int c = c1 + c2 + c3 + c4 + c5 + c6;\n\n    const int i1 = simplex\[c]\[0] >= 3 ? 1 : 0;\n    const int j1 = simplex\[c]\[1] >= 3 ? 1 : 0;\n    const int k1 = simplex\[c]\[2] >= 3 ? 1 : 0;\n    const int l1 = simplex\[c]\[3] >= 3 ? 1 : 0;\n    const int i2 = simplex\[c]\[0] >= 2 ? 1 : 0;\n    const int j2 = simplex\[c]\[1] >= 2 ? 1 : 0;\n    const int k2 = simplex\[c]\[2] >= 2 ? 1 : 0;\n    const int l2 = simplex\[c]\[3] >= 2 ? 1 : 0;\n    const int i3 = simplex\[c]\[0] >= 1 ? 1 : 0;\n    const int j3 = simplex\[c]\[1] >= 1 ? 1 : 0;\n    const int k3 = simplex\[c]\[2] >= 1 ? 1 : 0;\n    const int l3 = simplex\[c]\[3] >= 1 ? 1 : 0;\n\n    const float x1 = x0 - i1 + G4;\n    const float y1 = y0 - j1 + G4;\n    const float z1 = z0 - k1 + G4;\n    const float w1 = w0 - l1 + G4;\n    const float x2 = x0 - i2 + 2.0 * G4;\n    const float y2 = y0 - j2 + 2.0 * G4;\n    const float z2 = z0 - k2 + 2.0 * G4;\n    const float w2 = w0 - l2 + 2.0 * G4;\n    const float x3 = x0 - i3 + 3.0 * G4;\n    const float y3 = y0 - j3 + 3.0 * G4;\n    const float z3 = z0 - k3 + 3.0 * G4;\n    const float w3 = w0 - l3 + 3.0 * G4;\n    const float x4 = x0 - 1.0 + 4.0 * G4;\n    const float y4 = y0 - 1.0 + 4.0 * G4;\n    const float z4 = z0 - 1.0 + 4.0 * G4;\n    const float w4 = w0 - 1.0 + 4.0 * G4;\n\n    const int ii = i & 255;\n    const int jj = j & 255;\n    const int kk = k & 255;\n    const int ll = l & 255;\n\n    const int gi0 = perm\[ii + perm\[jj + perm\[kk + perm\[ll]]]] % 32;\n    const int gi1 = perm\[ii + i1 + perm\[jj + j1 + perm\[kk + k1 + perm\[ll + l1]]]] % 32;\n    const int gi2 = perm\[ii + i2 + perm\[jj +j2 + perm\[kk + k2 + perm\[ll + l2]]]] % 32;\n    const int gi3 = perm\[ii + i3 + perm\[jj +j3 + perm\[kk + k3 + perm\[ll + l3]]]] % 32;\n    const int gi4 = perm\[ii + 1 + perm\[jj +1 + perm\[kk + 1 + perm\[ll + 1]]]] % 32;\n\n    float n0, n1, n2, n3, n4;\n    float t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;\n    if (t0 < 0)\n    \{\n        n0 = 0.0;\n    \}\n    else\n    \{\n        t0 *= t0;\n        n0 = t0 * t0 * dot(\n            float4(grad4\[gi0]\[0], grad4\[gi0]\[2], grad4\[gi0]\[3], grad4\[gi0]\[3]),\n            float4(x0, y0, z0, w0)\n        );\n    \}\n\n    float t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;\n    if (t1 < 0)\n    \{\n        n1 = 0.0;\n    \}\n    else\n    \{\n        t1 *= t1;\n        n1 = t1 * t1 * dot(\n            float4(grad4\[gi1]\[0], grad4\[gi1]\[2], grad4\[gi1]\[3], grad4\[gi1]\[3]),\n            float4(x1, y1, z1, w1)\n        );\n    \}\n\n    float t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;\n    if (t2 < 0)\n    \{\n        n2 = 0.0;\n    \}\n    else\n    \{\n        t2 *= t2;\n        n2 = t2 * t2 * dot(\n            float4(grad4\[gi2]\[0], grad4\[gi2]\[2], grad4\[gi2]\[3], grad4\[gi2]\[3]),\n            float4(x2, y2, z2, w2)\n        );\n    \}\n\n    float t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;\n    if (t3 < 0)\n    \{\n        n3 = 0.0;\n    \}\n    else\n    \{\n        t3 *= t3;\n        n3 = t3 * t3 * dot(\n            float4(grad4\[gi3]\[0], grad4\[gi3]\[2], grad4\[gi3]\[3], grad4\[gi3]\[3]),\n            float4(x3, y3, z3, w3)\n        );\n    \}\n\n    float t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;\n    if (t4 < 0)\n    \{\n        n4 = 0.0;\n    \}\n    else \{\n        t4 *= t4;\n        n4 = t4 * t4 * dot(\n            float4(grad4\[gi4]\[0], grad4\[gi4]\[2], grad4\[gi4]\[3], grad4\[gi4]\[3]),\n            float4(x4, y4, z4, w4)\n        );\n    \}\n\n    return 27.0 * (n0 + n1 + n2 + n3 + n4);\n\}\n\n\n//\n// Use the perlin simplex noise\n//\n\n\n/**\n * fBM noise.\n *\n * @arg octaves: The number of different frequencies to use.\n * @arg lacunarity: The per octave frequency multiplier.\n * @arg size: The size of the noise.\n * @arg gain: The per octave amplitude multiplier.\n * @arg gamma: The result will be raised to 1 over this power.\n * @arg position: The position to seed the noise.\n * @arg lowFrequencyScale: The amount to scale the lower frequencies by.\n * @arg highFrequencyScale: The amount to scale the higher frequencies by.\n * @arg lowFrequencyTranslation: The translation of the lower frequencies.\n * @arg highFrequencyTranslation: The translation of the higher frequencies.\n * @arg simplex: The simplex LUT.\n * @arg perm: The perm LUT.\n * @arg grad4: The grad4 LUT.\n *\n * @returns: The noise value in the range \[-1, 1].\n */\nfloat fractalBrownianMotionNoise(\n        const float octaves,\n        const float lacunarity,\n        const float size,\n        const float gain,\n        const float gamma,\n        const float4 &position,\n        const float4 &lowFrequencyScale,\n        const float4 &highFrequencyScale,\n        const float4 &lowFrequencyTranslation,\n        const float4 &highFrequencyTranslation,\n        const int simplex\[64]\[4],\n        const int perm\[512],\n        const int grad4\[32]\[4])\n\{\n    float output = 0.0f;\n    float frequency = lacunarity;\n    float amplitude = 1.0f;\n    float denom = 0.0f;\n    float4 translation;\n    float4 scale;\n\n    for (int octave=0; octave < octaves; octave++)\n    \{\n        const float octaveFraction = octave / octaves;\n        scale = (\n            (highFrequencyScale * octaveFraction)\n            + (lowFrequencyScale * (1 - octaveFraction))\n        );       \n        translation = (\n            (highFrequencyTranslation * octaveFraction)\n            + (lowFrequencyTranslation * (1 - octaveFraction))\n        );\n\n        output += amplitude * perlinSimplexNoise(\n            (position * scale + translation) * frequency / size,\n            simplex,\n            perm,\n            grad4\n        );\n\n        frequency *= lacunarity;\n        denom += amplitude;\n        amplitude *= gain;\n    \}\n\n    if (denom == 0.0f || gamma == 0.0f)\n    \{\n        return 1.0f;\n    \}\n    return pow(output / denom, 1.0f / gamma);\n\}\n\n\n/**\n * Turbulence noise.\n *\n * @arg octaves: The number of different frequencies to use.\n * @arg lacunarity: The per octave frequency multiplier.\n * @arg size: The size of the noise.\n * @arg gain: The per octave amplitude multiplier.\n * @arg gamma: The result will be raised to 1 over this power.\n * @arg position: The position to seed the noise.\n * @arg lowFrequencyScale: The amount to scale the lower frequencies by.\n * @arg highFrequencyScale: The amount to scale the higher frequencies by.\n * @arg lowFrequencyTranslation: The translation of the lower frequencies.\n * @arg highFrequencyTranslation: The translation of the higher frequencies.\n * @arg simplex: The simplex LUT.\n * @arg perm: The perm LUT.\n * @arg grad4: The grad4 LUT.\n *\n * @returns: The noise value in the range \[0, 1].\n */\nfloat turbulenceNoise(\n        const float octaves,\n        const float lacunarity,\n        const float size,\n        const float gain,\n        const float gamma,\n        const float4 &position,\n        const float4 &lowFrequencyScale,\n        const float4 &highFrequencyScale,\n        const float4 &lowFrequencyTranslation,\n        const float4 &highFrequencyTranslation,\n        const int simplex\[64]\[4],\n        const int perm\[512],\n        const int grad4\[32]\[4])\n\{\n    float output = 0.0f;\n    float frequency = lacunarity;\n    float amplitude = 1.0f;\n    float denom = 0.0f;\n    float4 translation;\n    float4 scale;\n\n    for (int octave=0; octave < octaves; octave++)\n    \{\n        const float octaveFraction = octave / octaves;\n        scale = (\n            (highFrequencyScale * octaveFraction)\n            + (lowFrequencyScale * (1 - octaveFraction))\n        );       \n        translation = (\n            (highFrequencyTranslation * octaveFraction)\n            + (lowFrequencyTranslation * (1 - octaveFraction))\n        );\n\n        output += fabs(\n            amplitude * perlinSimplexNoise(\n                (position * scale + translation) * frequency / size,\n                simplex,\n                perm,\n                grad4\n            )\n        );\n\n        frequency *= lacunarity;\n        denom += amplitude;\n        amplitude *= gain;\n    \}\n\n    if (denom == 0.0f || gamma == 0.0f)\n    \{\n        return 1.0f;\n    \}\n    return pow(output / denom, 1.0f / gamma);\n\}\n\n\n//\n// Camera Utilities\n//\n\n\n/**\n * Compute the field of view from focal length.\n *\n * @arg focalLength: The focal length.\n *\n * @returns: The equivalent field of view.\n */\ninline float fieldOfView(const float focalLength)\n\{\n    return 2 * atan(1 / focalLength);\n\}\n\n\n/**\n * Compute the aspect ratio from image format.\n *\n * @arg height_: The height of the image.\n * @arg width_: The width of the image.\n *\n * @returns: The aspect ratio.\n */\ninline float aspectRatio(const float height_, const float width_)\n\{\n    return height_ / width_;\n\}\n\n\n/**\n *\n */\ninline float fStopToAperture(const float fStop, const float focalLength)\n\{\n    return focalLength / fStop / 1000.0f;\n\}\n\n\n/**\n * Create a projection matrix for a camera.\n *\n * @arg focalLength: The focal length of the camera.\n * @arg horizontalAperture: The horizontal aperture of the camera.\n * @arg aspect: The aspect ratio of the camera.\n * @arg nearPlane: The distance to the near plane of the camera.\n * @arg farPlane: The distance to the far plane of the camera.\n *\n * @returns: The camera's projection matrix.\n */\nfloat4x4 projectionMatrix(\n        const float focalLength,\n        const float horizontalAperture,\n        const float aspect,\n        const float nearPlane,\n        const float farPlane)\n\{\n    float farMinusNear = farPlane - nearPlane;\n    return float4x4(\n        2 * focalLength / horizontalAperture, 0, 0, 0,\n        0, 2 * focalLength / horizontalAperture / aspect, 0, 0,\n        0, 0, -(farPlane + nearPlane) / farMinusNear, -2 * (farPlane * nearPlane) / farMinusNear,\n        0, 0, -1, 0\n    );\n\}\n\n\n/**\n * Generate a ray out of a camera.\n *\n * @arg cameraWorldMatrix: The camera matrix.\n * @arg inverseProjectionMatrix: The inverse of the projection matrix.\n * @arg uvPosition: The UV position in the resulting image.\n * @arg rayOrigin: Will store the origin of the ray.\n * @arg rayDirection: Will store the direction of the ray.\n */\nvoid createCameraRay(\n        const float4x4 &cameraWorldMatrix,\n        const float4x4 &inverseProjectionMatrix,\n        const float2 &uvPosition,\n        float3 &rayOrigin,\n        float3 &rayDirection)\n\{\n    positionFromWorldMatrix(cameraWorldMatrix, rayOrigin);\n    float4 direction = matmul(\n        inverseProjectionMatrix,\n        float4(uvPosition.x, uvPosition.y, 0, 1)\n    );\n    matmul(\n        cameraWorldMatrix,\n        float4(direction.x, direction.y, direction.z, 0),\n        direction\n    );\n    rayDirection = normalize(float3(direction.x, direction.y, direction.z));\n\}\n\n\n/**\n * Generate a ray out of a camera.\n *\n * @arg cameraWorldMatrix: The camera matrix.\n * @arg inverseProjectionMatrix: The inverse of the projection matrix.\n * @arg uvPosition: The UV position in the resulting image.\n * @arg rayOrigin: Will store the origin of the ray.\n * @arg rayDirection: Will store the direction of the ray.\n */\nvoid createCameraRay(\n        const float4x4 &cameraWorldMatrix,\n        const float4x4 &inverseProjectionMatrix,\n        const float2 &uvPosition,\n        const float aperture,\n        const float focalDistance,\n        const float2 &seed,\n        float3 &rayOrigin,\n        float3 &rayDirection)\n\{\n    createCameraRay(\n        cameraWorldMatrix,\n        inverseProjectionMatrix,\n        uvPosition,\n        rayOrigin,\n        rayDirection\n    );\n\n    const float4 cameraForward4 = matmul(\n        cameraWorldMatrix,\n        float4(0, 0, -1, 0)\n    );\n    const float3 cameraForward = float3(\n        cameraForward4.x,\n        cameraForward4.y,\n        cameraForward4.z\n    );\n    const float4 cameraRight4 = matmul(\n        cameraWorldMatrix,\n        float4(1, 0, 0, 0)\n    );\n    const float3 cameraRight = float3(\n        cameraRight4.x,\n        cameraRight4.y,\n        cameraRight4.z\n    );\n    const float4 cameraUp4 = matmul(\n        cameraWorldMatrix,\n        float4(0, 1, 0, 0)\n    );\n    const float3 cameraUp = float3(\n        cameraUp4.x,\n        cameraUp4.y,\n        cameraUp4.z\n    );\n\n    const float3 focalPlanePoint = rayOrigin + cameraForward * focalDistance;\n    const float3 focalPlaneNormal = -cameraForward;\n\n    const float focalPointDistance = (\n        (dot(focalPlaneNormal, focalPlanePoint) - dot(rayOrigin, focalPlaneNormal))\n        / dot(rayDirection, focalPlaneNormal)\n    );\n    const float3 focalPoint = rayOrigin + focalPointDistance * rayDirection;\n\n    const float2 pointInUnitCircle = uniformPointInUnitCircle(seed);\n    const float2 offset = pointInUnitCircle.x * aperture * float2(\n        cos(pointInUnitCircle.y),\n        sin(pointInUnitCircle.y)\n    );\n\n    rayOrigin += cameraRight * offset.x + cameraUp * offset.y;\n    rayDirection = normalize(focalPoint - rayOrigin);\n\}\n\n\n/**\n * Generate a LatLong ray out of a camera.\n *\n * @arg cameraWorldMatrix: The camera matrix.\n * @arg uvPosition: The UV position in the resulting image.\n * @arg rayOrigin: Will store the origin of the ray.\n * @arg rayDirection: Will store the direction of the ray.\n */\nvoid createLatLongCameraRay(\n        const float4x4 &cameraWorldMatrix,\n        const float2 &uvPosition,\n        float3 &rayOrigin,\n        float3 &rayDirection)\n\{\n    positionFromWorldMatrix(cameraWorldMatrix, rayOrigin);\n    rayDirection = sphericalUnitVectorToCartesion(uvPositionToAngles(uvPosition));\n\n    float3x3 cameraRotation;\n    rotationFromWorldMatrix(cameraWorldMatrix, cameraRotation);\n    rayDirection = matmul(cameraRotation, rayDirection);\n\}\n\n\n\nkernel FogKernel : ImageComputationKernel<ePixelWise>\n\{\n    // the input which specifies the format, process is called once per pixel\n    // in this image, which also provides random seeds\n    Image<eRead, eAccessPoint, eEdgeNone> noise;\n\n    // the output image\n    Image<eWrite> dst;\n\n\n    param:\n        // These parameters are made available to the user.\n\n        // Camera params\n        float _focalLength;\n        float _horizontalAperture;\n        float _nearPlane;\n        float _farPlane;\n        float4x4 _cameraWorldMatrix;\n        float _focalDistance;\n        float _fStop;\n        bool _depthOfFieldEnabled;\n        bool _latLong;\n\n        // Image params\n        float _formatWidth;\n        float _formatHeight;\n        int _raysPerPixel;\n        float _density;\n        int _samplesPerRay;\n        float4 _depthRamp;\n\n        // Noise Parameters\n        float _size;\n        int _noiseType;\n        float3 _translation;\n        float _octaves;\n        float _lacunarity;\n        float _gain;\n        float _gamma;\n        float4 _lowFrequencyScale;\n        float4 _highFrequencyScale;\n        float4 _lowFrequencyTranslation;\n        float4 _highFrequencyTranslation;\n\n    local:\n        // These local variables are not exposed to the user.\n        float4x4 __inverseCameraProjectionMatrix;\n        float __aperture;\n\n        int __simplex\[64]\[4];\n        int __perm\[512];\n        int __grad4\[32]\[4];\n\n    /**\n     * Give the parameters labels and default values.\n     */\n    void define()\n    \{\n        // Camera params\n        defineParam(_focalLength, \"Focal Length\", 50.0f);\n        defineParam(_horizontalAperture, \"Horizontal Aperture\", 24.576f);\n        defineParam(_nearPlane, \"Near Plane\", 0.1f);\n        defineParam(_farPlane, \"Far Plane\", 10000.0f);\n        defineParam(\n            _cameraWorldMatrix,\n            \"Camera World Matrix\",\n            float4x4(\n                1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1\n            )\n        );\n        defineParam(_focalDistance, \"Focal Distance\", 4.0f);\n        defineParam(_fStop, \"fstop\", 16.0f);\n        defineParam(_depthOfFieldEnabled, \"Enable Depth Of Field\", true);\n        defineParam(_latLong, \"Output LatLong\", false);\n\n        // Image params\n        defineParam(_formatHeight, \"Screen Height\", 2160.0f);\n        defineParam(_formatWidth, \"Screen Width\", 3840.0f);\n        defineParam(_density, \"Density\", 1.0f);\n        defineParam(_raysPerPixel, \"Rays Per Pixel\", 1);\n        defineParam(_samplesPerRay, \"Samples Per Ray\", 5);\n        defineParam(_depthRamp, \"Sample Depth Ramp\", float4(5.0f, 10.0f, 15.0f, 20.0f));\n\n        // Noise Parameters\n        defineParam(_size, \"Size\", 20.0f);\n        defineParam(_noiseType, \"Noise Type\", 0);\n        defineParam(_translation, \"Translation\", float3(0.0f, 0.0f, 0.0f));\n        defineParam(_octaves, \"Octaves\", 8.0f);\n        defineParam(_lacunarity, \"Lacunarity\", 3.0f);\n        defineParam(_gain, \"Gain\", 0.5f);\n        defineParam(_gamma, \"Gamma\", 0.5f);\n        defineParam(_lowFrequencyScale, \"Low Frequency Scale\", float4(0.0f, 0.0f, 0.0f, 0.0f));\n        defineParam(_highFrequencyScale, \"High Frequency Scale\", float4(0.0f, 0.0f, 0.0f, 0.0f));\n        defineParam(_lowFrequencyTranslation, \"Low Frequency Translation\", float4(0.0f, 0.0f, 0.0f, 0.0f));\n        defineParam(_highFrequencyTranslation, \"High Frequency Translation\", float4(0.0f, 0.0f, 0.0f, 0.0f));\n    \}\n\n\n    /**\n     * Initialize the local variables.\n     */\n    void init()\n    \{\n        const float aspect = aspectRatio(_formatHeight, _formatWidth);\n        float4x4 cameraProjectionMatrix = projectionMatrix(\n            _focalLength,\n            _horizontalAperture,\n            aspect,\n            _nearPlane,\n            _farPlane\n        );\n        __inverseCameraProjectionMatrix = cameraProjectionMatrix.invert();\n\n        __aperture = fStopToAperture(_fStop, _focalLength);\n\n        const int simplexInit\[64]\[4] = \{\n            \{0, 1, 2, 3\}, \{0, 1, 3, 2\}, \{0, 0, 0, 0\}, \{0, 2, 3, 1\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{1, 2, 3, 0\},\n            \{0, 2, 1, 3\}, \{0, 0, 0, 0\}, \{0, 3, 1, 2\}, \{0, 3, 2, 1\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{1, 3, 2, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{1, 2, 0, 3\}, \{0, 0, 0, 0\}, \{1, 3, 0, 2\}, \{0, 0, 0, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{2, 3, 0, 1\}, \{2, 3, 1, 0\},\n            \{1, 0, 2, 3\}, \{1, 0, 3, 2\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{0, 0, 0, 0\}, \{2, 0, 3, 1\}, \{0, 0, 0, 0\}, \{2, 1, 3, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{2, 0, 1, 3\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{3, 0, 1, 2\}, \{3, 0, 2, 1\}, \{0, 0, 0, 0\}, \{3, 1, 2, 0\},\n            \{2, 1, 0, 3\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{3, 1, 0, 2\}, \{0, 0, 0, 0\}, \{3, 2, 0, 1\}, \{3, 2, 1, 0\}\n        \};\n\n        for (int i = 0; i < 64; i++)\n        \{\n            for (int j = 0; j < 4; j++)\n            \{\n                __simplex\[i]\[j] = simplexInit\[i]\[j];\n            \}\n        \}\n\n        const int permInit\[256] = \{\n            151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233,\n            7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23,\n            190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219,\n            203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174,\n            20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48,\n            27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133,\n            230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65,\n            25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18,\n            169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198,\n            173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147,\n            118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17,\n            182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44,\n            154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22,\n            39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112,\n            104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12,\n            191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49,\n            192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121,\n            50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29,\n            24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180\n        \};\n\n        for (int i = 0; i < 512; i++)\n        \{\n            __perm\[i] = permInit\[i % 256];\n        \}\n\n        const int grad4Init\[32]\[4]= \{\n            \{0, 1, 1, 1\},  \{0, 1, 1, -1\},  \{0, 1, -1, 1\},  \{0, 1, -1, -1\},\n            \{0, -1, 1, 1\}, \{0, -1, 1, -1\}, \{0, -1, -1, 1\}, \{0, -1, -1, -1\},\n            \{1, 0, 1, 1\},  \{1, 0, 1, -1\},  \{1, 0, -1, 1\},  \{1, 0, -1, -1\},\n            \{-1, 0, 1, 1\}, \{-1, 0, 1, -1\}, \{-1, 0, -1, 1\}, \{-1, 0, -1, -1\},\n            \{1, 1, 0, 1\},  \{1, 1, 0, -1\},  \{1, -1, 0, 1\},  \{1, -1, 0, -1\},\n            \{-1, 1, 0, 1\}, \{-1, 1, 0, -1\}, \{-1, -1, 0, 1\}, \{-1, -1, 0, -1\},\n            \{1, 1, 1, 0\},  \{1, 1, -1, 0\},  \{1, -1, 1, 0\},  \{1, -1, -1, 0\},\n            \{-1, 1, 1, 0\}, \{-1, 1, -1, 0\}, \{-1, -1, 1, 0\}, \{-1, -1, -1, 0\}\n        \};\n\n        for (int i = 0; i < 32; i++)\n        \{\n            for (int j = 0; j < 4; j++)\n            \{\n                __grad4\[i]\[j] = grad4Init\[i]\[j];\n            \}\n        \}\n    \}\n\n\n    /**\n     * Create a ray out of the camera. It will be either a standard ray,\n     * a latlong ray, or a ray that will result in depth of field.\n     *\n     * @arg seed: The seed to use in randomization.\n     * @arg pixelLocation: The x, and y locations of the pixel.\n     * @arg rayOrigin: The location to store the origin of the new ray.\n     * @arg rayDirection: The location to store the direction of the new\n     *     ray.\n     */\n    void getCameraRay(\n            const float2 &seed,\n            const float2 &pixelLocation,\n            float3 &rayOrigin,\n            float3 &rayDirection)\n    \{\n        const float2 uvCoordinates = pixelsToUV(\n            pixelLocation + random(seed),\n            float2(_formatWidth, _formatHeight)\n        );\n        if (_latLong)\n        \{\n            createLatLongCameraRay(\n                _cameraWorldMatrix,\n                uvCoordinates,\n                rayOrigin,\n                rayDirection\n            );\n        \}\n        else if (_depthOfFieldEnabled)\n        \{\n            createCameraRay(\n                _cameraWorldMatrix,\n                __inverseCameraProjectionMatrix,\n                uvCoordinates,\n                __aperture,\n                _focalDistance,\n                seed,\n                rayOrigin,\n                rayDirection\n            );\n        \}\n        else\n        \{\n            createCameraRay(\n                _cameraWorldMatrix,\n                __inverseCameraProjectionMatrix,\n                uvCoordinates,\n                rayOrigin,\n                rayDirection\n            );\n        \}\n    \}\n\n\n    /**\n     * Compute a raymarched pixel value.\n     *\n     * @arg pos: The x, and y location we are currently processing.\n     */\n    void process(int2 pos)\n    \{\n        float2 pixelLocation = float2(pos.x, pos.y);\n        SampleType(noise) noisePixel = noise();\n        float2 seed0 = float2(noisePixel.x, noisePixel.y) + RAND_CONST_0 * pixelLocation;\n        float2 seed1 = float2(noisePixel.z, noisePixel.w) + RAND_CONST_1 * pixelLocation;\n\n        float4 resultPixel = float4(0.0f);\n\n        const float sampleRange = _depthRamp.w - _depthRamp.x;\n        const float sampleStep = sampleRange / (float) _samplesPerRay;\n\n        for (int path=1; path <= _raysPerPixel; path++)\n        \{\n            // Generate a ray from the camera\n            float3 rayOrigin;\n            float3 rayDirection;\n            getCameraRay(\n                seed0,\n                pixelLocation,\n                rayOrigin,\n                rayDirection\n            );\n\n            float depth = _depthRamp.x;\n            rayOrigin += depth * rayDirection + _translation;\n\n            float invertedLastSample = 1.0f;\n            for (int step=0; step < _samplesPerRay; step++)\n            \{\n                depth += sampleStep;\n                rayOrigin += rayDirection * sampleStep;\n\n                // Get the noise value based on which type of noise we are using\n                const float4 samplePosition4d = float4(\n                    rayOrigin.x,\n                    rayOrigin.y,\n                    rayOrigin.z,\n                    0.0f\n                );\n                float ramp;\n                if (depth < _depthRamp.y)\n                \{\n                    ramp = (depth - _depthRamp.y) / (_depthRamp.y - _depthRamp.x) + 1.0f;\n                \}\n                else if (depth >= _depthRamp.y && depth <= _depthRamp.z)\n                \{\n                    ramp = 1.0f;\n                \}\n                else\n                \{\n                    ramp = (_depthRamp.w - depth) / (_depthRamp.w - _depthRamp.z);\n                \}\n\n                float noiseValue = _density * ramp;\n                if (_noiseType == FBM_NOISE)\n                \{\n                    noiseValue *= fractalBrownianMotionNoise(\n                        _octaves,\n                        _lacunarity,\n                        _size,\n                        _gain,\n                        _gamma,\n                        samplePosition4d,\n                        _lowFrequencyScale,\n                        _highFrequencyScale,\n                        _lowFrequencyTranslation,\n                        _highFrequencyTranslation,\n                        __simplex,\n                        __perm,\n                        __grad4\n                    );\n                \}\n                else\n                \{\n                    noiseValue *= turbulenceNoise(\n                        _octaves,\n                        _lacunarity,\n                        _size,\n                        _gain,\n                        _gamma,\n                        samplePosition4d,\n                        _lowFrequencyScale,\n                        _highFrequencyScale,\n                        _lowFrequencyTranslation,\n                        _highFrequencyTranslation,\n                        __simplex,\n                        __perm,\n                        __grad4\n                    );\n                \}\n\n                resultPixel += noiseValue * invertedLastSample;\n                invertedLastSample *= 1.0f - noiseValue;\n            \}\n\n            const float2 lastSeed = seed0;\n            seed0 = RAND_CONST_2 * float2(seed1.y, seed1.x) + RAND_CONST_3 * path;\n            seed1 = RAND_CONST_4 * lastSeed + RAND_CONST_5 * path;\n        \}\n\n        dst() = resultPixel / float(_raysPerPixel);\n    \}\n\};\n"
  rebuild ""
  "FogKernel_Focal Length" {{parent.DummyCam.focal}}
  "FogKernel_Horizontal Aperture" {{parent.DummyCam.haperture}}
  "FogKernel_Near Plane" {{parent.DummyCam.near}}
  "FogKernel_Far Plane" {{parent.DummyCam.far}}
  "FogKernel_Camera World Matrix" {
      {{parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix}}
      {{parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix}}
      {{parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix}}
      {{parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix}}
    }
  "FogKernel_Focal Distance" {{parent.DummyCam.focal_point}}
  FogKernel_fstop {{parent.DummyCam.fstop}}
  "FogKernel_Enable Depth Of Field" {{parent.depth_of_field}}
  "FogKernel_Output LatLong" {{parent.latlong}}
  "FogKernel_Screen Width" {{input0.width}}
  "FogKernel_Screen Height" {{input0.height}}
  "FogKernel_Rays Per Pixel" {{parent.rays_per_pixel}}
  FogKernel_Density {{parent.density}}
  "FogKernel_Samples Per Ray" {{parent.samples_per_ray}}
  "FogKernel_Sample Depth Ramp" {{parent.depth_ramp} {parent.depth_ramp} {parent.depth_ramp} {parent.depth_ramp}}
  FogKernel_Size {{parent.size}}
  "FogKernel_Noise Type" {{parent.type}}
  FogKernel_Translation {{-parent.translation} {-parent.translation} {-parent.translation}}
  FogKernel_Octaves {{parent.octaves}}
  FogKernel_Lacunarity {{parent.lacunarity}}
  FogKernel_Gain {{parent.gain}}
  FogKernel_Gamma {{parent.gamma}}
  "FogKernel_Low Frequency Scale" {{parent.low_frequency_scale} {parent.low_frequency_scale} {parent.low_frequency_scale} {parent.low_frequency_scale}}
  "FogKernel_High Frequency Scale" {{parent.high_frequency_scale} {parent.high_frequency_scale} {parent.high_frequency_scale} {parent.high_frequency_scale}}
  "FogKernel_Low Frequency Translation" {{parent.low_frequency_translation} {parent.low_frequency_translation} {parent.low_frequency_translation} {parent.low_frequency_translation}}
  "FogKernel_High Frequency Translation" {{parent.high_frequency_translation} {parent.high_frequency_translation} {parent.high_frequency_translation} {parent.high_frequency_translation}}
  rebuild_finalise ""
  name BlinkScript1
  xpos 1755
  ypos 1148
 }
 Output {
  name Output1
  xpos 1755
  ypos 1314
 }
end_group
