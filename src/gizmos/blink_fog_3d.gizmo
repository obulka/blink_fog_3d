Gizmo {
 inputs 3
 knobChanged "\n# Copyright 2022 by Owen Bulka.\n# All rights reserved.\n# This file is released under the \"MIT License Agreement\".\n# Please see the LICENSE.md file that should have been included as part\n# of this package.\nimport logging\n\nimport nuke\n\n_LOGGER = logging.getLogger(\"blink_fog\")\n\n\nclass KnobChangedCallbacks(dict):\n    def register(self, knob_name):\n        def decorated(method):\n            self\[knob_name] = method\n            return method\n        return decorated\n\n    def register_multiple(self, knob_names):\n        def decorated(method):\n            for knob_name in knob_names:\n                self\[knob_name] = method\n            return method\n        return decorated\n\n\nclass KnobManager(object):\n    _knob_changed_callbacks = KnobChangedCallbacks()\n\n    def __init__(self):\n        self._node = nuke.thisNode()\n        self._knob = nuke.thisKnob()\n\n    def handle_node_created(self):\n        self._input_changed()\n\n    def handle_knob_changed(self):\n        knob_name = self._knob.name()\n        try:\n            type(self)._knob_changed_callbacks.get(knob_name)(self)\n        except TypeError:\n            _LOGGER.debug(\"No callbacks for knob: %s\", knob_name)\n\n    @_knob_changed_callbacks.register(\"inputChange\")\n    def _input_changed(self):\n        pass\n\n\nclass BlinkFogKnobManager(KnobManager):\n    _knob_changed_callbacks = KnobChangedCallbacks(KnobManager._knob_changed_callbacks)\n\n    _deep_blender = \"deep_blender\"\n    _input_name = \"Input1\"\n    _deep_merge = \"DeepMerge\"\n    _time_warp = \"TimeWarp\"\n    _expression = \"Expression\"\n    _alpha_expression = \"ExprAlpha\"\n    _deep_from_image = \"DeepFromImage\"\n    _holdout_mode = \"holdout_mode\"\n    _samples_per_ray = \"samples_per_ray\"\n    _rays_per_pixel = \"rays_per_pixel\"\n    _output_deep = \"output_deep\"\n\n    def __init__(self):\n        super(BlinkFogKnobManager, self).__init__()\n\n    def _add_deep_samples(self, samples_to_add, current_deep_samples):\n        even = current_deep_samples % 2 == 0\n\n        input_pos = nuke.toNode(self._input_name).knob(\"xpos\").value()\n        time_warp_y_pos = nuke.toNode(self._time_warp + \"0\").knob(\"ypos\").value()\n        node_spacing_x = 150\n        node_spacing_y = 50\n\n        for sample in range(samples_to_add):\n            current_sample = current_deep_samples + sample\n            x_pos = input_pos + current_sample * node_spacing_x\n            if even:\n                time_warp = nuke.nodes.TimeWarp()\n                time_warp.setInput(0, nuke.toNode(self._input_name))\n                time_warp.knob(\"name\").setValue(self._time_warp + \"\{\}\".format(current_sample))\n                time_warp.knob(\"xpos\").setValue(x_pos)\n                time_warp.knob(\"ypos\").setValue(time_warp_y_pos)\n                time_warp.knob(\"filter\").setValue(\"none\")\n                time_warp.knob(\"lookup\").setExpression(\"frame + (1/parent.samples_per_ray*\{\})\".format(current_sample))\n\n                expression = nuke.nodes.Expression()\n                expression.setInput(0, time_warp)\n                expression.knob(\"name\").setValue(self._expression + \"\{\}\".format(current_sample))\n                expression.knob(\"xpos\").setValue(x_pos)\n                expression.knob(\"ypos\").setValue(time_warp_y_pos + node_spacing_y)\n                expression.knob(\"expr0\").setValue(\"r\")\n                expression.knob(\"expr1\").setValue(\"r\")\n                expression.knob(\"expr2\").setValue(\"r\")\n                expression.knob(\"expr3\").setValue(\"1/g\")\n                expression.knob(\"channel3\").setValue(\"depth\")\n\n                alpha_expression = nuke.nodes.Expression()\n                alpha_expression.setInput(0, expression)\n                alpha_expression.knob(\"name\").setValue(self._alpha_expression + \"\{\}\".format(current_sample))\n                alpha_expression.knob(\"xpos\").setValue(x_pos)\n                alpha_expression.knob(\"ypos\").setValue(time_warp_y_pos + 2 * node_spacing_y)\n                alpha_expression.knob(\"expr3\").setValue(\"r\")\n\n                deep_from_image = nuke.nodes.DeepFromImage()\n                deep_from_image.setInput(0, alpha_expression)\n                deep_from_image.knob(\"name\").setValue(self._deep_from_image + \"\{\}\".format(current_sample))\n                deep_from_image.knob(\"xpos\").setValue(x_pos)\n                deep_from_image.knob(\"ypos\").setValue(time_warp_y_pos + 3 * node_spacing_y)\n                deep_from_image.knob(\"premult\").setValue(True)\n\n                deep_merge = nuke.toNode(self._deep_merge)\n                deep_merge.setInput(current_sample, deep_from_image)\n\n            else:\n                time_warp = nuke.toNode(self._time_warp + \"\{\}\".format(current_sample - 1))\n\n                expression = nuke.nodes.Expression()\n                expression.setInput(0, time_warp)\n                expression.knob(\"name\").setValue(self._expression + \"\{\}\".format(current_sample))\n                expression.knob(\"xpos\").setValue(x_pos)\n                expression.knob(\"ypos\").setValue(time_warp_y_pos + node_spacing_y)\n                expression.knob(\"expr0\").setValue(\"b\")\n                expression.knob(\"expr1\").setValue(\"b\")\n                expression.knob(\"expr2\").setValue(\"b\")\n                expression.knob(\"expr3\").setValue(\"1/a\")\n                expression.knob(\"channel3\").setValue(\"depth\")\n\n                alpha_expression = nuke.nodes.Expression()\n                alpha_expression.setInput(0, expression)\n                alpha_expression.knob(\"name\").setValue(self._alpha_expression + \"\{\}\".format(current_sample))\n                alpha_expression.knob(\"xpos\").setValue(x_pos)\n                alpha_expression.knob(\"ypos\").setValue(time_warp_y_pos + 2 * node_spacing_y)\n                alpha_expression.knob(\"expr3\").setValue(\"r\")\n\n                deep_from_image = nuke.nodes.DeepFromImage()\n                deep_from_image.setInput(0, alpha_expression)\n                deep_from_image.knob(\"name\").setValue(self._deep_from_image + \"\{\}\".format(current_sample))\n                deep_from_image.knob(\"xpos\").setValue(x_pos)\n                deep_from_image.knob(\"ypos\").setValue(time_warp_y_pos + 3 * node_spacing_y)\n                deep_from_image.knob(\"premult\").setValue(True)\n\n                deep_merge = nuke.toNode(self._deep_merge)\n                deep_merge.setInput(current_sample, deep_from_image)\n\n            even = not even\n\n    def _remove_deep_samples(self, samples_to_remove, current_deep_samples):\n        even = current_deep_samples % 2 == 1\n\n        for sample in range(current_deep_samples - 1, current_deep_samples - samples_to_remove - 1, -1):\n            if even:\n                time_warp = nuke.toNode(self._time_warp + \"\{\}\".format(sample))\n                time_warp.setInput(0, None)\n                nuke.delete(time_warp)\n\n            expression = nuke.toNode(self._expression + \"\{\}\".format(sample))\n            alpha_expression = nuke.toNode(self._alpha_expression + \"\{\}\".format(sample))\n            deep_from_image = nuke.toNode(self._deep_from_image + \"\{\}\".format(sample))\n\n            nuke.delete(expression)\n            nuke.delete(alpha_expression)\n            nuke.delete(deep_from_image)\n\n            even = not even\n\n    def update_deep_nodes(self):\n        with self._node:\n            with nuke.toNode(self._deep_blender):\n                current_deep_samples = len(nuke.allNodes(filter=\"DeepFromImage\"))\n                samples_per_ray = self._node.knob(self._samples_per_ray).value()\n                deep_samples_to_add = int(samples_per_ray - current_deep_samples)\n\n                if deep_samples_to_add > 0:\n                    self._add_deep_samples(deep_samples_to_add, current_deep_samples)\n                elif deep_samples_to_add < 0 and samples_per_ray > 0:\n                    self._remove_deep_samples(abs(deep_samples_to_add), current_deep_samples)\n\n    @_knob_changed_callbacks.register(\"samples_per_ray\")\n    def _samples_per_ray_changed(self):\n        if self._node.knob(self._holdout_mode).getValue() == 2 or self._node.knob(self._output_deep).value():\n            self.update_deep_nodes()\n\n    @_knob_changed_callbacks.register(\"holdout_mode\")\n    def _holdout_mode_changed(self):\n        with self._node:\n            with nuke.toNode(self._deep_blender):\n                if self._knob.getValue() < 2 and not self._node.knob(self._output_deep).value():\n                    current_deep_samples = len(nuke.allNodes(filter=\"DeepFromImage\"))\n                    self._remove_deep_samples(current_deep_samples - 1, current_deep_samples)\n                else:\n                    self.update_deep_nodes()\n\n    @_knob_changed_callbacks.register(\"output_deep\")\n    def _output_deep_changed(self):\n        with self._node:\n            with nuke.toNode(self._deep_blender):\n                if self._knob.value():\n                    self.update_deep_nodes()\n                elif self._node.knob(self._holdout_mode).getValue() < 2:\n                    current_deep_samples = len(nuke.allNodes(filter=\"DeepFromImage\"))\n                    self._remove_deep_samples(current_deep_samples - 1, current_deep_samples)\n\n\nBlinkFogKnobManager().handle_knob_changed()\n\n"
 tile_color 0x3b004cff
 addUserKnob {20 User l BlinkFog3D}
 addUserKnob {26 sampling_settings l "<b>sampling settings"}
 addUserKnob {3 samples_per_ray l "samples per ray" t "This is the most important sampling setting. Increasing this will decrease the distance between samples, reducing noise.\n\nThe number of noise samples to compute per ray. Increase this to reduce flickering/improve quality, though it will run slower with a higher value."}
 samples_per_ray 50
 addUserKnob {3 rays_per_pixel l "rays per pixel" t "The number of rays per pixel to sample noise on. This enables antialiasing as well as cleaning up the noise from sampling depth of field.\n\nNOTE: Increasing this by 1 adds an ADDITIONAL samples_per_ray to the total samples, use with caution, or just leave this at 1"}
 rays_per_pixel 1
 addUserKnob {7 density t "A multiplier that increases fog density." R 0 10}
 density 0.5
 addUserKnob {20 time_blur l "Motion Blur" n 1}
 time_blur 0
 addUserKnob {6 enable_motion_blur l enable t "Enable the motion blur" +STARTLINE}
 addUserKnob {41 divisions T TimeBlur1.divisions}
 addUserKnob {41 shutter T TimeBlur1.shutter}
 addUserKnob {41 shutteroffset l "shutter offset" T TimeBlur1.shutteroffset}
 addUserKnob {41 shuttercustomoffset l "" -STARTLINE T TimeBlur1.shuttercustomoffset}
 addUserKnob {20 endGroup_1 n -1}
 addUserKnob {6 depth_of_field l "depth of field" t "Enable depth of field. This will be determined by the focal distance and fstop of the input camera. Increase the rays per pixel to clean up the noise when using this." +STARTLINE}
 addUserKnob {6 latlong t "Render a latlong." -STARTLINE}
 addUserKnob {26 depth_settings l "<b>depth settings"}
 addUserKnob {20 depth_ramp_1 l "Depth Ramp" n 1}
 addUserKnob {41 range l "depth ramp" t "The fog will only start being sampled at the depth specified in the first value, it will be scaled up to full density at the second value, maintain that density until the depth of the third value, and then ramp back down to the depth of the final value." T Keyer1.range}
 addUserKnob {20 endGroup n -1}
 addUserKnob {26 noise_settings l "<b>noise settings"}
 addUserKnob {7 size t "The size of the noise." R 1 300}
 size 5
 addUserKnob {4 type t "The noise type." M {turbulence fBm "" ""}}
 type fBm
 addUserKnob {13 translation t "Translate the noise by this amount."}
 addUserKnob {3 octaves t "The number of different frequencies to use."}
 octaves 8
 addUserKnob {7 lacunarity t "The per octave frequency multiplier." R 1 10}
 lacunarity 2
 addUserKnob {7 gain t "The per octave amplitude multiplier."}
 gain 0.6
 addUserKnob {7 gamma t "The result will be raised to 1 over this power."}
 gamma 0.4
 addUserKnob {26 spacer_0 l "" +STARTLINE T " "}
 addUserKnob {19 low_frequency_scale l "low freq scale" t "Scale the low frequencies by this amount separately from the high frequencies."}
 low_frequency_scale {1 1 1 1}
 addUserKnob {19 high_frequency_scale l "high freq scale" t "Scale the high frequencies by this amount separately from the low frequencies."}
 high_frequency_scale {1 1 1 1}
 addUserKnob {26 spacer l "" +STARTLINE T " "}
 addUserKnob {19 low_frequency_translation l "low freq translation" t "Translate the low frequencies by this amount separately from the high frequencies."}
 low_frequency_translation {0 0 0 0}
 addUserKnob {19 high_frequency_translation l "high freq translation" t "Translate the high frequencies by this amount separately from the low frequencies."}
 high_frequency_translation {0 0 0 0}
 addUserKnob {26 spacer_ l "" +STARTLINE T " "}
 addUserKnob {19 low_frequency_evolve l "low freq evolve" t "Evolve the low frequency over time."}
 low_frequency_evolve {0 0 0 0}
 addUserKnob {19 high_frequency_evolve l "high freq evolve" t "Evolve the high frequency over time."}
 high_frequency_evolve {0 0 0 0}
 addUserKnob {26 spacer_2 l "" +STARTLINE T " "}
 addUserKnob {26 holdout_settings l "<b>holdout settings"}
 addUserKnob {4 holdout_mode l "holdout mode" M {depth "deep (proxy)" "deep (full)"}}
 addUserKnob {26 ""}
 addUserKnob {41 from0 l "depth channel" T Copy1.from0}
 addUserKnob {6 invert_depth l "invert depth" t "Check this box to do 1/z, otherwise assumes true depth." -STARTLINE}
 addUserKnob {6 output_deep l "output deep (slow)" t "Output deep data, this will be slow." +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {41 format T format_.format}
 addUserKnob {3 overscan}
 addUserKnob {26 div0 l "" +STARTLINE}
 addUserKnob {26 info l "" +STARTLINE T "v1.3.0 - (c) Owen Bulka & Riley Gray - 2024"}
}
 Keyer {
  inputs 0
  operation "luminance key"
  range {2 4 12 15}
  name Keyer1
  xpos 1982
  ypos 784
 }
 Constant {
  inputs 0
  channels {rgba.red rgba.green rgba.blue -rgba.alpha}
  name format_
  xpos 1756
  ypos 678
 }
 Crop {
  box {{-parent.overscan} {-parent.overscan} {"width + parent.overscan"} {"height + parent.overscan"}}
  crop false
  name Crop4
  xpos 1756
  ypos 757
 }
 Noise {
  output {rgba.red -rgba.green -rgba.blue -rgba.alpha}
  cliptype bbox
  size 1
  zoffset 100
  nyquist false
  gain 0.95
  gamma 1
  center {512 389}
  name Noise5
  xpos 1756
  ypos 868
 }
 Noise {
  output {-rgba.red rgba.green -rgba.blue -rgba.alpha}
  cliptype bbox
  size 1
  zoffset 10
  nyquist {{parent.Noise5.nyquist}}
  gain {{parent.Noise5.gain}}
  gamma {{parent.Noise5.gamma}}
  center {512 389}
  name Noise6
  xpos 1756
  ypos 897
 }
 Noise {
  output {-rgba.red -rgba.green rgba.blue -rgba.alpha}
  cliptype bbox
  size 1
  zoffset 1000
  nyquist {{parent.Noise5.nyquist}}
  gain {{parent.Noise5.gain}}
  gamma {{parent.Noise5.gamma}}
  center {512 389}
  name Noise7
  xpos 1756
  ypos 926
 }
 Noise {
  output {-rgba.red -rgba.green -rgba.blue rgba.alpha}
  cliptype bbox
  size 1
  zoffset -100
  nyquist {{parent.Noise5.nyquist}}
  gain {{parent.Noise5.gain}}
  gamma {{parent.Noise5.gamma}}
  center {512 389}
  name Noise8
  xpos 1756
  ypos 955
 }
 Multiply {
  value 100
  name Multiply1
  xpos 1756
  ypos 993
 }
 Dot {
  name Dot2
  xpos 1790
  ypos 1114
 }
set N9b36360 [stack 0]
 Dot {
  name Dot3
  xpos 1925
  ypos 1114
 }
set N9c66ed0 [stack 0]
 Dot {
  name Dot11
  xpos 2114
  ypos 1114
 }
 BlinkScript {
  kernelSourceFile /home/ob1/software/nuke/dev/fog/src/blink/kernels/blink_fog_single_sample.cpp
  recompileCount 139
  ProgramGroup 1
  KernelDescription "2 \"FogKernel\" iterate pixelWise 6c3484bd1b271bda5d57b07285ece1ca01bf37c277a9c92f1b616301b6b4a7e7 2 \"seeds\" Read Point \"dst\" Write Point 27 \"Focal Length\" Float 1 AABIQg== \"Horizontal Aperture\" Float 1 ppvEQQ== \"Near Plane\" Float 1 zczMPQ== \"Far Plane\" Float 1 AEAcRg== \"Camera World Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"Focal Distance\" Float 1 AACAQA== \"fstop\" Float 1 AACAQQ== \"Enable Depth Of Field\" Bool 1 AQ== \"Output LatLong\" Bool 1 AA== \"Screen Width\" Float 1 AABwRQ== \"Screen Height\" Float 1 AAAHRQ== \"Individual Sample\" Float 1 AAAAAA== \"Density\" Float 1 AACAPw== \"Samples Per Ray\" Int 1 BQAAAA== \"Sample Depth Ramp\" Float 4 AACgQAAAIEEAAHBBAACgQQ== \"Do Second Sample\" Bool 1 AA== \"Size\" Float 1 AACgQQ== \"Noise Type\" Int 1 AAAAAA== \"Translation\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"Octaves\" Float 1 AAAAQQ== \"Lacunarity\" Float 1 AABAQA== \"Gain\" Float 1 AAAAPw== \"Gamma\" Float 1 AAAAPw== \"Low Frequency Scale\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"High Frequency Scale\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"Low Frequency Translation\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"High Frequency Translation\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== 27 \"_focalLength\" 1 1 \"_horizontalAperture\" 1 1 \"_nearPlane\" 1 1 \"_farPlane\" 1 1 \"_cameraWorldMatrix\" 16 1 \"_focalDistance\" 1 1 \"_fStop\" 1 1 \"_depthOfFieldEnabled\" 1 1 \"_latLong\" 1 1 \"_formatWidth\" 1 1 \"_formatHeight\" 1 1 \"_individualSample\" 1 1 \"_density\" 1 1 \"_samplesPerRay\" 1 1 \"_depthRamp\" 4 1 \"_secondSample\" 1 1 \"_size\" 1 1 \"_noiseType\" 1 1 \"_translation\" 3 1 \"_octaves\" 1 1 \"_lacunarity\" 1 1 \"_gain\" 1 1 \"_gamma\" 1 1 \"_lowFrequencyScale\" 4 1 \"_highFrequencyScale\" 4 1 \"_lowFrequencyTranslation\" 4 1 \"_highFrequencyTranslation\" 4 1 5 \"__inverseCameraProjectionMatrix\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"__aperture\" Float 1 1 AAAAAA== \"__simplex\" Int 1 256 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"__perm\" Int 1 512 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"__grad4\" Int 1 128 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
  kernelSource "// Copyright 2024 by Owen Bulka.\n// All rights reserved.\n// This file is released under the \"MIT License Agreement\".\n// Please see the LICENSE.md file that should have been included as part\n// of this package.\n\n\n//\n// Math operations\n//\n\n\n/**\n * Compute the fractional portion of the value. Ex. 3.5 returns 0.5\n *\n * @arg value: The value to get the fractional portion of.\n *\n * @returns: The fractional portion of the value.\n */\ninline float fract(const float value)\n\{\n    return value - floor(value);\n\}\n\n\n/**\n * Multiply a 4d vector by a 4x4 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline void matmul(const float4x4 &m, const float4 &v, float4 &out)\n\{\n    for (int i=0; i < 4; i++)\n    \{\n        out\[i] = 0;\n\n        for (int j=0; j < 4; j++)\n        \{\n            out\[i] += m\[i]\[j] * v\[j];\n        \}\n    \}\n\}\n\n\n/**\n * Multiply a 4d vector by a 4x4 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline float4 matmul(const float4x4 &m, const float4 &v)\n\{\n    float4 out;\n    for (int i=0; i < 4; i++)\n    \{\n        out\[i] = 0;\n\n        for (int j=0; j < 4; j++)\n        \{\n            out\[i] += m\[i]\[j] * v\[j];\n        \}\n    \}\n\n    return out;\n\}\n\n\n/**\n * Multiply a 3d vector by a 3x3 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline float3 matmul(const float3x3 &m, const float3 &v)\n\{\n    return float3(\n        m\[0]\[0] * v.x + m\[0]\[1] * v.y + m\[0]\[2] * v.z,\n        m\[1]\[0] * v.x + m\[1]\[1] * v.y + m\[1]\[2] * v.z,\n        m\[2]\[0] * v.x + m\[2]\[1] * v.y + m\[2]\[2] * v.z\n    );\n\}\n\n\n/**\n * Convert the uv position in a latlong image to angles.\n *\n * @arg uvPosition: The UV position.\n *\n * @returns: The equivalent angles in radians.\n */\ninline float2 uvPositionToAngles(const float2 &uvPosition)\n\{\n    return float2(\n        (uvPosition.x + 1.0f) * PI,\n        (1.0f - uvPosition.y) * PI / 2.0f\n    );\n\}\n\n\n/**\n * Convert location of a pixel in an image into UV.\n *\n * @arg pixelLocation: The x, and y positions of the pixel.\n * @arg format: The image width, and height.\n *\n * @returns: The UV position.\n */\ninline float2 pixelsToUV(const float2 &pixelLocation, const float2 &format)\n\{\n    return float2(\n        2.0f * pixelLocation.x / format.x - 1.0f,\n        2.0f * pixelLocation.y / format.y - 1.0f\n    );\n\}\n\n\n/**\n * Convert a spherical unit vector (unit radius) to cartesion.\n *\n * @arg angles: The spherical angles in radians.\n *\n * @returns: The equivalent cartesion vector.\n */\ninline float3 sphericalUnitVectorToCartesion(const float2 &angles)\n\{\n    const float sinPhi = sin(angles.y);\n    return float3(\n        cos(angles.x) * sinPhi,\n        cos(angles.y),\n        sin(angles.x) * sinPhi\n    );\n\}\n\n\n/**\n * Get the position component of a world matrix.\n *\n * @arg worldMatrix: The world matrix.\n * @arg position: The location to store the position.\n */\ninline void positionFromWorldMatrix(const float4x4 &worldMatrix, float3 &position)\n\{\n    position = float3(\n        worldMatrix\[0]\[3],\n        worldMatrix\[1]\[3],\n        worldMatrix\[2]\[3]\n    );\n\}\n\n\n/**\n * Get the rotation component of a world matrix.\n *\n * @arg worldMatrix: The world matrix.\n * @arg rotation: The location to store the rotation.\n */\ninline void rotationFromWorldMatrix(const float4x4 &worldMatrix, float3x3 &rotationMatrix)\n\{\n    rotationMatrix\[0]\[0] = worldMatrix\[0]\[0];\n    rotationMatrix\[0]\[1] = worldMatrix\[0]\[1];\n    rotationMatrix\[0]\[2] = worldMatrix\[0]\[2];\n    rotationMatrix\[1]\[0] = worldMatrix\[1]\[0];\n    rotationMatrix\[1]\[1] = worldMatrix\[1]\[1];\n    rotationMatrix\[1]\[2] = worldMatrix\[1]\[2];\n    rotationMatrix\[2]\[0] = worldMatrix\[2]\[0];\n    rotationMatrix\[2]\[1] = worldMatrix\[2]\[1];\n    rotationMatrix\[2]\[2] = worldMatrix\[2]\[2];\n\}\n\n\n//\n// Randomization functions\n//\n\n\n// Some random constants on the interval \[1, 2]\n#define RAND_CONST_0 1.571411510193971f\n\n\n/**\n * Get a random value on the interval \[0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval \[0, 1].\n */\ninline float random(const float seed)\n\{\n    return fract(sin(73.1f * seed + 91.3458f) * 47453.5453f);\n\}\n\n\n/**\n * Get a random value on the interval \[0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval \[0, 1].\n */\ninline float2 random(const float2 &seed)\n\{\n    return float2(\n        fract(sin(13.157f * seed.x + 71.743f) * 7513.471f),\n        fract(sin(97.519f * seed.y + 113.591f) * 47453.5453f)\n    );\n\}\n\n\n/**\n * Create a random point that lies within the unit circle.\n *\n * @arg seed: The random seed.\n *\n * @returns: A random point, (radius, angle) in the unit circle.\n */\ninline float2 uniformPointInUnitCircle(const float2 &seed)\n\{\n    return float2(sqrt(random(seed.x)), 2.0f * PI * random(seed.y));\n\}\n\n\n/**\n * Sum the elements of a vector.\n *\n * @arg vector: The vector to sum the elements of.\n *\n * @returns: The sum of the vector elements.\n */\ninline float elementSum(const float4 &vector) \{\n    return vector.x + vector.y + vector.z + vector.w;\n\}\n\n\n#define FBM_NOISE 1\n\n\n//\n// Camera Utilities\n//\n\n\n/**\n * Compute the field of view from focal length.\n *\n * @arg focalLength: The focal length.\n *\n * @returns: The equivalent field of view.\n */\ninline float fieldOfView(const float focalLength)\n\{\n    return 2 * atan(1 / focalLength);\n\}\n\n\n/**\n * Compute the aspect ratio from image format.\n *\n * @arg height_: The height of the image.\n * @arg width_: The width of the image.\n *\n * @returns: The aspect ratio.\n */\ninline float aspectRatio(const float height_, const float width_)\n\{\n    return height_ / width_;\n\}\n\n\n/**\n *\n */\ninline float fStopToAperture(const float fStop, const float focalLength)\n\{\n    return focalLength / fStop / 1000.0f;\n\}\n\n\n/**\n * Create a projection matrix for a camera.\n *\n * @arg focalLength: The focal length of the camera.\n * @arg horizontalAperture: The horizontal aperture of the camera.\n * @arg aspect: The aspect ratio of the camera.\n * @arg nearPlane: The distance to the near plane of the camera.\n * @arg farPlane: The distance to the far plane of the camera.\n *\n * @returns: The camera's projection matrix.\n */\nfloat4x4 projectionMatrix(\n        const float focalLength,\n        const float horizontalAperture,\n        const float aspect,\n        const float nearPlane,\n        const float farPlane)\n\{\n    float farMinusNear = farPlane - nearPlane;\n    return float4x4(\n        2 * focalLength / horizontalAperture, 0, 0, 0,\n        0, 2 * focalLength / horizontalAperture / aspect, 0, 0,\n        0, 0, -(farPlane + nearPlane) / farMinusNear, -2 * (farPlane * nearPlane) / farMinusNear,\n        0, 0, -1, 0\n    );\n\}\n\n\n/**\n * Generate a ray out of a camera.\n *\n * @arg cameraWorldMatrix: The camera matrix.\n * @arg inverseProjectionMatrix: The inverse of the projection matrix.\n * @arg uvPosition: The UV position in the resulting image.\n * @arg rayOrigin: Will store the origin of the ray.\n * @arg rayDirection: Will store the direction of the ray.\n */\nvoid createCameraRay(\n        const float4x4 &cameraWorldMatrix,\n        const float4x4 &inverseProjectionMatrix,\n        const float2 &uvPosition,\n        float3 &rayOrigin,\n        float3 &rayDirection)\n\{\n    positionFromWorldMatrix(cameraWorldMatrix, rayOrigin);\n    float4 direction = matmul(\n        inverseProjectionMatrix,\n        float4(uvPosition.x, uvPosition.y, 0, 1)\n    );\n    matmul(\n        cameraWorldMatrix,\n        float4(direction.x, direction.y, direction.z, 0),\n        direction\n    );\n    rayDirection = normalize(float3(direction.x, direction.y, direction.z));\n\}\n\n\n/**\n * Generate a ray out of a camera.\n *\n * @arg cameraWorldMatrix: The camera matrix.\n * @arg inverseProjectionMatrix: The inverse of the projection matrix.\n * @arg uvPosition: The UV position in the resulting image.\n * @arg rayOrigin: Will store the origin of the ray.\n * @arg rayDirection: Will store the direction of the ray.\n */\nvoid createCameraRay(\n        const float4x4 &cameraWorldMatrix,\n        const float4x4 &inverseProjectionMatrix,\n        const float2 &uvPosition,\n        const float aperture,\n        const float focalDistance,\n        const float2 &seed,\n        float3 &rayOrigin,\n        float3 &rayDirection)\n\{\n    createCameraRay(\n        cameraWorldMatrix,\n        inverseProjectionMatrix,\n        uvPosition,\n        rayOrigin,\n        rayDirection\n    );\n\n    const float4 cameraForward4 = matmul(\n        cameraWorldMatrix,\n        float4(0, 0, -1, 0)\n    );\n    const float3 cameraForward = float3(\n        cameraForward4.x,\n        cameraForward4.y,\n        cameraForward4.z\n    );\n    const float4 cameraRight4 = matmul(\n        cameraWorldMatrix,\n        float4(1, 0, 0, 0)\n    );\n    const float3 cameraRight = float3(\n        cameraRight4.x,\n        cameraRight4.y,\n        cameraRight4.z\n    );\n    const float4 cameraUp4 = matmul(\n        cameraWorldMatrix,\n        float4(0, 1, 0, 0)\n    );\n    const float3 cameraUp = float3(\n        cameraUp4.x,\n        cameraUp4.y,\n        cameraUp4.z\n    );\n\n    const float3 focalPlanePoint = rayOrigin + cameraForward * focalDistance;\n    const float3 focalPlaneNormal = -cameraForward;\n\n    const float focalPointDistance = (\n        (dot(focalPlaneNormal, focalPlanePoint) - dot(rayOrigin, focalPlaneNormal))\n        / dot(rayDirection, focalPlaneNormal)\n    );\n    const float3 focalPoint = rayOrigin + focalPointDistance * rayDirection;\n\n    const float2 pointInUnitCircle = uniformPointInUnitCircle(seed);\n    const float2 offset = pointInUnitCircle.x * aperture * float2(\n        cos(pointInUnitCircle.y),\n        sin(pointInUnitCircle.y)\n    );\n\n    rayOrigin += cameraRight * offset.x + cameraUp * offset.y;\n    rayDirection = normalize(focalPoint - rayOrigin);\n\}\n\n\n/**\n * Generate a LatLong ray out of a camera.\n *\n * @arg cameraWorldMatrix: The camera matrix.\n * @arg uvPosition: The UV position in the resulting image.\n * @arg rayOrigin: Will store the origin of the ray.\n * @arg rayDirection: Will store the direction of the ray.\n */\nvoid createLatLongCameraRay(\n        const float4x4 &cameraWorldMatrix,\n        const float2 &uvPosition,\n        float3 &rayOrigin,\n        float3 &rayDirection)\n\{\n    positionFromWorldMatrix(cameraWorldMatrix, rayOrigin);\n    rayDirection = sphericalUnitVectorToCartesion(uvPositionToAngles(uvPosition));\n\n    float3x3 cameraRotation;\n    rotationFromWorldMatrix(cameraWorldMatrix, cameraRotation);\n    rayDirection = matmul(cameraRotation, rayDirection);\n\}\n\n\n\nkernel FogKernel : ImageComputationKernel<ePixelWise>\n\{\n    // the input which specifies the format, process is called once per pixel\n    // in this image, which also provides random seeds\n    Image<eRead, eAccessPoint, eEdgeNone> seeds;\n\n    // the output image\n    Image<eWrite> dst;\n\n\n    param:\n        // These parameters are made available to the user.\n\n        // Camera params\n        float _focalLength;\n        float _horizontalAperture;\n        float _nearPlane;\n        float _farPlane;\n        float4x4 _cameraWorldMatrix;\n        float _focalDistance;\n        float _fStop;\n        bool _depthOfFieldEnabled;\n        bool _latLong;\n\n        // Image params\n        float _formatWidth;\n        float _formatHeight;\n        float _individualSample;\n        float _density;\n        int _samplesPerRay;\n        float4 _depthRamp;\n        bool _secondSample;\n\n        // Noise Parameters\n        float _size;\n        int _noiseType;\n        float3 _translation;\n        float _octaves;\n        float _lacunarity;\n        float _gain;\n        float _gamma;\n        float4 _lowFrequencyScale;\n        float4 _highFrequencyScale;\n        float4 _lowFrequencyTranslation;\n        float4 _highFrequencyTranslation;\n\n    local:\n        // These local variables are not exposed to the user.\n        float4x4 __inverseCameraProjectionMatrix;\n        float __aperture;\n\n        int __simplex\[64]\[4];\n        int __perm\[512];\n        int __grad4\[32]\[4];\n\n    /**\n     * Give the parameters labels and default values.\n     */\n    void define()\n    \{\n        // Camera params\n        defineParam(_focalLength, \"Focal Length\", 50.0f);\n        defineParam(_horizontalAperture, \"Horizontal Aperture\", 24.576f);\n        defineParam(_nearPlane, \"Near Plane\", 0.1f);\n        defineParam(_farPlane, \"Far Plane\", 10000.0f);\n        defineParam(\n            _cameraWorldMatrix,\n            \"Camera World Matrix\",\n            float4x4(\n                1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1\n            )\n        );\n        defineParam(_focalDistance, \"Focal Distance\", 4.0f);\n        defineParam(_fStop, \"fstop\", 16.0f);\n        defineParam(_depthOfFieldEnabled, \"Enable Depth Of Field\", true);\n        defineParam(_latLong, \"Output LatLong\", false);\n\n        // Image params\n        defineParam(_formatHeight, \"Screen Height\", 2160.0f);\n        defineParam(_formatWidth, \"Screen Width\", 3840.0f);\n        defineParam(_individualSample, \"Individual Sample\", 0.0f);\n        defineParam(_density, \"Density\", 1.0f);\n        defineParam(_samplesPerRay, \"Samples Per Ray\", 5);\n        defineParam(_depthRamp, \"Sample Depth Ramp\", float4(5.0f, 10.0f, 15.0f, 20.0f));\n        defineParam(_secondSample, \"Do Second Sample\", false);\n\n        // Noise Parameters\n        defineParam(_size, \"Size\", 20.0f);\n        defineParam(_noiseType, \"Noise Type\", 0);\n        defineParam(_translation, \"Translation\", float3(0.0f, 0.0f, 0.0f));\n        defineParam(_octaves, \"Octaves\", 8.0f);\n        defineParam(_lacunarity, \"Lacunarity\", 3.0f);\n        defineParam(_gain, \"Gain\", 0.5f);\n        defineParam(_gamma, \"Gamma\", 0.5f);\n        defineParam(_lowFrequencyScale, \"Low Frequency Scale\", float4(0.0f, 0.0f, 0.0f, 0.0f));\n        defineParam(_highFrequencyScale, \"High Frequency Scale\", float4(0.0f, 0.0f, 0.0f, 0.0f));\n        defineParam(_lowFrequencyTranslation, \"Low Frequency Translation\", float4(0.0f, 0.0f, 0.0f, 0.0f));\n        defineParam(_highFrequencyTranslation, \"High Frequency Translation\", float4(0.0f, 0.0f, 0.0f, 0.0f));\n    \}\n\n\n    /**\n     * Initialize the local variables.\n     */\n    void init()\n    \{\n        const float aspect = aspectRatio(_formatHeight, _formatWidth);\n        float4x4 cameraProjectionMatrix = projectionMatrix(\n            _focalLength,\n            _horizontalAperture,\n            aspect,\n            _nearPlane,\n            _farPlane\n        );\n        __inverseCameraProjectionMatrix = cameraProjectionMatrix.invert();\n\n        __aperture = fStopToAperture(_fStop, _focalLength);\n\n        const int simplexInit\[64]\[4] = \{\n            \{0, 1, 2, 3\}, \{0, 1, 3, 2\}, \{0, 0, 0, 0\}, \{0, 2, 3, 1\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{1, 2, 3, 0\},\n            \{0, 2, 1, 3\}, \{0, 0, 0, 0\}, \{0, 3, 1, 2\}, \{0, 3, 2, 1\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{1, 3, 2, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{1, 2, 0, 3\}, \{0, 0, 0, 0\}, \{1, 3, 0, 2\}, \{0, 0, 0, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{2, 3, 0, 1\}, \{2, 3, 1, 0\},\n            \{1, 0, 2, 3\}, \{1, 0, 3, 2\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{0, 0, 0, 0\}, \{2, 0, 3, 1\}, \{0, 0, 0, 0\}, \{2, 1, 3, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{2, 0, 1, 3\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{3, 0, 1, 2\}, \{3, 0, 2, 1\}, \{0, 0, 0, 0\}, \{3, 1, 2, 0\},\n            \{2, 1, 0, 3\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{3, 1, 0, 2\}, \{0, 0, 0, 0\}, \{3, 2, 0, 1\}, \{3, 2, 1, 0\}\n        \};\n\n        for (int i = 0; i < 64; i++)\n        \{\n            for (int j = 0; j < 4; j++)\n            \{\n                __simplex\[i]\[j] = simplexInit\[i]\[j];\n            \}\n        \}\n\n        const int permInit\[256] = \{\n            151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233,\n            7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23,\n            190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219,\n            203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174,\n            20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48,\n            27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133,\n            230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65,\n            25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18,\n            169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198,\n            173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147,\n            118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17,\n            182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44,\n            154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22,\n            39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112,\n            104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12,\n            191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49,\n            192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121,\n            50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29,\n            24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180\n        \};\n\n        for (int i = 0; i < 512; i++)\n        \{\n            __perm\[i] = permInit\[i % 256];\n        \}\n\n        const int grad4Init\[32]\[4]= \{\n            \{0, 1, 1, 1\},  \{0, 1, 1, -1\},  \{0, 1, -1, 1\},  \{0, 1, -1, -1\},\n            \{0, -1, 1, 1\}, \{0, -1, 1, -1\}, \{0, -1, -1, 1\}, \{0, -1, -1, -1\},\n            \{1, 0, 1, 1\},  \{1, 0, 1, -1\},  \{1, 0, -1, 1\},  \{1, 0, -1, -1\},\n            \{-1, 0, 1, 1\}, \{-1, 0, 1, -1\}, \{-1, 0, -1, 1\}, \{-1, 0, -1, -1\},\n            \{1, 1, 0, 1\},  \{1, 1, 0, -1\},  \{1, -1, 0, 1\},  \{1, -1, 0, -1\},\n            \{-1, 1, 0, 1\}, \{-1, 1, 0, -1\}, \{-1, -1, 0, 1\}, \{-1, -1, 0, -1\},\n            \{1, 1, 1, 0\},  \{1, 1, -1, 0\},  \{1, -1, 1, 0\},  \{1, -1, -1, 0\},\n            \{-1, 1, 1, 0\}, \{-1, 1, -1, 0\}, \{-1, -1, 1, 0\}, \{-1, -1, -1, 0\}\n        \};\n\n        for (int i = 0; i < 32; i++)\n        \{\n            for (int j = 0; j < 4; j++)\n            \{\n                __grad4\[i]\[j] = grad4Init\[i]\[j];\n            \}\n        \}\n    \}\n\n    /**\n     * 4D Perlin simplex noise\n     *\n     * Copyright (c) 2007-2012 Eliot Eshelman\n     *\n     * This program is free software: you can redistribute it and/or modify\n     * it under the terms of the GNU General Public License as published by\n     * the Free Software Foundation, either version 3 of the License, or\n     * (at your option) any later version.\n     *\n     * This program is distributed in the hope that it will be useful,\n     * but WITHOUT ANY WARRANTY; without even the implied warranty of\n     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n     * GNU General Public License for more details.\n     *\n     * You should have received a copy of the GNU General Public License\n     * along with this program. If not, see <http://www.gnu.org/licenses/>.\n     *\n     * @arg seed: The seed for the noise.\n     * @arg simplex: The simplex LUT.\n     * @arg perm: The perm LUT.\n     * @arg grad4: The grad4 LUT.\n     *\n     * @returns: Noise value in the range \[-1, 1], value of 0 on all integer\n     *     coordinates.\n     */\n    inline float perlinSimplexNoise(\n            const float4 &seed\n    )\n    \{\n        const float G4 = 0.138196601f;\n        const float4 i = floor(seed + elementSum(seed) * 0.309016994f);\n        const float4 x0 = seed - i + elementSum(i) * G4;\n\n        const int c = (\n            ((x0.x > x0.y) << 5)\n            | ((x0.x > x0.z) << 4)\n            | ((x0.y > x0.z) << 3)\n            | ((x0.x > x0.w) << 2)\n            | ((x0.y > x0.w) << 1)\n            | (x0.z > x0.w)\n        );\n        const int4 i1 = int4(\n            __simplex\[c]\[0] >= 3,\n            __simplex\[c]\[1] >= 3,\n            __simplex\[c]\[2] >= 3,\n            __simplex\[c]\[3] >= 3\n        );\n        const int4 i2 = int4(\n            __simplex\[c]\[0] >= 2,\n            __simplex\[c]\[1] >= 2,\n            __simplex\[c]\[2] >= 2,\n            __simplex\[c]\[3] >= 2\n        );\n        const int4 i3 = int4(\n            __simplex\[c]\[0] >= 1,\n            __simplex\[c]\[1] >= 1,\n            __simplex\[c]\[2] >= 1,\n            __simplex\[c]\[3] >= 1\n        );\n\n        const float4 x1 = x0 - float4(i1.x, i1.y, i1.z, i1.w) + G4;\n        const float4 x2 = x0 - float4(i2.x, i2.y, i2.z, i2.w) + 2.0f * G4;\n        const float4 x3 = x0 - float4(i3.x, i3.y, i3.z, i3.w) + 3.0f * G4;\n        const float4 x4 = x0 - 1.0f + 4.0f * G4;\n\n        const int ii = (int) i.x & 255;\n        const int jj = (int) i.y & 255;\n        const int kk = (int) i.z & 255;\n        const int ll = (int) i.w & 255;\n\n        const int gi0 = __perm\[\n            ii + __perm\[jj + __perm\[kk + __perm\[ll]]]\n        ] % 32;\n        const int gi1 = __perm\[\n            ii + i1.x + __perm\[jj + i1.y + __perm\[kk + i1.z + __perm\[ll + i1.w]]]\n        ] % 32;\n        const int gi2 = __perm\[\n            ii + i2.x + __perm\[jj + i2.y + __perm\[kk + i2.z + __perm\[ll + i2.w]]]\n        ] % 32;\n        const int gi3 = __perm\[\n            ii + i3.x + __perm\[jj + i3.y + __perm\[kk + i3.z + __perm\[ll + i3.w]]]\n        ] % 32;\n        const int gi4 = __perm\[\n            ii + 1 + __perm\[jj + 1 + __perm\[kk + 1 + __perm\[ll + 1]]]\n        ] % 32;\n\n        float n0, n1, n2, n3, n4;\n        float t0 = 0.6f - dot(x0, x0);\n        if (t0 < 0)\n        \{\n            n0 = 0.0f;\n        \}\n        else\n        \{\n            t0 *= t0;\n            n0 = t0 * t0 * dot(\n                float4(__grad4\[gi0]\[0], __grad4\[gi0]\[1], __grad4\[gi0]\[2], __grad4\[gi0]\[3]),\n                x0\n            );\n        \}\n\n        float t1 = 0.6f - dot(x1, x1);\n        if (t1 < 0)\n        \{\n            n1 = 0.0f;\n        \}\n        else\n        \{\n            t1 *= t1;\n            n1 = t1 * t1 * dot(\n                float4(__grad4\[gi1]\[0], __grad4\[gi1]\[1], __grad4\[gi1]\[2], __grad4\[gi1]\[3]),\n                x1\n            );\n        \}\n\n        float t2 = 0.6f - dot(x2, x2);\n        if (t2 < 0)\n        \{\n            n2 = 0.0f;\n        \}\n        else\n        \{\n            t2 *= t2;\n            n2 = t2 * t2 * dot(\n                float4(__grad4\[gi2]\[0], __grad4\[gi2]\[1], __grad4\[gi2]\[2], __grad4\[gi2]\[3]),\n                x2\n            );\n        \}\n\n        float t3 = 0.6f - dot(x3, x3);\n        if (t3 < 0)\n        \{\n            n3 = 0.0f;\n        \}\n        else\n        \{\n            t3 *= t3;\n            n3 = t3 * t3 * dot(\n                float4(__grad4\[gi3]\[0], __grad4\[gi3]\[1], __grad4\[gi3]\[2], __grad4\[gi3]\[3]),\n                x3\n            );\n        \}\n\n        float t4 = 0.6f - dot(x4, x4);\n        if (t4 < 0)\n        \{\n            n4 = 0.0f;\n        \}\n        else \{\n            t4 *= t4;\n            n4 = t4 * t4 * dot(\n                float4(__grad4\[gi4]\[0], __grad4\[gi4]\[1], __grad4\[gi4]\[2], __grad4\[gi4]\[3]),\n                x4\n            );\n        \}\n\n        return 27.0f * (n0 + n1 + n2 + n3 + n4);\n    \}\n\n\n    //\n    // Use the perlin simplex noise\n    //\n\n\n    /**\n     * fBM noise.\n     *\n     * @arg position: The position to seed the noise.\n     *\n     * @returns: The noise value in the range \[-1, 1].\n     */\n    float fractalBrownianMotionNoise(const float4 &position)\n    \{\n        float output = 0.0f;\n        float frequency = _lacunarity;\n        float amplitude = 1.0f;\n        float denom = 0.0f;\n        float4 translation;\n        float4 scale;\n\n        for (int octave=0; octave < _octaves; octave++)\n        \{\n            const float octaveFraction = octave / _octaves;\n            scale = (\n                (_highFrequencyScale * octaveFraction)\n                + (_lowFrequencyScale * (1.0f - octaveFraction))\n            );       \n            translation = (\n                (_highFrequencyTranslation * octaveFraction)\n                + (_lowFrequencyTranslation * (1.0f - octaveFraction))\n            );\n\n            output += amplitude * perlinSimplexNoise(\n                (position * scale + translation) * frequency / _size\n            );\n\n            frequency *= _lacunarity;\n            denom += amplitude;\n            amplitude *= _gain;\n        \}\n\n        return pow(fabs(output / denom), 1.0f / _gamma);\n    \}\n\n\n    /**\n     * Turbulence noise.\n     *\n     * @arg position: The position to seed the noise.\n     *\n     * @returns: The noise value in the range \[0, 1].\n     */\n    float turbulenceNoise(const float4 &position)\n    \{\n        float output = 0.0f;\n        float frequency = _lacunarity;\n        float amplitude = 1.0f;\n        float denom = 0.0f;\n        float4 translation;\n        float4 scale;\n\n        for (int octave=0; octave < _octaves; octave++)\n        \{\n            const float octaveFraction = octave / _octaves;\n            scale = (\n                (_highFrequencyScale * octaveFraction)\n                + (_lowFrequencyScale * (1.0f - octaveFraction))\n            );       \n            translation = (\n                (_highFrequencyTranslation * octaveFraction)\n                + (_lowFrequencyTranslation * (1.0f - octaveFraction))\n            );\n\n            output += fabs(\n                amplitude * perlinSimplexNoise(\n                    (position * scale + translation) * frequency / _size\n                )\n            );\n\n            frequency *= _lacunarity;\n            denom += amplitude;\n            amplitude *= _gain;\n        \}\n\n        return pow(output / denom, 1.0f / _gamma);\n    \}\n\n\n    /**\n     * Create a ray out of the camera. It will be either a standard ray,\n     * a latlong ray, or a ray that will result in depth of field.\n     *\n     * @arg seed: The seed to use in randomization.\n     * @arg pixelLocation: The x, and y locations of the pixel.\n     * @arg rayOrigin: The location to store the origin of the new ray.\n     * @arg rayDirection: The location to store the direction of the new\n     *     ray.\n     */\n    void getCameraRay(\n            const float2 &seed,\n            const float2 &pixelLocation,\n            float3 &rayOrigin,\n            float3 &rayDirection)\n    \{\n        const float2 uvCoordinates = pixelsToUV(\n            pixelLocation + random(seed),\n            float2(_formatWidth, _formatHeight)\n        );\n        if (_latLong)\n        \{\n            createLatLongCameraRay(\n                _cameraWorldMatrix,\n                uvCoordinates,\n                rayOrigin,\n                rayDirection\n            );\n        \}\n        else if (_depthOfFieldEnabled)\n        \{\n            createCameraRay(\n                _cameraWorldMatrix,\n                __inverseCameraProjectionMatrix,\n                uvCoordinates,\n                __aperture,\n                _focalDistance,\n                seed,\n                rayOrigin,\n                rayDirection\n            );\n        \}\n        else\n        \{\n            createCameraRay(\n                _cameraWorldMatrix,\n                __inverseCameraProjectionMatrix,\n                uvCoordinates,\n                rayOrigin,\n                rayDirection\n            );\n        \}\n    \}\n\n\n    /**\n     * Compute a noise value.\n     *\n     * @arg pos: The x, and y location we are currently processing.\n     */\n    void process(int2 pos)\n    \{\n        float2 pixelLocation = float2(pos.x, pos.y);\n        SampleType(seeds) seedPixel = seeds();\n        float2 seed = float2(seedPixel.x, seedPixel.y) + RAND_CONST_0 * pixelLocation;\n\n        float4 resultPixel = float4(0.0f);\n\n        const float sampleStep = (_depthRamp.w - _depthRamp.x) / (float) _samplesPerRay;\n\n        // Generate a ray from the camera\n        float3 rayOrigin;\n        float3 rayDirection;\n        getCameraRay(\n            seed,\n            pixelLocation,\n            rayOrigin,\n            rayDirection\n        );\n\n        // Set the depth to the start of the depth ramp and add a random offset\n        // to eliminate layer lines\n        float depth = _depthRamp.x - random(seed.x + seed.y + _individualSample) * sampleStep;\n        rayOrigin += depth * rayDirection + _translation;\n\n        depth += (1.0f + _individualSample) * sampleStep;\n        rayOrigin += (1.0f + _individualSample) * rayDirection * sampleStep;\n        for (int sample=0; sample <= (int) _secondSample; sample++)\n        \{\n            // Get the noise value based on which type of noise we are using\n            const float4 samplePosition4d = float4(\n                rayOrigin.x,\n                rayOrigin.y,\n                rayOrigin.z,\n                0.0f\n            );\n\n            // Apply the scaling specified by the depth ramp\n            float ramp;\n            if (depth < _depthRamp.y)\n            \{\n                ramp = (depth - _depthRamp.y) / (_depthRamp.y - _depthRamp.x) + 1.0f;\n            \}\n            else if (depth >= _depthRamp.y && depth <= _depthRamp.z)\n            \{\n                ramp = 1.0f;\n            \}\n            else\n            \{\n                ramp = (_depthRamp.w - depth) / (_depthRamp.w - _depthRamp.z);\n            \}\n\n            // Compute the noise value at this position\n            float noiseValue = _density * ramp;\n            if (_noiseType == FBM_NOISE)\n            \{\n                noiseValue *= fractalBrownianMotionNoise(samplePosition4d);\n            \}\n            else\n            \{\n                noiseValue *= turbulenceNoise(samplePosition4d);\n            \}\n\n            resultPixel\[sample * 2] = noiseValue;\n            resultPixel\[sample * 2 + 1] = depth;\n\n            depth += sampleStep;\n            rayOrigin += rayDirection * sampleStep;\n        \}\n\n        dst() = resultPixel;\n    \}\n\};\n"
  rebuild ""
  "FogKernel_Focal Length" {{parent.DummyCam.focal(floor(frame))}}
  "FogKernel_Horizontal Aperture" {{parent.DummyCam.haperture(floor(frame))}}
  "FogKernel_Near Plane" {{parent.DummyCam.near(floor(frame))}}
  "FogKernel_Far Plane" {{parent.DummyCam.far(floor(frame))}}
  "group_FogKernel_Camera World Matrix" 1
  "FogKernel_Camera World Matrix" {
      {{parent.DummyCam.world_matrix(floor(frame))} {parent.DummyCam.world_matrix(floor(frame))} {parent.DummyCam.world_matrix(floor(frame))} {parent.DummyCam.world_matrix(floor(frame))}}
      {{parent.DummyCam.world_matrix(floor(frame))} {parent.DummyCam.world_matrix(floor(frame))} {parent.DummyCam.world_matrix(floor(frame))} {parent.DummyCam.world_matrix(floor(frame))}}
      {{parent.DummyCam.world_matrix(floor(frame))} {parent.DummyCam.world_matrix(floor(frame))} {parent.DummyCam.world_matrix(floor(frame))} {parent.DummyCam.world_matrix(floor(frame))}}
      {{parent.DummyCam.world_matrix(floor(frame))} {parent.DummyCam.world_matrix(floor(frame))} {parent.DummyCam.world_matrix(floor(frame))} {parent.DummyCam.world_matrix(floor(frame))}}
    }
  "FogKernel_Focal Distance" {{parent.DummyCam.focal_point(floor(frame))}}
  FogKernel_fstop {{parent.DummyCam.fstop(floor(frame))}}
  "FogKernel_Enable Depth Of Field" {{parent.depth_of_field}}
  "FogKernel_Output LatLong" {{parent.latlong}}
  "FogKernel_Screen Width" {{"proxy? input0.width*proxy_scale: input0.width"}}
  "FogKernel_Screen Height" {{"proxy? input0.height * proxy_scale : input0.height"}}
  "FogKernel_Individual Sample" {{"frame % 1 * parent.samples_per_ray"}}
  FogKernel_Density {{"parent.density * 50 / parent.samples_per_ray"}}
  "FogKernel_Samples Per Ray" {{parent.samples_per_ray}}
  "FogKernel_Sample Depth Ramp" {{parent.Keyer1.range.A} {parent.Keyer1.range.B} {parent.Keyer1.range.C} {parent.Keyer1.range.D}}
  "FogKernel_Do Second Sample" {{"parent.samples_per_ray % 2 == 0 || frame % 1 * parent.samples_per_ray < parent.samples_per_ray - 1"}}
  FogKernel_Size {{parent.size}}
  "FogKernel_Noise Type" {{parent.type}}
  FogKernel_Translation {{-parent.translation-8} {-parent.translation} {-parent.translation}}
  FogKernel_Octaves {{parent.octaves}}
  FogKernel_Lacunarity {{parent.lacunarity}}
  FogKernel_Gain {{parent.gain}}
  FogKernel_Gamma {{parent.gamma}}
  "FogKernel_Low Frequency Scale" {{parent.low_frequency_scale} {parent.low_frequency_scale} {parent.low_frequency_scale} {parent.low_frequency_scale}}
  "FogKernel_High Frequency Scale" {{parent.high_frequency_scale} {parent.high_frequency_scale} {parent.high_frequency_scale} {parent.high_frequency_scale}}
  "FogKernel_Low Frequency Translation" {{"parent.low_frequency_translation + parent.low_frequency_evolve * frame / 100"} {"parent.low_frequency_translation + parent.low_frequency_evolve * frame / 100"} {"parent.low_frequency_translation + parent.low_frequency_evolve * frame / 100"} {"parent.low_frequency_translation + parent.low_frequency_evolve * frame / 100"}}
  "FogKernel_High Frequency Translation" {{"parent.high_frequency_translation + parent.high_frequency_evolve * frame / 100"} {"parent.high_frequency_translation + parent.high_frequency_evolve * frame / 100"} {"parent.high_frequency_translation + parent.high_frequency_evolve * frame / 100"} {"parent.high_frequency_translation + parent.high_frequency_evolve * frame / 100"}}
  rebuild_finalise ""
  name BlinkScript5
  xpos 2080
  ypos 1151
 }
 Group {
  name deep_blender
  knobChanged "\n"
  selected true
  xpos 2080
  ypos 1264
  addUserKnob {20 User}
  addUserKnob {3 samples_per_ray}
  samples_per_ray {{parent.samples_per_ray}}
 }
  Input {
   inputs 0
   name Input1
   xpos 574
   ypos 664
  }
  TimeWarp {
   lookup {{"frame + (1/parent.samples_per_ray*0)"}}
   time ""
   filter none
   name TimeWarp0
   xpos 574
   ypos 812
  }
  Expression {
   expr0 r
   expr1 r
   expr2 r
   channel3 depth
   expr3 1/g
   name Expression0
   xpos 575
   ypos 860
  }
  Expression {
   expr3 r
   name ExprAlpha0
   xpos 575
   ypos 908
  }
  DeepFromImage {
   premult true
   name DeepFromImage0
   xpos 575
   ypos 957
  }
  DeepMerge2 {
   name DeepMerge
   xpos 575
   ypos 1056
  }
  Output {
   name Output1
   xpos 575
   ypos 1154
  }
 end_group
 Dot {
  name Dot16
  xpos 2114
  ypos 1391
 }
set N9bb1740 [stack 0]
 Dot {
  name Dot17
  xpos 2243
  ypos 1391
 }
 Dot {
  name Dot15
  xpos 2243
  ypos 1648
 }
 Input {
  inputs 0
  name deep_holdout
  xpos 1127
  ypos 615
  number 2
 }
 Dot {
  name Dot5
  xpos 1161
  ypos 744
 }
set N9c14e90 [stack 0]
 Dot {
  name Dot6
  xpos 998
  ypos 744
 }
set N9c19de0 [stack 0]
 Dot {
  name Dot12
  xpos 795
  ypos 744
 }
 Dot {
  name Dot13
  xpos 795
  ypos 1475
 }
push $N9bb1740
 DeepMerge2 {
  inputs 2
  operation holdout
  name DeepMerge1
  xpos 2080
  ypos 1472
 }
 DeepToImage2 {
  name DeepToImage3
  xpos 2080
  ypos 1502
 }
 Dot {
  name Dot14
  xpos 2114
  ypos 1588
 }
push $N9c19de0
 DeepCrop {
  use_znear false
  zfar {{parent.Keyer1.range.A}}
  bbox {409.6000061 216 1638.400024 864}
  use_bbox false
  name DeepCrop2
  xpos 964
  ypos 801
 }
 DeepToImage2 {
  name DeepToImage2
  xpos 964
  ypos 852
 }
 Reformat {
  format {{{parent.format_.format}}}
  pbb true
  name Reformat3
  xpos 964
  ypos 936
 }
 Crop {
  box {{min(bbox.x,0)} {min(bbox.y,0)} {max(bbox.r,width)} {max(bbox.t,height)}}
  crop false
  name Crop3
  xpos 964
  ypos 960
 }
 Dot {
  name Dot7
  xpos 998
  ypos 1360
 }
push $N9c14e90
 DeepCrop {
  znear {{parent.Keyer1.range.A}}
  zfar {{parent.Keyer1.range.D}}
  bbox {409.6000061 216 1638.400024 864}
  use_bbox false
  name DeepCrop1
  xpos 1127
  ypos 800
 }
 DeepToImage2 {
  name DeepToImage1
  xpos 1127
  ypos 853
 }
 Shuffle {
  in depth
  in2 rgba
  alpha alpha2
  name shuffle1
  xpos 1127
  ypos 911
 }
 Reformat {
  format {{{parent.format_.format}}}
  pbb true
  name Reformat2
  xpos 1127
  ypos 935
 }
 Crop {
  box {{min(bbox.x,0)} {min(bbox.y,0)} {max(bbox.r,width)} {max(bbox.t,height)}}
  crop false
  name Crop2
  xpos 1127
  ypos 959
 }
 Crop {
  box {{parent.Crop4.box} {parent.Crop4.box} {parent.Crop4.box} {parent.Crop4.box}}
  crop false
  name Crop6
  xpos 1127
  ypos 983
 }
 NoTimeBlur {
  name NoTimeBlur2
  xpos 1127
  ypos 1025
  disable {{!parent.enable_motion_blur}}
 }
 Dot {
  name Dot8
  xpos 1161
  ypos 1072
 }
 Input {
  inputs 0
  name holdout
  xpos 1419
  ypos 620
  number 1
 }
 Dot {
  name Dot4
  xpos 1453
  ypos 744
 }
set Na108fd0 [stack 0]
 Dot {
  name Dot10
  xpos 1357
  ypos 744
 }
 Dot {
  name Dot9
  xpos 1357
  ypos 862
 }
push $Na108fd0
 Expression {
  expr1 0
  expr2 0
  name Expression1
  xpos 1419
  ypos 814
 }
 Copy {
  inputs 2
  from0 depth.Z
  to0 rgba.red
  name Copy1
  xpos 1419
  ypos 853
  disable {{"\[exists parent.input1] ? 0 : 1"}}
 }
 Reformat {
  format {{{parent.format_.format}}}
  pbb true
  name Reformat1
  xpos 1419
  ypos 930
 }
 Crop {
  box {{min(bbox.x,0)} {min(bbox.y,0)} {max(bbox.r,width)} {max(bbox.t,height)}}
  crop false
  name Crop1
  xpos 1419
  ypos 954
 }
 Crop {
  box {{parent.Crop4.box} {parent.Crop4.box} {parent.Crop4.box} {parent.Crop4.box}}
  crop false
  name Crop5
  xpos 1419
  ypos 978
 }
 NoTimeBlur {
  name NoTimeBlur1
  xpos 1419
  ypos 1025
  disable {{!parent.enable_motion_blur}}
 }
 Switch {
  inputs 2
  which {{parent.holdout_mode}}
  name Switch2
  xpos 1419
  ypos 1069
 }
 Dot {
  name Dot1
  xpos 1453
  ypos 1158
 }
push $N9b36360
 BlinkScript {
  inputs 2
  kernelSourceFile /home/ob1/software/nuke/dev/fog/src/blink/kernels/blink_fog_3d.cpp
  recompileCount 142
  ProgramGroup 1
  KernelDescription "2 \"FogKernel\" iterate pixelWise 0e902c74a54fc6674a9bf67003ad166d15937b21bf75e0106251acb980c9280d 3 \"seeds\" Read Point \"depthAOV\" Read Point \"dst\" Write Point 27 \"Focal Length\" Float 1 AABIQg== \"Horizontal Aperture\" Float 1 ppvEQQ== \"Near Plane\" Float 1 zczMPQ== \"Far Plane\" Float 1 AEAcRg== \"Camera World Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"Focal Distance\" Float 1 AACAQA== \"fstop\" Float 1 AACAQQ== \"Enable Depth Of Field\" Bool 1 AQ== \"Output LatLong\" Bool 1 AA== \"Screen Width\" Float 1 AABwRQ== \"Screen Height\" Float 1 AAAHRQ== \"Rays Per Pixel\" Int 1 AQAAAA== \"Density\" Float 1 AACAPw== \"Samples Per Ray\" Int 1 BQAAAA== \"Sample Depth Ramp\" Float 4 AACgQAAAIEEAAHBBAACgQQ== \"Size\" Float 1 AACgQQ== \"Noise Type\" Int 1 AAAAAA== \"Translation\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"Octaves\" Float 1 AAAAQQ== \"Lacunarity\" Float 1 AABAQA== \"Gain\" Float 1 AAAAPw== \"Gamma\" Float 1 AAAAPw== \"Low Frequency Scale\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"High Frequency Scale\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"Low Frequency Translation\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"High Frequency Translation\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"Invert Depth\" Bool 1 AA== 27 \"_focalLength\" 1 1 \"_horizontalAperture\" 1 1 \"_nearPlane\" 1 1 \"_farPlane\" 1 1 \"_cameraWorldMatrix\" 16 1 \"_focalDistance\" 1 1 \"_fStop\" 1 1 \"_depthOfFieldEnabled\" 1 1 \"_latLong\" 1 1 \"_formatWidth\" 1 1 \"_formatHeight\" 1 1 \"_raysPerPixel\" 1 1 \"_density\" 1 1 \"_samplesPerRay\" 1 1 \"_depthRamp\" 4 1 \"_size\" 1 1 \"_noiseType\" 1 1 \"_translation\" 3 1 \"_octaves\" 1 1 \"_lacunarity\" 1 1 \"_gain\" 1 1 \"_gamma\" 1 1 \"_lowFrequencyScale\" 4 1 \"_highFrequencyScale\" 4 1 \"_lowFrequencyTranslation\" 4 1 \"_highFrequencyTranslation\" 4 1 \"_invertDepth\" 1 1 5 \"__inverseCameraProjectionMatrix\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"__aperture\" Float 1 1 AAAAAA== \"__simplex\" Int 1 256 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"__perm\" Int 1 512 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"__grad4\" Int 1 128 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
  kernelSource "// Copyright 2024 by Owen Bulka.\n// All rights reserved.\n// This file is released under the \"MIT License Agreement\".\n// Please see the LICENSE.md file that should have been included as part\n// of this package.\n\n\n//\n// Math operations\n//\n\n\n/**\n * Compute the fractional portion of the value. Ex. 3.5 returns 0.5\n *\n * @arg value: The value to get the fractional portion of.\n *\n * @returns: The fractional portion of the value.\n */\ninline float fract(const float value)\n\{\n    return value - floor(value);\n\}\n\n\n/**\n * Multiply a 4d vector by a 4x4 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline void matmul(const float4x4 &m, const float4 &v, float4 &out)\n\{\n    for (int i=0; i < 4; i++)\n    \{\n        out\[i] = 0;\n\n        for (int j=0; j < 4; j++)\n        \{\n            out\[i] += m\[i]\[j] * v\[j];\n        \}\n    \}\n\}\n\n\n/**\n * Multiply a 4d vector by a 4x4 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline float4 matmul(const float4x4 &m, const float4 &v)\n\{\n    float4 out;\n    for (int i=0; i < 4; i++)\n    \{\n        out\[i] = 0;\n\n        for (int j=0; j < 4; j++)\n        \{\n            out\[i] += m\[i]\[j] * v\[j];\n        \}\n    \}\n\n    return out;\n\}\n\n\n/**\n * Multiply a 3d vector by a 3x3 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline float3 matmul(const float3x3 &m, const float3 &v)\n\{\n    return float3(\n        m\[0]\[0] * v.x + m\[0]\[1] * v.y + m\[0]\[2] * v.z,\n        m\[1]\[0] * v.x + m\[1]\[1] * v.y + m\[1]\[2] * v.z,\n        m\[2]\[0] * v.x + m\[2]\[1] * v.y + m\[2]\[2] * v.z\n    );\n\}\n\n\n/**\n * Convert the uv position in a latlong image to angles.\n *\n * @arg uvPosition: The UV position.\n *\n * @returns: The equivalent angles in radians.\n */\ninline float2 uvPositionToAngles(const float2 &uvPosition)\n\{\n    return float2(\n        (uvPosition.x + 1.0f) * PI,\n        (1.0f - uvPosition.y) * PI / 2.0f\n    );\n\}\n\n\n/**\n * Convert location of a pixel in an image into UV.\n *\n * @arg pixelLocation: The x, and y positions of the pixel.\n * @arg format: The image width, and height.\n *\n * @returns: The UV position.\n */\ninline float2 pixelsToUV(const float2 &pixelLocation, const float2 &format)\n\{\n    return float2(\n        2.0f * pixelLocation.x / format.x - 1.0f,\n        2.0f * pixelLocation.y / format.y - 1.0f\n    );\n\}\n\n\n/**\n * Convert a spherical unit vector (unit radius) to cartesion.\n *\n * @arg angles: The spherical angles in radians.\n *\n * @returns: The equivalent cartesion vector.\n */\ninline float3 sphericalUnitVectorToCartesion(const float2 &angles)\n\{\n    const float sinPhi = sin(angles.y);\n    return float3(\n        cos(angles.x) * sinPhi,\n        cos(angles.y),\n        sin(angles.x) * sinPhi\n    );\n\}\n\n\n/**\n * Get the position component of a world matrix.\n *\n * @arg worldMatrix: The world matrix.\n * @arg position: The location to store the position.\n */\ninline void positionFromWorldMatrix(const float4x4 &worldMatrix, float3 &position)\n\{\n    position = float3(\n        worldMatrix\[0]\[3],\n        worldMatrix\[1]\[3],\n        worldMatrix\[2]\[3]\n    );\n\}\n\n\n/**\n * Get the rotation component of a world matrix.\n *\n * @arg worldMatrix: The world matrix.\n * @arg rotation: The location to store the rotation.\n */\ninline void rotationFromWorldMatrix(const float4x4 &worldMatrix, float3x3 &rotationMatrix)\n\{\n    rotationMatrix\[0]\[0] = worldMatrix\[0]\[0];\n    rotationMatrix\[0]\[1] = worldMatrix\[0]\[1];\n    rotationMatrix\[0]\[2] = worldMatrix\[0]\[2];\n    rotationMatrix\[1]\[0] = worldMatrix\[1]\[0];\n    rotationMatrix\[1]\[1] = worldMatrix\[1]\[1];\n    rotationMatrix\[1]\[2] = worldMatrix\[1]\[2];\n    rotationMatrix\[2]\[0] = worldMatrix\[2]\[0];\n    rotationMatrix\[2]\[1] = worldMatrix\[2]\[1];\n    rotationMatrix\[2]\[2] = worldMatrix\[2]\[2];\n\}\n\n\n//\n// Randomization functions\n//\n\n\n// Some random constants on the interval \[1, 2]\n#define RAND_CONST_0 1.571411510193971f\n#define RAND_CONST_1 1.268632820084931f\n#define RAND_CONST_2 1.7880365647937733f\n#define RAND_CONST_3 1.3546987471558234f\n#define RAND_CONST_4 1.4365958250848703f\n#define RAND_CONST_5 1.7045380669435368f\n\n\n/**\n * Get a random value on the interval \[0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval \[0, 1].\n */\ninline float random(const float seed)\n\{\n    return fract(sin(73.1f * seed + 91.3458f) * 47453.5453f);\n\}\n\n\n/**\n * Get a random value on the interval \[0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval \[0, 1].\n */\ninline float2 random(const float2 &seed)\n\{\n    return float2(\n        fract(sin(13.157f * seed.x + 71.743f) * 7513.471f),\n        fract(sin(97.519f * seed.y + 113.591f) * 47453.5453f)\n    );\n\}\n\n\n/**\n * Create a random point that lies within the unit circle.\n *\n * @arg seed: The random seed.\n *\n * @returns: A random point, (radius, angle) in the unit circle.\n */\ninline float2 uniformPointInUnitCircle(const float2 &seed)\n\{\n    return float2(sqrt(random(seed.x)), 2.0f * PI * random(seed.y));\n\}\n\n\n/**\n * Sum the elements of a vector.\n *\n * @arg vector: The vector to sum the elements of.\n *\n * @returns: The sum of the vector elements.\n */\ninline float elementSum(const float4 &vector) \{\n    return vector.x + vector.y + vector.z + vector.w;\n\}\n\n\n#define FBM_NOISE 1\n\n\n//\n// Camera Utilities\n//\n\n\n/**\n * Compute the field of view from focal length.\n *\n * @arg focalLength: The focal length.\n *\n * @returns: The equivalent field of view.\n */\ninline float fieldOfView(const float focalLength)\n\{\n    return 2 * atan(1 / focalLength);\n\}\n\n\n/**\n * Compute the aspect ratio from image format.\n *\n * @arg height_: The height of the image.\n * @arg width_: The width of the image.\n *\n * @returns: The aspect ratio.\n */\ninline float aspectRatio(const float height_, const float width_)\n\{\n    return height_ / width_;\n\}\n\n\n/**\n *\n */\ninline float fStopToAperture(const float fStop, const float focalLength)\n\{\n    return focalLength / fStop / 1000.0f;\n\}\n\n\n/**\n * Create a projection matrix for a camera.\n *\n * @arg focalLength: The focal length of the camera.\n * @arg horizontalAperture: The horizontal aperture of the camera.\n * @arg aspect: The aspect ratio of the camera.\n * @arg nearPlane: The distance to the near plane of the camera.\n * @arg farPlane: The distance to the far plane of the camera.\n *\n * @returns: The camera's projection matrix.\n */\nfloat4x4 projectionMatrix(\n        const float focalLength,\n        const float horizontalAperture,\n        const float aspect,\n        const float nearPlane,\n        const float farPlane)\n\{\n    float farMinusNear = farPlane - nearPlane;\n    return float4x4(\n        2 * focalLength / horizontalAperture, 0, 0, 0,\n        0, 2 * focalLength / horizontalAperture / aspect, 0, 0,\n        0, 0, -(farPlane + nearPlane) / farMinusNear, -2 * (farPlane * nearPlane) / farMinusNear,\n        0, 0, -1, 0\n    );\n\}\n\n\n/**\n * Generate a ray out of a camera.\n *\n * @arg cameraWorldMatrix: The camera matrix.\n * @arg inverseProjectionMatrix: The inverse of the projection matrix.\n * @arg uvPosition: The UV position in the resulting image.\n * @arg rayOrigin: Will store the origin of the ray.\n * @arg rayDirection: Will store the direction of the ray.\n */\nvoid createCameraRay(\n        const float4x4 &cameraWorldMatrix,\n        const float4x4 &inverseProjectionMatrix,\n        const float2 &uvPosition,\n        float3 &rayOrigin,\n        float3 &rayDirection)\n\{\n    positionFromWorldMatrix(cameraWorldMatrix, rayOrigin);\n    float4 direction = matmul(\n        inverseProjectionMatrix,\n        float4(uvPosition.x, uvPosition.y, 0, 1)\n    );\n    matmul(\n        cameraWorldMatrix,\n        float4(direction.x, direction.y, direction.z, 0),\n        direction\n    );\n    rayDirection = normalize(float3(direction.x, direction.y, direction.z));\n\}\n\n\n/**\n * Generate a ray out of a camera.\n *\n * @arg cameraWorldMatrix: The camera matrix.\n * @arg inverseProjectionMatrix: The inverse of the projection matrix.\n * @arg uvPosition: The UV position in the resulting image.\n * @arg rayOrigin: Will store the origin of the ray.\n * @arg rayDirection: Will store the direction of the ray.\n */\nvoid createCameraRay(\n        const float4x4 &cameraWorldMatrix,\n        const float4x4 &inverseProjectionMatrix,\n        const float2 &uvPosition,\n        const float aperture,\n        const float focalDistance,\n        const float2 &seed,\n        float3 &rayOrigin,\n        float3 &rayDirection)\n\{\n    createCameraRay(\n        cameraWorldMatrix,\n        inverseProjectionMatrix,\n        uvPosition,\n        rayOrigin,\n        rayDirection\n    );\n\n    const float4 cameraForward4 = matmul(\n        cameraWorldMatrix,\n        float4(0, 0, -1, 0)\n    );\n    const float3 cameraForward = float3(\n        cameraForward4.x,\n        cameraForward4.y,\n        cameraForward4.z\n    );\n    const float4 cameraRight4 = matmul(\n        cameraWorldMatrix,\n        float4(1, 0, 0, 0)\n    );\n    const float3 cameraRight = float3(\n        cameraRight4.x,\n        cameraRight4.y,\n        cameraRight4.z\n    );\n    const float4 cameraUp4 = matmul(\n        cameraWorldMatrix,\n        float4(0, 1, 0, 0)\n    );\n    const float3 cameraUp = float3(\n        cameraUp4.x,\n        cameraUp4.y,\n        cameraUp4.z\n    );\n\n    const float3 focalPlanePoint = rayOrigin + cameraForward * focalDistance;\n    const float3 focalPlaneNormal = -cameraForward;\n\n    const float focalPointDistance = (\n        (dot(focalPlaneNormal, focalPlanePoint) - dot(rayOrigin, focalPlaneNormal))\n        / dot(rayDirection, focalPlaneNormal)\n    );\n    const float3 focalPoint = rayOrigin + focalPointDistance * rayDirection;\n\n    const float2 pointInUnitCircle = uniformPointInUnitCircle(seed);\n    const float2 offset = pointInUnitCircle.x * aperture * float2(\n        cos(pointInUnitCircle.y),\n        sin(pointInUnitCircle.y)\n    );\n\n    rayOrigin += cameraRight * offset.x + cameraUp * offset.y;\n    rayDirection = normalize(focalPoint - rayOrigin);\n\}\n\n\n/**\n * Generate a LatLong ray out of a camera.\n *\n * @arg cameraWorldMatrix: The camera matrix.\n * @arg uvPosition: The UV position in the resulting image.\n * @arg rayOrigin: Will store the origin of the ray.\n * @arg rayDirection: Will store the direction of the ray.\n */\nvoid createLatLongCameraRay(\n        const float4x4 &cameraWorldMatrix,\n        const float2 &uvPosition,\n        float3 &rayOrigin,\n        float3 &rayDirection)\n\{\n    positionFromWorldMatrix(cameraWorldMatrix, rayOrigin);\n    rayDirection = sphericalUnitVectorToCartesion(uvPositionToAngles(uvPosition));\n\n    float3x3 cameraRotation;\n    rotationFromWorldMatrix(cameraWorldMatrix, cameraRotation);\n    rayDirection = matmul(cameraRotation, rayDirection);\n\}\n\n\n\nkernel FogKernel : ImageComputationKernel<ePixelWise>\n\{\n    // the input which specifies the format, process is called once per pixel\n    // in this image, which also provides random seeds\n    Image<eRead, eAccessPoint, eEdgeNone> seeds;\n    Image<eRead, eAccessPoint, eEdgeNone> depthAOV;\n\n    // the output image\n    Image<eWrite> dst;\n\n\n    param:\n        // These parameters are made available to the user.\n\n        // Camera params\n        float _focalLength;\n        float _horizontalAperture;\n        float _nearPlane;\n        float _farPlane;\n        float4x4 _cameraWorldMatrix;\n        float _focalDistance;\n        float _fStop;\n        bool _depthOfFieldEnabled;\n        bool _latLong;\n\n        // Image params\n        float _formatWidth;\n        float _formatHeight;\n        int _raysPerPixel;\n        float _density;\n        int _samplesPerRay;\n        float4 _depthRamp;\n\n        // Noise Parameters\n        float _size;\n        int _noiseType;\n        float3 _translation;\n        float _octaves;\n        float _lacunarity;\n        float _gain;\n        float _gamma;\n        float4 _lowFrequencyScale;\n        float4 _highFrequencyScale;\n        float4 _lowFrequencyTranslation;\n        float4 _highFrequencyTranslation;\n\n        bool _invertDepth;\n\n    local:\n        // These local variables are not exposed to the user.\n        float4x4 __inverseCameraProjectionMatrix;\n        float __aperture;\n\n        int __simplex\[64]\[4];\n        int __perm\[512];\n        int __grad4\[32]\[4];\n\n    /**\n     * Give the parameters labels and default values.\n     */\n    void define()\n    \{\n        // Camera params\n        defineParam(_focalLength, \"Focal Length\", 50.0f);\n        defineParam(_horizontalAperture, \"Horizontal Aperture\", 24.576f);\n        defineParam(_nearPlane, \"Near Plane\", 0.1f);\n        defineParam(_farPlane, \"Far Plane\", 10000.0f);\n        defineParam(\n            _cameraWorldMatrix,\n            \"Camera World Matrix\",\n            float4x4(\n                1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1\n            )\n        );\n        defineParam(_focalDistance, \"Focal Distance\", 4.0f);\n        defineParam(_fStop, \"fstop\", 16.0f);\n        defineParam(_depthOfFieldEnabled, \"Enable Depth Of Field\", true);\n        defineParam(_latLong, \"Output LatLong\", false);\n\n        // Image params\n        defineParam(_formatHeight, \"Screen Height\", 2160.0f);\n        defineParam(_formatWidth, \"Screen Width\", 3840.0f);\n        defineParam(_density, \"Density\", 1.0f);\n        defineParam(_raysPerPixel, \"Rays Per Pixel\", 1);\n        defineParam(_samplesPerRay, \"Samples Per Ray\", 5);\n        defineParam(_depthRamp, \"Sample Depth Ramp\", float4(5.0f, 10.0f, 15.0f, 20.0f));\n\n        // Noise Parameters\n        defineParam(_size, \"Size\", 20.0f);\n        defineParam(_noiseType, \"Noise Type\", 0);\n        defineParam(_translation, \"Translation\", float3(0.0f, 0.0f, 0.0f));\n        defineParam(_octaves, \"Octaves\", 8.0f);\n        defineParam(_lacunarity, \"Lacunarity\", 3.0f);\n        defineParam(_gain, \"Gain\", 0.5f);\n        defineParam(_gamma, \"Gamma\", 0.5f);\n        defineParam(_lowFrequencyScale, \"Low Frequency Scale\", float4(0.0f, 0.0f, 0.0f, 0.0f));\n        defineParam(_highFrequencyScale, \"High Frequency Scale\", float4(0.0f, 0.0f, 0.0f, 0.0f));\n        defineParam(_lowFrequencyTranslation, \"Low Frequency Translation\", float4(0.0f, 0.0f, 0.0f, 0.0f));\n        defineParam(_highFrequencyTranslation, \"High Frequency Translation\", float4(0.0f, 0.0f, 0.0f, 0.0f));\n        defineParam(_invertDepth, \"Invert Depth\", false);\n    \}\n\n\n    /**\n     * Initialize the local variables.\n     */\n    void init()\n    \{\n        const float aspect = aspectRatio(_formatHeight, _formatWidth);\n        float4x4 cameraProjectionMatrix = projectionMatrix(\n            _focalLength,\n            _horizontalAperture,\n            aspect,\n            _nearPlane,\n            _farPlane\n        );\n        __inverseCameraProjectionMatrix = cameraProjectionMatrix.invert();\n\n        __aperture = fStopToAperture(_fStop, _focalLength);\n\n        const int simplexInit\[64]\[4] = \{\n            \{0, 1, 2, 3\}, \{0, 1, 3, 2\}, \{0, 0, 0, 0\}, \{0, 2, 3, 1\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{1, 2, 3, 0\},\n            \{0, 2, 1, 3\}, \{0, 0, 0, 0\}, \{0, 3, 1, 2\}, \{0, 3, 2, 1\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{1, 3, 2, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{1, 2, 0, 3\}, \{0, 0, 0, 0\}, \{1, 3, 0, 2\}, \{0, 0, 0, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{2, 3, 0, 1\}, \{2, 3, 1, 0\},\n            \{1, 0, 2, 3\}, \{1, 0, 3, 2\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{0, 0, 0, 0\}, \{2, 0, 3, 1\}, \{0, 0, 0, 0\}, \{2, 1, 3, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{2, 0, 1, 3\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{3, 0, 1, 2\}, \{3, 0, 2, 1\}, \{0, 0, 0, 0\}, \{3, 1, 2, 0\},\n            \{2, 1, 0, 3\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{3, 1, 0, 2\}, \{0, 0, 0, 0\}, \{3, 2, 0, 1\}, \{3, 2, 1, 0\}\n        \};\n\n        for (int i = 0; i < 64; i++)\n        \{\n            for (int j = 0; j < 4; j++)\n            \{\n                __simplex\[i]\[j] = simplexInit\[i]\[j];\n            \}\n        \}\n\n        const int permInit\[256] = \{\n            151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233,\n            7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23,\n            190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219,\n            203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174,\n            20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48,\n            27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133,\n            230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65,\n            25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18,\n            169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198,\n            173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147,\n            118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17,\n            182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44,\n            154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22,\n            39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112,\n            104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12,\n            191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49,\n            192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121,\n            50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29,\n            24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180\n        \};\n\n        for (int i = 0; i < 512; i++)\n        \{\n            __perm\[i] = permInit\[i % 256];\n        \}\n\n        const int grad4Init\[32]\[4]= \{\n            \{0, 1, 1, 1\},  \{0, 1, 1, -1\},  \{0, 1, -1, 1\},  \{0, 1, -1, -1\},\n            \{0, -1, 1, 1\}, \{0, -1, 1, -1\}, \{0, -1, -1, 1\}, \{0, -1, -1, -1\},\n            \{1, 0, 1, 1\},  \{1, 0, 1, -1\},  \{1, 0, -1, 1\},  \{1, 0, -1, -1\},\n            \{-1, 0, 1, 1\}, \{-1, 0, 1, -1\}, \{-1, 0, -1, 1\}, \{-1, 0, -1, -1\},\n            \{1, 1, 0, 1\},  \{1, 1, 0, -1\},  \{1, -1, 0, 1\},  \{1, -1, 0, -1\},\n            \{-1, 1, 0, 1\}, \{-1, 1, 0, -1\}, \{-1, -1, 0, 1\}, \{-1, -1, 0, -1\},\n            \{1, 1, 1, 0\},  \{1, 1, -1, 0\},  \{1, -1, 1, 0\},  \{1, -1, -1, 0\},\n            \{-1, 1, 1, 0\}, \{-1, 1, -1, 0\}, \{-1, -1, 1, 0\}, \{-1, -1, -1, 0\}\n        \};\n\n        for (int i = 0; i < 32; i++)\n        \{\n            for (int j = 0; j < 4; j++)\n            \{\n                __grad4\[i]\[j] = grad4Init\[i]\[j];\n            \}\n        \}\n    \}\n\n    /**\n     * 4D Perlin simplex noise\n     *\n     * Copyright (c) 2007-2012 Eliot Eshelman\n     *\n     * This program is free software: you can redistribute it and/or modify\n     * it under the terms of the GNU General Public License as published by\n     * the Free Software Foundation, either version 3 of the License, or\n     * (at your option) any later version.\n     *\n     * This program is distributed in the hope that it will be useful,\n     * but WITHOUT ANY WARRANTY; without even the implied warranty of\n     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n     * GNU General Public License for more details.\n     *\n     * You should have received a copy of the GNU General Public License\n     * along with this program. If not, see <http://www.gnu.org/licenses/>.\n     *\n     * @arg seed: The seed for the noise.\n     *\n     * @returns: Noise value in the range \[-1, 1], value of 0 on all integer\n     *     coordinates.\n     */\n    inline float perlinSimplexNoise(const float4 &seed) \{\n        const float G4 = 0.138196601f;\n        const float4 i = floor(seed + elementSum(seed) * 0.309016994f);\n        const float4 x0 = seed - i + elementSum(i) * G4;\n\n        const int c = (\n            ((x0.x > x0.y) << 5)\n            | ((x0.x > x0.z) << 4)\n            | ((x0.y > x0.z) << 3)\n            | ((x0.x > x0.w) << 2)\n            | ((x0.y > x0.w) << 1)\n            | (x0.z > x0.w)\n        );\n        const int4 i1 = int4(\n            __simplex\[c]\[0] >= 3,\n            __simplex\[c]\[1] >= 3,\n            __simplex\[c]\[2] >= 3,\n            __simplex\[c]\[3] >= 3\n        );\n        const int4 i2 = int4(\n            __simplex\[c]\[0] >= 2,\n            __simplex\[c]\[1] >= 2,\n            __simplex\[c]\[2] >= 2,\n            __simplex\[c]\[3] >= 2\n        );\n        const int4 i3 = int4(\n            __simplex\[c]\[0] >= 1,\n            __simplex\[c]\[1] >= 1,\n            __simplex\[c]\[2] >= 1,\n            __simplex\[c]\[3] >= 1\n        );\n\n        const float4 x1 = x0 - float4(i1.x, i1.y, i1.z, i1.w) + G4;\n        const float4 x2 = x0 - float4(i2.x, i2.y, i2.z, i2.w) + 2.0f * G4;\n        const float4 x3 = x0 - float4(i3.x, i3.y, i3.z, i3.w) + 3.0f * G4;\n        const float4 x4 = x0 - 1.0f + 4.0f * G4;\n\n        const int ii = (int) i.x & 255;\n        const int jj = (int) i.y & 255;\n        const int kk = (int) i.z & 255;\n        const int ll = (int) i.w & 255;\n\n        const int gi0 = __perm\[\n            ii + __perm\[jj + __perm\[kk + __perm\[ll]]]\n        ] % 32;\n        const int gi1 = __perm\[\n            ii + i1.x + __perm\[jj + i1.y + __perm\[kk + i1.z + __perm\[ll + i1.w]]]\n        ] % 32;\n        const int gi2 = __perm\[\n            ii + i2.x + __perm\[jj + i2.y + __perm\[kk + i2.z + __perm\[ll + i2.w]]]\n        ] % 32;\n        const int gi3 = __perm\[\n            ii + i3.x + __perm\[jj + i3.y + __perm\[kk + i3.z + __perm\[ll + i3.w]]]\n        ] % 32;\n        const int gi4 = __perm\[\n            ii + 1 + __perm\[jj + 1 + __perm\[kk + 1 + __perm\[ll + 1]]]\n        ] % 32;\n\n        float n0, n1, n2, n3, n4;\n        float t0 = 0.6f - dot(x0, x0);\n        if (t0 < 0)\n        \{\n            n0 = 0.0f;\n        \}\n        else\n        \{\n            t0 *= t0;\n            n0 = t0 * t0 * dot(\n                float4(__grad4\[gi0]\[0], __grad4\[gi0]\[1], __grad4\[gi0]\[2], __grad4\[gi0]\[3]),\n                x0\n            );\n        \}\n\n        float t1 = 0.6f - dot(x1, x1);\n        if (t1 < 0)\n        \{\n            n1 = 0.0f;\n        \}\n        else\n        \{\n            t1 *= t1;\n            n1 = t1 * t1 * dot(\n                float4(__grad4\[gi1]\[0], __grad4\[gi1]\[1], __grad4\[gi1]\[2], __grad4\[gi1]\[3]),\n                x1\n            );\n        \}\n\n        float t2 = 0.6f - dot(x2, x2);\n        if (t2 < 0)\n        \{\n            n2 = 0.0f;\n        \}\n        else\n        \{\n            t2 *= t2;\n            n2 = t2 * t2 * dot(\n                float4(__grad4\[gi2]\[0], __grad4\[gi2]\[1], __grad4\[gi2]\[2], __grad4\[gi2]\[3]),\n                x2\n            );\n        \}\n\n        float t3 = 0.6f - dot(x3, x3);\n        if (t3 < 0)\n        \{\n            n3 = 0.0f;\n        \}\n        else\n        \{\n            t3 *= t3;\n            n3 = t3 * t3 * dot(\n                float4(__grad4\[gi3]\[0], __grad4\[gi3]\[1], __grad4\[gi3]\[2], __grad4\[gi3]\[3]),\n                x3\n            );\n        \}\n\n        float t4 = 0.6f - dot(x4, x4);\n        if (t4 < 0)\n        \{\n            n4 = 0.0f;\n        \}\n        else \{\n            t4 *= t4;\n            n4 = t4 * t4 * dot(\n                float4(__grad4\[gi4]\[0], __grad4\[gi4]\[1], __grad4\[gi4]\[2], __grad4\[gi4]\[3]),\n                x4\n            );\n        \}\n\n        return 27.0f * (n0 + n1 + n2 + n3 + n4);\n    \}\n\n\n    //\n    // Use the perlin simplex noise\n    //\n\n\n    /**\n     * fBM noise.\n     *\n     * @arg position: The position to seed the noise.\n     *\n     * @returns: The noise value in the range \[-1, 1].\n     */\n    float fractalBrownianMotionNoise(const float4 &position)\n    \{\n        float output = 0.0f;\n        float frequency = _lacunarity;\n        float amplitude = 1.0f;\n        float denom = 0.0f;\n        float4 translation;\n        float4 scale;\n\n        for (int octave=0; octave < _octaves; octave++)\n        \{\n            const float octaveFraction = octave / _octaves;\n            scale = (\n                (_highFrequencyScale * octaveFraction)\n                + (_lowFrequencyScale * (1.0f - octaveFraction))\n            );       \n            translation = (\n                (_highFrequencyTranslation * octaveFraction)\n                + (_lowFrequencyTranslation * (1.0f - octaveFraction))\n            );\n\n            output += amplitude * perlinSimplexNoise(\n                (position * scale + translation) * frequency / _size\n            );\n\n            frequency *= _lacunarity;\n            denom += amplitude;\n            amplitude *= _gain;\n        \}\n\n        return pow(fabs(output / denom), 1.0f / _gamma);\n    \}\n\n\n    /**\n     * Turbulence noise.\n     *\n     * @arg position: The position to seed the noise.\n     *\n     * @returns: The noise value in the range \[0, 1].\n     */\n    float turbulenceNoise(const float4 &position)\n    \{\n        float output = 0.0f;\n        float frequency = _lacunarity;\n        float amplitude = 1.0f;\n        float denom = 0.0f;\n        float4 translation;\n        float4 scale;\n\n        for (int octave=0; octave < _octaves; octave++)\n        \{\n            const float octaveFraction = octave / _octaves;\n            scale = (\n                (_highFrequencyScale * octaveFraction)\n                + (_lowFrequencyScale * (1.0f - octaveFraction))\n            );       \n            translation = (\n                (_highFrequencyTranslation * octaveFraction)\n                + (_lowFrequencyTranslation * (1.0f - octaveFraction))\n            );\n\n            output += fabs(\n                amplitude * perlinSimplexNoise(\n                    (position * scale + translation) * frequency / _size\n                )\n            );\n\n            frequency *= _lacunarity;\n            denom += amplitude;\n            amplitude *= _gain;\n        \}\n\n        return pow(output / denom, 1.0f / _gamma);\n    \}\n\n\n    /**\n     * Create a ray out of the camera. It will be either a standard ray,\n     * a latlong ray, or a ray that will result in depth of field.\n     *\n     * @arg seed: The seed to use in randomization.\n     * @arg pixelLocation: The x, and y locations of the pixel.\n     * @arg rayOrigin: The location to store the origin of the new ray.\n     * @arg rayDirection: The location to store the direction of the new\n     *     ray.\n     */\n    void getCameraRay(\n            const float2 &seed,\n            const float2 &pixelLocation,\n            float3 &rayOrigin,\n            float3 &rayDirection)\n    \{\n        const float2 uvCoordinates = pixelsToUV(\n            pixelLocation + random(seed),\n            float2(_formatWidth, _formatHeight)\n        );\n        if (_latLong)\n        \{\n            createLatLongCameraRay(\n                _cameraWorldMatrix,\n                uvCoordinates,\n                rayOrigin,\n                rayDirection\n            );\n        \}\n        else if (_depthOfFieldEnabled)\n        \{\n            createCameraRay(\n                _cameraWorldMatrix,\n                __inverseCameraProjectionMatrix,\n                uvCoordinates,\n                __aperture,\n                _focalDistance,\n                seed,\n                rayOrigin,\n                rayDirection\n            );\n        \}\n        else\n        \{\n            createCameraRay(\n                _cameraWorldMatrix,\n                __inverseCameraProjectionMatrix,\n                uvCoordinates,\n                rayOrigin,\n                rayDirection\n            );\n        \}\n    \}\n\n\n    /**\n     * Compute a noise value.\n     *\n     * @arg pos: The x, and y location we are currently processing.\n     */\n    void process(int2 pos)\n    \{\n        float pixelDepth = depthAOV(0);\n        pixelDepth = (\n            pixelDepth > 0.0f ? (_invertDepth ? 1.0f / pixelDepth : pixelDepth) : _depthRamp.w\n        );\n        const float pixelDepthAlpha = 1.0f - depthAOV(3);\n\n        float2 pixelLocation = float2(pos.x, pos.y);\n        SampleType(seeds) seedPixel = seeds();\n        float2 seed0 = float2(seedPixel.x, seedPixel.y) + RAND_CONST_0 * pixelLocation;\n        float2 seed1 = float2(seedPixel.z, seedPixel.w) + RAND_CONST_1 * pixelLocation;\n\n        float4 resultPixel = float4(0.0f);\n\n        const float sampleStep = (_depthRamp.w - _depthRamp.x) / (float) _samplesPerRay;\n\n        for (int path=1; path <= _raysPerPixel; path++)\n        \{\n            // Generate a ray from the camera\n            float3 rayOrigin;\n            float3 rayDirection;\n            getCameraRay(\n                seed0,\n                pixelLocation,\n                rayOrigin,\n                rayDirection\n            );\n\n            // Set the depth to the start of the depth ramp and add a random offset\n            // to eliminate layer lines\n            float depth = _depthRamp.x - random(seed0.x + seed0.y) * sampleStep;\n            rayOrigin += depth * rayDirection + _translation;\n\n            float invertedLastSample = 1.0f;\n            for (int step=0; step < _samplesPerRay; step++)\n            \{\n                float ramp = 1.0f;\n                depth += sampleStep;\n                if (depth > pixelDepth)\n                \{\n                    if (pixelDepthAlpha <= 0.0f)\n                    \{\n                        break;\n                    \}\n                    ramp *= pixelDepthAlpha;\n                \}\n                rayOrigin += rayDirection * sampleStep;\n\n                // Get the noise value based on which type of noise we are using\n                const float4 samplePosition4d = float4(\n                    rayOrigin.x,\n                    rayOrigin.y,\n                    rayOrigin.z,\n                    0.0f\n                );\n\n                // Apply the scaling specified by the depth ramp\n                if (depth < _depthRamp.y)\n                \{\n                    ramp *= (depth - _depthRamp.y) / (_depthRamp.y - _depthRamp.x) + 1.0f;\n                \}\n                else if (depth > _depthRamp.z)\n                \{\n                    ramp *= (_depthRamp.w - depth) / (_depthRamp.w - _depthRamp.z);\n                \}\n\n                // Compute the noise value at this position\n                float noiseValue = _density * ramp;\n                if (_noiseType == FBM_NOISE)\n                \{\n                    noiseValue *= fractalBrownianMotionNoise(samplePosition4d);\n                \}\n                else\n                \{\n                    noiseValue *= turbulenceNoise(samplePosition4d);\n                \}\n\n                // Over the noise values\n                resultPixel += noiseValue * invertedLastSample;\n                invertedLastSample *= 1.0f - noiseValue;\n            \}\n\n            const float2 lastSeed = seed0;\n            seed0 = RAND_CONST_2 * float2(seed1.y, seed1.x) + RAND_CONST_3 * path;\n            seed1 = RAND_CONST_4 * lastSeed + RAND_CONST_5 * path;\n        \}\n\n        dst() = resultPixel / float(_raysPerPixel);\n    \}\n\};\n"
  rebuild ""
  "FogKernel_Focal Length" {{parent.DummyCam.focal}}
  "FogKernel_Horizontal Aperture" {{parent.DummyCam.haperture}}
  "FogKernel_Near Plane" {{parent.DummyCam.near}}
  "FogKernel_Far Plane" {{parent.DummyCam.far}}
  "FogKernel_Camera World Matrix" {
      {{parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix}}
      {{parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix}}
      {{parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix}}
      {{parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix}}
    }
  "FogKernel_Focal Distance" {{parent.DummyCam.focal_point}}
  FogKernel_fstop {{parent.DummyCam.fstop}}
  "FogKernel_Enable Depth Of Field" {{parent.depth_of_field}}
  "FogKernel_Output LatLong" {{parent.latlong}}
  "FogKernel_Screen Width" {{"proxy? input0.width*proxy_scale: input0.width"}}
  "FogKernel_Screen Height" {{"proxy? input0.height * proxy_scale : input0.height"}}
  "FogKernel_Rays Per Pixel" {{parent.rays_per_pixel}}
  FogKernel_Density {{"parent.density * 50 / parent.samples_per_ray"}}
  "FogKernel_Samples Per Ray" {{parent.samples_per_ray}}
  "FogKernel_Sample Depth Ramp" {{parent.Keyer1.range.A} {parent.Keyer1.range.B} {parent.Keyer1.range.C} {parent.Keyer1.range.D}}
  FogKernel_Size {{parent.size}}
  "FogKernel_Noise Type" {{parent.type}}
  FogKernel_Translation {{-parent.translation-8} {-parent.translation} {-parent.translation}}
  FogKernel_Octaves {{parent.octaves}}
  FogKernel_Lacunarity {{parent.lacunarity}}
  FogKernel_Gain {{parent.gain}}
  FogKernel_Gamma {{parent.gamma}}
  "FogKernel_Low Frequency Scale" {{parent.low_frequency_scale} {parent.low_frequency_scale} {parent.low_frequency_scale} {parent.low_frequency_scale}}
  "FogKernel_High Frequency Scale" {{parent.high_frequency_scale} {parent.high_frequency_scale} {parent.high_frequency_scale} {parent.high_frequency_scale}}
  "FogKernel_Low Frequency Translation" {{"parent.low_frequency_translation + parent.low_frequency_evolve * frame / 100"} {"parent.low_frequency_translation + parent.low_frequency_evolve * frame / 100"} {"parent.low_frequency_translation + parent.low_frequency_evolve * frame / 100"} {"parent.low_frequency_translation + parent.low_frequency_evolve * frame / 100"}}
  "FogKernel_High Frequency Translation" {{"parent.high_frequency_translation + parent.high_frequency_evolve * frame / 100"} {"parent.high_frequency_translation + parent.high_frequency_evolve * frame / 100"} {"parent.high_frequency_translation + parent.high_frequency_evolve * frame / 100"} {"parent.high_frequency_translation + parent.high_frequency_evolve * frame / 100"}}
  "FogKernel_Invert Depth" {{"parent.holdout_mode? 1: parent.invert_depth"}}
  rebuild_finalise ""
  name BlinkScript1
  xpos 1756
  ypos 1149
 }
push $N9c66ed0
 BlinkScript {
  kernelSourceFile /home/ob1/software/nuke/dev/fog/src/blink/kernels/blink_fog_3d_no_depth.cpp
  recompileCount 137
  ProgramGroup 1
  KernelDescription "2 \"FogKernel\" iterate pixelWise 29debb16ae3b77d21324b441989cd40e6352d5c988e51890d2703adb249e1032 2 \"seeds\" Read Point \"dst\" Write Point 26 \"Focal Length\" Float 1 AABIQg== \"Horizontal Aperture\" Float 1 ppvEQQ== \"Near Plane\" Float 1 zczMPQ== \"Far Plane\" Float 1 AEAcRg== \"Camera World Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"Focal Distance\" Float 1 AACAQA== \"fstop\" Float 1 AACAQQ== \"Enable Depth Of Field\" Bool 1 AQ== \"Output LatLong\" Bool 1 AA== \"Screen Width\" Float 1 AABwRQ== \"Screen Height\" Float 1 AAAHRQ== \"Rays Per Pixel\" Int 1 AQAAAA== \"Density\" Float 1 AACAPw== \"Samples Per Ray\" Int 1 BQAAAA== \"Sample Depth Ramp\" Float 4 AACgQAAAIEEAAHBBAACgQQ== \"Size\" Float 1 AACgQQ== \"Noise Type\" Int 1 AAAAAA== \"Translation\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"Octaves\" Float 1 AAAAQQ== \"Lacunarity\" Float 1 AABAQA== \"Gain\" Float 1 AAAAPw== \"Gamma\" Float 1 AAAAPw== \"Low Frequency Scale\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"High Frequency Scale\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"Low Frequency Translation\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"High Frequency Translation\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== 26 \"_focalLength\" 1 1 \"_horizontalAperture\" 1 1 \"_nearPlane\" 1 1 \"_farPlane\" 1 1 \"_cameraWorldMatrix\" 16 1 \"_focalDistance\" 1 1 \"_fStop\" 1 1 \"_depthOfFieldEnabled\" 1 1 \"_latLong\" 1 1 \"_formatWidth\" 1 1 \"_formatHeight\" 1 1 \"_raysPerPixel\" 1 1 \"_density\" 1 1 \"_samplesPerRay\" 1 1 \"_depthRamp\" 4 1 \"_size\" 1 1 \"_noiseType\" 1 1 \"_translation\" 3 1 \"_octaves\" 1 1 \"_lacunarity\" 1 1 \"_gain\" 1 1 \"_gamma\" 1 1 \"_lowFrequencyScale\" 4 1 \"_highFrequencyScale\" 4 1 \"_lowFrequencyTranslation\" 4 1 \"_highFrequencyTranslation\" 4 1 5 \"__inverseCameraProjectionMatrix\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"__aperture\" Float 1 1 AAAAAA== \"__simplex\" Int 1 256 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"__perm\" Int 1 512 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"__grad4\" Int 1 128 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
  kernelSource "// Copyright 2024 by Owen Bulka.\n// All rights reserved.\n// This file is released under the \"MIT License Agreement\".\n// Please see the LICENSE.md file that should have been included as part\n// of this package.\n\n\n//\n// Math operations\n//\n\n\n/**\n * Compute the fractional portion of the value. Ex. 3.5 returns 0.5\n *\n * @arg value: The value to get the fractional portion of.\n *\n * @returns: The fractional portion of the value.\n */\ninline float fract(const float value)\n\{\n    return value - floor(value);\n\}\n\n\n/**\n * Multiply a 4d vector by a 4x4 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline void matmul(const float4x4 &m, const float4 &v, float4 &out)\n\{\n    for (int i=0; i < 4; i++)\n    \{\n        out\[i] = 0;\n\n        for (int j=0; j < 4; j++)\n        \{\n            out\[i] += m\[i]\[j] * v\[j];\n        \}\n    \}\n\}\n\n\n/**\n * Multiply a 4d vector by a 4x4 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline float4 matmul(const float4x4 &m, const float4 &v)\n\{\n    float4 out;\n    for (int i=0; i < 4; i++)\n    \{\n        out\[i] = 0;\n\n        for (int j=0; j < 4; j++)\n        \{\n            out\[i] += m\[i]\[j] * v\[j];\n        \}\n    \}\n\n    return out;\n\}\n\n\n/**\n * Multiply a 3d vector by a 3x3 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline float3 matmul(const float3x3 &m, const float3 &v)\n\{\n    return float3(\n        m\[0]\[0] * v.x + m\[0]\[1] * v.y + m\[0]\[2] * v.z,\n        m\[1]\[0] * v.x + m\[1]\[1] * v.y + m\[1]\[2] * v.z,\n        m\[2]\[0] * v.x + m\[2]\[1] * v.y + m\[2]\[2] * v.z\n    );\n\}\n\n\n/**\n * Convert the uv position in a latlong image to angles.\n *\n * @arg uvPosition: The UV position.\n *\n * @returns: The equivalent angles in radians.\n */\ninline float2 uvPositionToAngles(const float2 &uvPosition)\n\{\n    return float2(\n        (uvPosition.x + 1.0f) * PI,\n        (1.0f - uvPosition.y) * PI / 2.0f\n    );\n\}\n\n\n/**\n * Convert location of a pixel in an image into UV.\n *\n * @arg pixelLocation: The x, and y positions of the pixel.\n * @arg format: The image width, and height.\n *\n * @returns: The UV position.\n */\ninline float2 pixelsToUV(const float2 &pixelLocation, const float2 &format)\n\{\n    return float2(\n        2.0f * pixelLocation.x / format.x - 1.0f,\n        2.0f * pixelLocation.y / format.y - 1.0f\n    );\n\}\n\n\n/**\n * Convert a spherical unit vector (unit radius) to cartesion.\n *\n * @arg angles: The spherical angles in radians.\n *\n * @returns: The equivalent cartesion vector.\n */\ninline float3 sphericalUnitVectorToCartesion(const float2 &angles)\n\{\n    const float sinPhi = sin(angles.y);\n    return float3(\n        cos(angles.x) * sinPhi,\n        cos(angles.y),\n        sin(angles.x) * sinPhi\n    );\n\}\n\n\n/**\n * Get the position component of a world matrix.\n *\n * @arg worldMatrix: The world matrix.\n * @arg position: The location to store the position.\n */\ninline void positionFromWorldMatrix(const float4x4 &worldMatrix, float3 &position)\n\{\n    position = float3(\n        worldMatrix\[0]\[3],\n        worldMatrix\[1]\[3],\n        worldMatrix\[2]\[3]\n    );\n\}\n\n\n/**\n * Get the rotation component of a world matrix.\n *\n * @arg worldMatrix: The world matrix.\n * @arg rotation: The location to store the rotation.\n */\ninline void rotationFromWorldMatrix(const float4x4 &worldMatrix, float3x3 &rotationMatrix)\n\{\n    rotationMatrix\[0]\[0] = worldMatrix\[0]\[0];\n    rotationMatrix\[0]\[1] = worldMatrix\[0]\[1];\n    rotationMatrix\[0]\[2] = worldMatrix\[0]\[2];\n    rotationMatrix\[1]\[0] = worldMatrix\[1]\[0];\n    rotationMatrix\[1]\[1] = worldMatrix\[1]\[1];\n    rotationMatrix\[1]\[2] = worldMatrix\[1]\[2];\n    rotationMatrix\[2]\[0] = worldMatrix\[2]\[0];\n    rotationMatrix\[2]\[1] = worldMatrix\[2]\[1];\n    rotationMatrix\[2]\[2] = worldMatrix\[2]\[2];\n\}\n\n\n//\n// Randomization functions\n//\n\n\n// Some random constants on the interval \[1, 2]\n#define RAND_CONST_0 1.571411510193971f\n#define RAND_CONST_1 1.268632820084931f\n#define RAND_CONST_2 1.7880365647937733f\n#define RAND_CONST_3 1.3546987471558234f\n#define RAND_CONST_4 1.4365958250848703f\n#define RAND_CONST_5 1.7045380669435368f\n\n\n/**\n * Get a random value on the interval \[0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval \[0, 1].\n */\ninline float random(const float seed)\n\{\n    return fract(sin(73.1f * seed + 91.3458f) * 47453.5453f);\n\}\n\n\n/**\n * Get a random value on the interval \[0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval \[0, 1].\n */\ninline float2 random(const float2 &seed)\n\{\n    return float2(\n        fract(sin(13.157f * seed.x + 71.743f) * 7513.471f),\n        fract(sin(97.519f * seed.y + 113.591f) * 47453.5453f)\n    );\n\}\n\n\n/**\n * Create a random point that lies within the unit circle.\n *\n * @arg seed: The random seed.\n *\n * @returns: A random point, (radius, angle) in the unit circle.\n */\ninline float2 uniformPointInUnitCircle(const float2 &seed)\n\{\n    return float2(sqrt(random(seed.x)), 2.0f * PI * random(seed.y));\n\}\n\n\n/**\n * Sum the elements of a vector.\n *\n * @arg vector: The vector to sum the elements of.\n *\n * @returns: The sum of the vector elements.\n */\ninline float elementSum(const float4 &vector) \{\n    return vector.x + vector.y + vector.z + vector.w;\n\}\n\n\n#define FBM_NOISE 1\n\n\n//\n// Camera Utilities\n//\n\n\n/**\n * Compute the field of view from focal length.\n *\n * @arg focalLength: The focal length.\n *\n * @returns: The equivalent field of view.\n */\ninline float fieldOfView(const float focalLength)\n\{\n    return 2 * atan(1 / focalLength);\n\}\n\n\n/**\n * Compute the aspect ratio from image format.\n *\n * @arg height_: The height of the image.\n * @arg width_: The width of the image.\n *\n * @returns: The aspect ratio.\n */\ninline float aspectRatio(const float height_, const float width_)\n\{\n    return height_ / width_;\n\}\n\n\n/**\n *\n */\ninline float fStopToAperture(const float fStop, const float focalLength)\n\{\n    return focalLength / fStop / 1000.0f;\n\}\n\n\n/**\n * Create a projection matrix for a camera.\n *\n * @arg focalLength: The focal length of the camera.\n * @arg horizontalAperture: The horizontal aperture of the camera.\n * @arg aspect: The aspect ratio of the camera.\n * @arg nearPlane: The distance to the near plane of the camera.\n * @arg farPlane: The distance to the far plane of the camera.\n *\n * @returns: The camera's projection matrix.\n */\nfloat4x4 projectionMatrix(\n        const float focalLength,\n        const float horizontalAperture,\n        const float aspect,\n        const float nearPlane,\n        const float farPlane)\n\{\n    float farMinusNear = farPlane - nearPlane;\n    return float4x4(\n        2 * focalLength / horizontalAperture, 0, 0, 0,\n        0, 2 * focalLength / horizontalAperture / aspect, 0, 0,\n        0, 0, -(farPlane + nearPlane) / farMinusNear, -2 * (farPlane * nearPlane) / farMinusNear,\n        0, 0, -1, 0\n    );\n\}\n\n\n/**\n * Generate a ray out of a camera.\n *\n * @arg cameraWorldMatrix: The camera matrix.\n * @arg inverseProjectionMatrix: The inverse of the projection matrix.\n * @arg uvPosition: The UV position in the resulting image.\n * @arg rayOrigin: Will store the origin of the ray.\n * @arg rayDirection: Will store the direction of the ray.\n */\nvoid createCameraRay(\n        const float4x4 &cameraWorldMatrix,\n        const float4x4 &inverseProjectionMatrix,\n        const float2 &uvPosition,\n        float3 &rayOrigin,\n        float3 &rayDirection)\n\{\n    positionFromWorldMatrix(cameraWorldMatrix, rayOrigin);\n    float4 direction = matmul(\n        inverseProjectionMatrix,\n        float4(uvPosition.x, uvPosition.y, 0, 1)\n    );\n    matmul(\n        cameraWorldMatrix,\n        float4(direction.x, direction.y, direction.z, 0),\n        direction\n    );\n    rayDirection = normalize(float3(direction.x, direction.y, direction.z));\n\}\n\n\n/**\n * Generate a ray out of a camera.\n *\n * @arg cameraWorldMatrix: The camera matrix.\n * @arg inverseProjectionMatrix: The inverse of the projection matrix.\n * @arg uvPosition: The UV position in the resulting image.\n * @arg rayOrigin: Will store the origin of the ray.\n * @arg rayDirection: Will store the direction of the ray.\n */\nvoid createCameraRay(\n        const float4x4 &cameraWorldMatrix,\n        const float4x4 &inverseProjectionMatrix,\n        const float2 &uvPosition,\n        const float aperture,\n        const float focalDistance,\n        const float2 &seed,\n        float3 &rayOrigin,\n        float3 &rayDirection)\n\{\n    createCameraRay(\n        cameraWorldMatrix,\n        inverseProjectionMatrix,\n        uvPosition,\n        rayOrigin,\n        rayDirection\n    );\n\n    const float4 cameraForward4 = matmul(\n        cameraWorldMatrix,\n        float4(0, 0, -1, 0)\n    );\n    const float3 cameraForward = float3(\n        cameraForward4.x,\n        cameraForward4.y,\n        cameraForward4.z\n    );\n    const float4 cameraRight4 = matmul(\n        cameraWorldMatrix,\n        float4(1, 0, 0, 0)\n    );\n    const float3 cameraRight = float3(\n        cameraRight4.x,\n        cameraRight4.y,\n        cameraRight4.z\n    );\n    const float4 cameraUp4 = matmul(\n        cameraWorldMatrix,\n        float4(0, 1, 0, 0)\n    );\n    const float3 cameraUp = float3(\n        cameraUp4.x,\n        cameraUp4.y,\n        cameraUp4.z\n    );\n\n    const float3 focalPlanePoint = rayOrigin + cameraForward * focalDistance;\n    const float3 focalPlaneNormal = -cameraForward;\n\n    const float focalPointDistance = (\n        (dot(focalPlaneNormal, focalPlanePoint) - dot(rayOrigin, focalPlaneNormal))\n        / dot(rayDirection, focalPlaneNormal)\n    );\n    const float3 focalPoint = rayOrigin + focalPointDistance * rayDirection;\n\n    const float2 pointInUnitCircle = uniformPointInUnitCircle(seed);\n    const float2 offset = pointInUnitCircle.x * aperture * float2(\n        cos(pointInUnitCircle.y),\n        sin(pointInUnitCircle.y)\n    );\n\n    rayOrigin += cameraRight * offset.x + cameraUp * offset.y;\n    rayDirection = normalize(focalPoint - rayOrigin);\n\}\n\n\n/**\n * Generate a LatLong ray out of a camera.\n *\n * @arg cameraWorldMatrix: The camera matrix.\n * @arg uvPosition: The UV position in the resulting image.\n * @arg rayOrigin: Will store the origin of the ray.\n * @arg rayDirection: Will store the direction of the ray.\n */\nvoid createLatLongCameraRay(\n        const float4x4 &cameraWorldMatrix,\n        const float2 &uvPosition,\n        float3 &rayOrigin,\n        float3 &rayDirection)\n\{\n    positionFromWorldMatrix(cameraWorldMatrix, rayOrigin);\n    rayDirection = sphericalUnitVectorToCartesion(uvPositionToAngles(uvPosition));\n\n    float3x3 cameraRotation;\n    rotationFromWorldMatrix(cameraWorldMatrix, cameraRotation);\n    rayDirection = matmul(cameraRotation, rayDirection);\n\}\n\n\n\nkernel FogKernel : ImageComputationKernel<ePixelWise>\n\{\n    // the input which specifies the format, process is called once per pixel\n    // in this image, which also provides random seeds\n    Image<eRead, eAccessPoint, eEdgeNone> seeds;\n\n    // the output image\n    Image<eWrite> dst;\n\n\n    param:\n        // These parameters are made available to the user.\n\n        // Camera params\n        float _focalLength;\n        float _horizontalAperture;\n        float _nearPlane;\n        float _farPlane;\n        float4x4 _cameraWorldMatrix;\n        float _focalDistance;\n        float _fStop;\n        bool _depthOfFieldEnabled;\n        bool _latLong;\n\n        // Image params\n        float _formatWidth;\n        float _formatHeight;\n        int _raysPerPixel;\n        float _density;\n        int _samplesPerRay;\n        float4 _depthRamp;\n\n        // Noise Parameters\n        float _size;\n        int _noiseType;\n        float3 _translation;\n        float _octaves;\n        float _lacunarity;\n        float _gain;\n        float _gamma;\n        float4 _lowFrequencyScale;\n        float4 _highFrequencyScale;\n        float4 _lowFrequencyTranslation;\n        float4 _highFrequencyTranslation;\n\n    local:\n        // These local variables are not exposed to the user.\n        float4x4 __inverseCameraProjectionMatrix;\n        float __aperture;\n\n        int __simplex\[64]\[4];\n        int __perm\[512];\n        int __grad4\[32]\[4];\n\n    /**\n     * Give the parameters labels and default values.\n     */\n    void define()\n    \{\n        // Camera params\n        defineParam(_focalLength, \"Focal Length\", 50.0f);\n        defineParam(_horizontalAperture, \"Horizontal Aperture\", 24.576f);\n        defineParam(_nearPlane, \"Near Plane\", 0.1f);\n        defineParam(_farPlane, \"Far Plane\", 10000.0f);\n        defineParam(\n            _cameraWorldMatrix,\n            \"Camera World Matrix\",\n            float4x4(\n                1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1\n            )\n        );\n        defineParam(_focalDistance, \"Focal Distance\", 4.0f);\n        defineParam(_fStop, \"fstop\", 16.0f);\n        defineParam(_depthOfFieldEnabled, \"Enable Depth Of Field\", true);\n        defineParam(_latLong, \"Output LatLong\", false);\n\n        // Image params\n        defineParam(_formatHeight, \"Screen Height\", 2160.0f);\n        defineParam(_formatWidth, \"Screen Width\", 3840.0f);\n        defineParam(_density, \"Density\", 1.0f);\n        defineParam(_raysPerPixel, \"Rays Per Pixel\", 1);\n        defineParam(_samplesPerRay, \"Samples Per Ray\", 5);\n        defineParam(_depthRamp, \"Sample Depth Ramp\", float4(5.0f, 10.0f, 15.0f, 20.0f));\n\n        // Noise Parameters\n        defineParam(_size, \"Size\", 20.0f);\n        defineParam(_noiseType, \"Noise Type\", 0);\n        defineParam(_translation, \"Translation\", float3(0.0f, 0.0f, 0.0f));\n        defineParam(_octaves, \"Octaves\", 8.0f);\n        defineParam(_lacunarity, \"Lacunarity\", 3.0f);\n        defineParam(_gain, \"Gain\", 0.5f);\n        defineParam(_gamma, \"Gamma\", 0.5f);\n        defineParam(_lowFrequencyScale, \"Low Frequency Scale\", float4(0.0f, 0.0f, 0.0f, 0.0f));\n        defineParam(_highFrequencyScale, \"High Frequency Scale\", float4(0.0f, 0.0f, 0.0f, 0.0f));\n        defineParam(_lowFrequencyTranslation, \"Low Frequency Translation\", float4(0.0f, 0.0f, 0.0f, 0.0f));\n        defineParam(_highFrequencyTranslation, \"High Frequency Translation\", float4(0.0f, 0.0f, 0.0f, 0.0f));\n    \}\n\n\n    /**\n     * Initialize the local variables.\n     */\n    void init()\n    \{\n        const float aspect = aspectRatio(_formatHeight, _formatWidth);\n        float4x4 cameraProjectionMatrix = projectionMatrix(\n            _focalLength,\n            _horizontalAperture,\n            aspect,\n            _nearPlane,\n            _farPlane\n        );\n        __inverseCameraProjectionMatrix = cameraProjectionMatrix.invert();\n\n        __aperture = fStopToAperture(_fStop, _focalLength);\n\n        const int simplexInit\[64]\[4] = \{\n            \{0, 1, 2, 3\}, \{0, 1, 3, 2\}, \{0, 0, 0, 0\}, \{0, 2, 3, 1\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{1, 2, 3, 0\},\n            \{0, 2, 1, 3\}, \{0, 0, 0, 0\}, \{0, 3, 1, 2\}, \{0, 3, 2, 1\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{1, 3, 2, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{1, 2, 0, 3\}, \{0, 0, 0, 0\}, \{1, 3, 0, 2\}, \{0, 0, 0, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{2, 3, 0, 1\}, \{2, 3, 1, 0\},\n            \{1, 0, 2, 3\}, \{1, 0, 3, 2\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{0, 0, 0, 0\}, \{2, 0, 3, 1\}, \{0, 0, 0, 0\}, \{2, 1, 3, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{2, 0, 1, 3\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{3, 0, 1, 2\}, \{3, 0, 2, 1\}, \{0, 0, 0, 0\}, \{3, 1, 2, 0\},\n            \{2, 1, 0, 3\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{3, 1, 0, 2\}, \{0, 0, 0, 0\}, \{3, 2, 0, 1\}, \{3, 2, 1, 0\}\n        \};\n\n        for (int i = 0; i < 64; i++)\n        \{\n            for (int j = 0; j < 4; j++)\n            \{\n                __simplex\[i]\[j] = simplexInit\[i]\[j];\n            \}\n        \}\n\n        const int permInit\[256] = \{\n            151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233,\n            7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23,\n            190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219,\n            203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174,\n            20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48,\n            27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133,\n            230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65,\n            25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18,\n            169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198,\n            173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147,\n            118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17,\n            182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44,\n            154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22,\n            39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112,\n            104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12,\n            191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49,\n            192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121,\n            50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29,\n            24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180\n        \};\n\n        for (int i = 0; i < 512; i++)\n        \{\n            __perm\[i] = permInit\[i % 256];\n        \}\n\n        const int grad4Init\[32]\[4]= \{\n            \{0, 1, 1, 1\},  \{0, 1, 1, -1\},  \{0, 1, -1, 1\},  \{0, 1, -1, -1\},\n            \{0, -1, 1, 1\}, \{0, -1, 1, -1\}, \{0, -1, -1, 1\}, \{0, -1, -1, -1\},\n            \{1, 0, 1, 1\},  \{1, 0, 1, -1\},  \{1, 0, -1, 1\},  \{1, 0, -1, -1\},\n            \{-1, 0, 1, 1\}, \{-1, 0, 1, -1\}, \{-1, 0, -1, 1\}, \{-1, 0, -1, -1\},\n            \{1, 1, 0, 1\},  \{1, 1, 0, -1\},  \{1, -1, 0, 1\},  \{1, -1, 0, -1\},\n            \{-1, 1, 0, 1\}, \{-1, 1, 0, -1\}, \{-1, -1, 0, 1\}, \{-1, -1, 0, -1\},\n            \{1, 1, 1, 0\},  \{1, 1, -1, 0\},  \{1, -1, 1, 0\},  \{1, -1, -1, 0\},\n            \{-1, 1, 1, 0\}, \{-1, 1, -1, 0\}, \{-1, -1, 1, 0\}, \{-1, -1, -1, 0\}\n        \};\n\n        for (int i = 0; i < 32; i++)\n        \{\n            for (int j = 0; j < 4; j++)\n            \{\n                __grad4\[i]\[j] = grad4Init\[i]\[j];\n            \}\n        \}\n    \}\n\n    /**\n     * 4D Perlin simplex noise\n     *\n     * Copyright (c) 2007-2012 Eliot Eshelman\n     *\n     * This program is free software: you can redistribute it and/or modify\n     * it under the terms of the GNU General Public License as published by\n     * the Free Software Foundation, either version 3 of the License, or\n     * (at your option) any later version.\n     *\n     * This program is distributed in the hope that it will be useful,\n     * but WITHOUT ANY WARRANTY; without even the implied warranty of\n     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n     * GNU General Public License for more details.\n     *\n     * You should have received a copy of the GNU General Public License\n     * along with this program. If not, see <http://www.gnu.org/licenses/>.\n     *\n     * @arg seed: The seed for the noise.\n     * @arg simplex: The simplex LUT.\n     * @arg perm: The perm LUT.\n     * @arg grad4: The grad4 LUT.\n     *\n     * @returns: Noise value in the range \[-1, 1], value of 0 on all integer\n     *     coordinates.\n     */\n    inline float perlinSimplexNoise(\n            const float4 &seed\n    )\n    \{\n        const float G4 = 0.138196601f;\n        const float4 i = floor(seed + elementSum(seed) * 0.309016994f);\n        const float4 x0 = seed - i + elementSum(i) * G4;\n\n        const int c = (\n            ((x0.x > x0.y) << 5)\n            | ((x0.x > x0.z) << 4)\n            | ((x0.y > x0.z) << 3)\n            | ((x0.x > x0.w) << 2)\n            | ((x0.y > x0.w) << 1)\n            | (x0.z > x0.w)\n        );\n        const int4 i1 = int4(\n            __simplex\[c]\[0] >= 3,\n            __simplex\[c]\[1] >= 3,\n            __simplex\[c]\[2] >= 3,\n            __simplex\[c]\[3] >= 3\n        );\n        const int4 i2 = int4(\n            __simplex\[c]\[0] >= 2,\n            __simplex\[c]\[1] >= 2,\n            __simplex\[c]\[2] >= 2,\n            __simplex\[c]\[3] >= 2\n        );\n        const int4 i3 = int4(\n            __simplex\[c]\[0] >= 1,\n            __simplex\[c]\[1] >= 1,\n            __simplex\[c]\[2] >= 1,\n            __simplex\[c]\[3] >= 1\n        );\n\n        const float4 x1 = x0 - float4(i1.x, i1.y, i1.z, i1.w) + G4;\n        const float4 x2 = x0 - float4(i2.x, i2.y, i2.z, i2.w) + 2.0f * G4;\n        const float4 x3 = x0 - float4(i3.x, i3.y, i3.z, i3.w) + 3.0f * G4;\n        const float4 x4 = x0 - 1.0f + 4.0f * G4;\n\n        const int ii = (int) i.x & 255;\n        const int jj = (int) i.y & 255;\n        const int kk = (int) i.z & 255;\n        const int ll = (int) i.w & 255;\n\n        const int gi0 = __perm\[\n            ii + __perm\[jj + __perm\[kk + __perm\[ll]]]\n        ] % 32;\n        const int gi1 = __perm\[\n            ii + i1.x + __perm\[jj + i1.y + __perm\[kk + i1.z + __perm\[ll + i1.w]]]\n        ] % 32;\n        const int gi2 = __perm\[\n            ii + i2.x + __perm\[jj + i2.y + __perm\[kk + i2.z + __perm\[ll + i2.w]]]\n        ] % 32;\n        const int gi3 = __perm\[\n            ii + i3.x + __perm\[jj + i3.y + __perm\[kk + i3.z + __perm\[ll + i3.w]]]\n        ] % 32;\n        const int gi4 = __perm\[\n            ii + 1 + __perm\[jj + 1 + __perm\[kk + 1 + __perm\[ll + 1]]]\n        ] % 32;\n\n        float n0, n1, n2, n3, n4;\n        float t0 = 0.6f - dot(x0, x0);\n        if (t0 < 0)\n        \{\n            n0 = 0.0f;\n        \}\n        else\n        \{\n            t0 *= t0;\n            n0 = t0 * t0 * dot(\n                float4(__grad4\[gi0]\[0], __grad4\[gi0]\[1], __grad4\[gi0]\[2], __grad4\[gi0]\[3]),\n                x0\n            );\n        \}\n\n        float t1 = 0.6f - dot(x1, x1);\n        if (t1 < 0)\n        \{\n            n1 = 0.0f;\n        \}\n        else\n        \{\n            t1 *= t1;\n            n1 = t1 * t1 * dot(\n                float4(__grad4\[gi1]\[0], __grad4\[gi1]\[1], __grad4\[gi1]\[2], __grad4\[gi1]\[3]),\n                x1\n            );\n        \}\n\n        float t2 = 0.6f - dot(x2, x2);\n        if (t2 < 0)\n        \{\n            n2 = 0.0f;\n        \}\n        else\n        \{\n            t2 *= t2;\n            n2 = t2 * t2 * dot(\n                float4(__grad4\[gi2]\[0], __grad4\[gi2]\[1], __grad4\[gi2]\[2], __grad4\[gi2]\[3]),\n                x2\n            );\n        \}\n\n        float t3 = 0.6f - dot(x3, x3);\n        if (t3 < 0)\n        \{\n            n3 = 0.0f;\n        \}\n        else\n        \{\n            t3 *= t3;\n            n3 = t3 * t3 * dot(\n                float4(__grad4\[gi3]\[0], __grad4\[gi3]\[1], __grad4\[gi3]\[2], __grad4\[gi3]\[3]),\n                x3\n            );\n        \}\n\n        float t4 = 0.6f - dot(x4, x4);\n        if (t4 < 0)\n        \{\n            n4 = 0.0f;\n        \}\n        else \{\n            t4 *= t4;\n            n4 = t4 * t4 * dot(\n                float4(__grad4\[gi4]\[0], __grad4\[gi4]\[1], __grad4\[gi4]\[2], __grad4\[gi4]\[3]),\n                x4\n            );\n        \}\n\n        return 27.0f * (n0 + n1 + n2 + n3 + n4);\n    \}\n\n\n    //\n    // Use the perlin simplex noise\n    //\n\n\n    /**\n     * fBM noise.\n     *\n     * @arg position: The position to seed the noise.\n     *\n     * @returns: The noise value in the range \[-1, 1].\n     */\n    float fractalBrownianMotionNoise(const float4 &position)\n    \{\n        float output = 0.0f;\n        float frequency = _lacunarity;\n        float amplitude = 1.0f;\n        float denom = 0.0f;\n        float4 translation;\n        float4 scale;\n\n        for (int octave=0; octave < _octaves; octave++)\n        \{\n            const float octaveFraction = octave / _octaves;\n            scale = (\n                (_highFrequencyScale * octaveFraction)\n                + (_lowFrequencyScale * (1.0f - octaveFraction))\n            );       \n            translation = (\n                (_highFrequencyTranslation * octaveFraction)\n                + (_lowFrequencyTranslation * (1.0f - octaveFraction))\n            );\n\n            output += amplitude * perlinSimplexNoise(\n                (position * scale + translation) * frequency / _size\n            );\n\n            frequency *= _lacunarity;\n            denom += amplitude;\n            amplitude *= _gain;\n        \}\n\n        return pow(fabs(output / denom), 1.0f / _gamma);\n    \}\n\n\n    /**\n     * Turbulence noise.\n     *\n     * @arg position: The position to seed the noise.\n     *\n     * @returns: The noise value in the range \[0, 1].\n     */\n    float turbulenceNoise(const float4 &position)\n    \{\n        float output = 0.0f;\n        float frequency = _lacunarity;\n        float amplitude = 1.0f;\n        float denom = 0.0f;\n        float4 translation;\n        float4 scale;\n\n        for (int octave=0; octave < _octaves; octave++)\n        \{\n            const float octaveFraction = octave / _octaves;\n            scale = (\n                (_highFrequencyScale * octaveFraction)\n                + (_lowFrequencyScale * (1.0f - octaveFraction))\n            );       \n            translation = (\n                (_highFrequencyTranslation * octaveFraction)\n                + (_lowFrequencyTranslation * (1.0f - octaveFraction))\n            );\n\n            output += fabs(\n                amplitude * perlinSimplexNoise(\n                    (position * scale + translation) * frequency / _size\n                )\n            );\n\n            frequency *= _lacunarity;\n            denom += amplitude;\n            amplitude *= _gain;\n        \}\n\n        return pow(output / denom, 1.0f / _gamma);\n    \}\n\n\n    /**\n     * Create a ray out of the camera. It will be either a standard ray,\n     * a latlong ray, or a ray that will result in depth of field.\n     *\n     * @arg seed: The seed to use in randomization.\n     * @arg pixelLocation: The x, and y locations of the pixel.\n     * @arg rayOrigin: The location to store the origin of the new ray.\n     * @arg rayDirection: The location to store the direction of the new\n     *     ray.\n     */\n    void getCameraRay(\n            const float2 &seed,\n            const float2 &pixelLocation,\n            float3 &rayOrigin,\n            float3 &rayDirection)\n    \{\n        const float2 uvCoordinates = pixelsToUV(\n            pixelLocation + random(seed),\n            float2(_formatWidth, _formatHeight)\n        );\n        if (_latLong)\n        \{\n            createLatLongCameraRay(\n                _cameraWorldMatrix,\n                uvCoordinates,\n                rayOrigin,\n                rayDirection\n            );\n        \}\n        else if (_depthOfFieldEnabled)\n        \{\n            createCameraRay(\n                _cameraWorldMatrix,\n                __inverseCameraProjectionMatrix,\n                uvCoordinates,\n                __aperture,\n                _focalDistance,\n                seed,\n                rayOrigin,\n                rayDirection\n            );\n        \}\n        else\n        \{\n            createCameraRay(\n                _cameraWorldMatrix,\n                __inverseCameraProjectionMatrix,\n                uvCoordinates,\n                rayOrigin,\n                rayDirection\n            );\n        \}\n    \}\n\n\n    /**\n     * Compute a noise value.\n     *\n     * @arg pos: The x, and y location we are currently processing.\n     */\n    void process(int2 pos)\n    \{\n        float2 pixelLocation = float2(pos.x, pos.y);\n        SampleType(seeds) seedPixel = seeds();\n        float2 seed0 = float2(seedPixel.x, seedPixel.y) + RAND_CONST_0 * pixelLocation;\n        float2 seed1 = float2(seedPixel.z, seedPixel.w) + RAND_CONST_1 * pixelLocation;\n\n        float4 resultPixel = float4(0.0f);\n\n        const float sampleStep = (_depthRamp.w - _depthRamp.x) / (float) _samplesPerRay;\n\n        for (int path=1; path <= _raysPerPixel; path++)\n        \{\n            // Generate a ray from the camera\n            float3 rayOrigin;\n            float3 rayDirection;\n            getCameraRay(\n                seed0,\n                pixelLocation,\n                rayOrigin,\n                rayDirection\n            );\n\n            // Set the depth to the start of the depth ramp and add a random offset\n            // to eliminate layer lines\n            float depth = _depthRamp.x;\n            rayOrigin += depth * rayDirection + _translation;\n\n            float invertedLastSample = 1.0f;\n            for (int step=0; step < _samplesPerRay; step++)\n            \{\n                depth += sampleStep;\n                rayOrigin += rayDirection * sampleStep;\n\n                // Get the noise value based on which type of noise we are using\n                const float4 samplePosition4d = float4(\n                    rayOrigin.x,\n                    rayOrigin.y,\n                    rayOrigin.z,\n                    0.0f\n                );\n\n                // Apply the scaling specified by the depth ramp\n                float ramp;\n                if (depth < _depthRamp.y)\n                \{\n                    ramp = (depth - _depthRamp.y) / (_depthRamp.y - _depthRamp.x) + 1.0f;\n                \}\n                else if (depth >= _depthRamp.y && depth <= _depthRamp.z)\n                \{\n                    ramp = 1.0f;\n                \}\n                else\n                \{\n                    ramp = (_depthRamp.w - depth) / (_depthRamp.w - _depthRamp.z);\n                \}\n\n                // Compute the noise value at this position\n                float noiseValue = _density * ramp;\n                if (_noiseType == FBM_NOISE)\n                \{\n                    noiseValue *= fractalBrownianMotionNoise(samplePosition4d);\n                \}\n                else\n                \{\n                    noiseValue *= turbulenceNoise(samplePosition4d);\n                \}\n\n                // Over the noise values\n                resultPixel += noiseValue * invertedLastSample;\n                invertedLastSample *= 1.0f - noiseValue;\n            \}\n\n            const float2 lastSeed = seed0;\n            seed0 = RAND_CONST_2 * float2(seed1.y, seed1.x) + RAND_CONST_3 * path;\n            seed1 = RAND_CONST_4 * lastSeed + RAND_CONST_5 * path;\n        \}\n\n        dst() = resultPixel / float(_raysPerPixel);\n    \}\n\};\n"
  rebuild ""
  "FogKernel_Focal Length" {{parent.DummyCam.focal}}
  "FogKernel_Horizontal Aperture" {{parent.DummyCam.haperture}}
  "FogKernel_Near Plane" {{parent.DummyCam.near}}
  "FogKernel_Far Plane" {{parent.DummyCam.far}}
  "group_FogKernel_Camera World Matrix" 1
  "FogKernel_Camera World Matrix" {
      {{parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix}}
      {{parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix}}
      {{parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix}}
      {{parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix}}
    }
  "FogKernel_Focal Distance" {{parent.DummyCam.focal_point}}
  FogKernel_fstop {{parent.DummyCam.fstop}}
  "FogKernel_Enable Depth Of Field" {{parent.depth_of_field}}
  "FogKernel_Output LatLong" {{parent.latlong}}
  "FogKernel_Screen Width" {{"proxy? input0.width*proxy_scale: input0.width"}}
  "FogKernel_Screen Height" {{"proxy? input0.height * proxy_scale : input0.height"}}
  "FogKernel_Rays Per Pixel" {{parent.rays_per_pixel}}
  FogKernel_Density {{"parent.density * 50 / parent.samples_per_ray"}}
  "FogKernel_Samples Per Ray" {{parent.samples_per_ray}}
  "FogKernel_Sample Depth Ramp" {{parent.Keyer1.range.A} {parent.Keyer1.range.B} {parent.Keyer1.range.C} {parent.Keyer1.range.D}}
  FogKernel_Size {{parent.size}}
  "FogKernel_Noise Type" {{parent.type}}
  FogKernel_Translation {{-parent.translation-8} {-parent.translation} {-parent.translation}}
  FogKernel_Octaves {{parent.octaves}}
  FogKernel_Lacunarity {{parent.lacunarity}}
  FogKernel_Gain {{parent.gain}}
  FogKernel_Gamma {{parent.gamma}}
  "FogKernel_Low Frequency Scale" {{parent.low_frequency_scale} {parent.low_frequency_scale} {parent.low_frequency_scale} {parent.low_frequency_scale}}
  "FogKernel_High Frequency Scale" {{parent.high_frequency_scale} {parent.high_frequency_scale} {parent.high_frequency_scale} {parent.high_frequency_scale}}
  "FogKernel_Low Frequency Translation" {{"parent.low_frequency_translation + parent.low_frequency_evolve * frame / 100"} {"parent.low_frequency_translation + parent.low_frequency_evolve * frame / 100"} {"parent.low_frequency_translation + parent.low_frequency_evolve * frame / 100"} {"parent.low_frequency_translation + parent.low_frequency_evolve * frame / 100"}}
  "FogKernel_High Frequency Translation" {{"parent.high_frequency_translation + parent.high_frequency_evolve * frame / 100"} {"parent.high_frequency_translation + parent.high_frequency_evolve * frame / 100"} {"parent.high_frequency_translation + parent.high_frequency_evolve * frame / 100"} {"parent.high_frequency_translation + parent.high_frequency_evolve * frame / 100"}}
  rebuild_finalise ""
  name BlinkScript2
  xpos 1891
  ypos 1151
 }
 Switch {
  inputs 2
  which {{"\[exists parent.input1]"}}
  name Switch1
  xpos 1891
  ypos 1227
 }
 TimeBlur {
  divisions 5
  shutteroffset centred
  shuttercustomoffset 0
  name TimeBlur1
  xpos 1891
  ypos 1253
  disable {{!parent.enable_motion_blur}}
 }
 Merge2 {
  inputs 2
  operation stencil
  bbox B
  name Merge2
  xpos 1891
  ypos 1357
  disable {{1-parent.holdout_mode}}
 }
 Switch {
  inputs 2
  which {{"parent.holdout_mode == 2"}}
  name Switch3
  xpos 1891
  ypos 1585
 }
 Switch {
  inputs 2
  which {{parent.output_deep}}
  name Switch4
  xpos 1891
  ypos 1645
 }
 Output {
  name Output1
  xpos 1891
  ypos 1700
 }
 Input {
  inputs 0
  name camera
  xpos 1620
  ypos 894
 }
 Camera {
  projection_mode {{"\[expression \[value the_cam]projection_mode(\[value the_frame])]"}}
  focal {{"\[expression \[value the_cam]focal(\[value the_frame])]"}}
  haperture {{"\[expression \[value the_cam]haperture(\[value the_frame])]"}}
  vaperture {{"\[expression \[value the_cam]vaperture(\[value the_frame])]"}}
  near {{"\[expression \[value the_cam]near(\[value the_frame])]"}}
  far {{"\[expression \[value the_cam]far(\[value the_frame])]"}}
  win_translate {{"\[expression \[value the_cam]win_translate.u(\[value the_frame])]"} {"\[expression \[value the_cam]win_translate.v(\[value the_frame])]"}}
  win_scale {{"\[expression \[value the_cam]win_scale.u(\[value the_frame])]"} {"\[expression \[value the_cam]win_scale.v(\[value the_frame])]"}}
  winroll {{"\[expression \[value the_cam]winroll(\[value the_frame])]"}}
  focal_point {{"\[expression \[value the_cam]focal_point(\[value the_frame])]"}}
  fstop {{"\[expression \[value the_cam]fstop(\[value the_frame])]"}}
  name DummyCam
  help "DummyCam by Adrian Pueyo\n\nCamera that apart from the matrices also grabs all the \"Projection\" values from the upstream camera that it's connected to. Turns into a default Camera if no Camera connected. Can also be used inside of groups and gizmos, as many levels deep as you want :D All using live and super fast TCL.\n\nUpdated v1.1: Now grabs the correct frame too (thanks Erwan Leroy for the idea).\n\nUpdated v1.3: Now accepts Nuke13's Camera3\n\nadrianpueyo.com, 2019-2021"
  onCreate "n = nuke.thisNode()\nfor k in \[\"projection_mode\",\"focal\",\"haperture\",\"vaperture\",\"near\",\"far\",\"win_translate\",\"win_scale\",\"winroll\",\"focal_point\",\"fstop\"]:\n    n\[k].setFlag(0x0000000010000000)"
  xpos 1630
  ypos 994
  addUserKnob {20 DummyCam l Defaults}
  addUserKnob {43 the_cam +INVISIBLE}
  the_cam "\[\n#DummyCam v1.3 - Updated 5 May 2021.\nset starting_point \"this.input0\"\nset default \"this.d_\"\n\n# If cam has no inputs, return the default.\nif \{\[exists \$starting_point]\} \{\n    set x \[node \$starting_point]\n\} \{ \n    return \$default\n\}\n\nset finished 0\nwhile \{\$finished != 1\} \{\n\n    # First look for a Cam or Input or topnode.\n    while \{\[class \$x] != \"Camera4\" && \[class \$x] != \"Camera3\" && \[class \$x] != \"Camera2\" && \[class \$x] != \"Camera\" && \[class \$x] != \"Input\" && \$x != \[topnode \$x]\} \{\n        set x \[node \$x.input0]\n    \}\n\n    # Then, check if node is a cam (and return), and otherwise, if it's an input, see if the parent exists and move to it.\n    if \{\[class \$x]==\"Camera4\"||\[class \$x]==\"Camera3\"||\[class \$x]==\"Camera2\"||\[class \$x]==\"Camera\"\} \{\n        set x \[append x \".\"]\n        return \$x\n    \} \{ \n        if \{ \[class \$x]==\"Input\" \} \{ \n            set inp \"\$x.parent.input\"\n            set inputNum \[value \$x.number]\n            set inp \[append inp \$inputNum]\n            if \{ \[exists \$inp] \} \{\n                set x \[node \$inp]\n            \} \{ \n                set finished 1\n            \}\n        \} \{ \n            set finished 1\n        \}\n    \}\n\}\nreturn \$default\n]"
  addUserKnob {43 the_frame +INVISIBLE}
  the_frame "\[\nset the_camera \[string trimright \[value the_cam] .]\nif \{\[exists \$the_camera]\} \{\n    return \[value \$the_camera.frame]\n\} \{ \n    return \[frame]\n\}\n]"
  addUserKnob {4 d_projection_mode l projection M {perspective orthographic uv spherical ""}}
  addUserKnob {7 d_focal l "focal length" R 0 100}
  d_focal 50
  addUserKnob {7 d_haperture l "horiz aperture" R 0 50}
  d_haperture 24.576
  addUserKnob {7 d_vaperture l "vert aperture" R 0 50}
  d_vaperture 18.672
  addUserKnob {7 d_near l near R 0 10}
  d_near 0.1
  addUserKnob {7 d_far l far R 0 10000}
  d_far 10000
  addUserKnob {30 d_win_translate l "window translate"}
  addUserKnob {30 d_win_scale l "window scale"}
  d_win_scale {1 1}
  addUserKnob {7 d_winroll l "window roll" R 0 45}
  addUserKnob {7 d_focal_point l "focal distance" R 0 10}
  d_focal_point 2
  addUserKnob {7 d_fstop l fstop R 0 30}
  d_fstop 16
  addUserKnob {26 version l " " t "Updated 5 May 2021" T "<span style=\"color:#666\"><br/><b>DummyCam v1.3</b> - <a href=\"http://www.adrianpueyo.com\" style=\"color:#666;text-decoration: none;\">adrianpueyo.com</a>, 2019-2021</span>"}
 }
end_group
