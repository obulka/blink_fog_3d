#! /usr/local/Nuke13.2v2/libnuke-13.2.2.so -nx
version 13.2 v2
define_window_layout_xml {<?xml version="1.0" encoding="UTF-8"?>
<layout version="1.0">
    <window x="1948" y="14" w="1892" h="1048" screen="0">
        <splitter orientation="1">
            <split size="40"/>
            <dock id="" hideTitles="1" activePageId="Toolbar.1">
                <page id="Toolbar.1"/>
            </dock>
            <split size="1229" stretch="1"/>
            <splitter orientation="2">
                <split size="590"/>
                <dock id="" activePageId="Viewer.1" focus="true">
                    <page id="Viewer.1"/>
                </dock>
                <split size="415"/>
                <dock id="" activePageId="DAG.1">
                    <page id="DAG.1"/>
                    <page id="Curve Editor.1"/>
                    <page id="DopeSheet.1"/>
                    <page id="DAG.2"/>
                    <page id="DAG.3"/>
                </dock>
            </splitter>
            <split size="615"/>
            <dock id="" activePageId="Properties.1">
                <page id="Properties.1"/>
                <page id="uk.co.thefoundry.backgroundrenderview.1"/>
            </dock>
        </splitter>
    </window>
</layout>
}
Root {
 inputs 0
 name /home/ob1/software/nuke/dev/fog/src/examples/test.nk
 frame 14
 format "2048 1556 0 0 2048 1556 1 2K_Super_35(full-ap)"
 proxy_type scale
 proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
 colorManagement OCIO
 OCIO_config aces_1.2
 defaultViewerLUT "OCIO LUTs"
 workingSpaceLUT scene_linear
 monitorLut ACES/sRGB
 monitorOutLUT "sRGB (ACES)"
 int8Lut matte_paint
 int16Lut texture_paint
 logLut compositing_log
 floatLut scene_linear
}
CheckerBoard2 {
 inputs 0
 format "2048 1024 0 0 2048 1024 1 2K_LatLong"
 name CheckerBoard1
 xpos 1056
 ypos -238
}
Camera3 {
 inputs 0
 translate {0 0 {curve x1 0.7799999714 x100 -1}}
 focal 30
 name Camera2
 xpos -572
 ypos 59
}
Group {
 inputs 0
 name TX_Fog
 help "TX_Fog\nby Tomas Lefebvre\n\n/// v2.0"
 tile_color 0xccccccff
 xpos -409
 ypos -157
 addUserKnob {20 Settings}
 addUserKnob {26 noiseSetupDiv l "<b>noise basic settings</b>"}
 addUserKnob {20 noiseTabBegin l "" +STARTLINE n -2}
 addUserKnob {20 Noise}
 addUserKnob {41 size l x/ysize T Noise0.size}
 addUserKnob {41 zoffset l z T Noise0.zoffset}
 addUserKnob {41 octaves T Noise0.octaves}
 addUserKnob {41 nyquist l "clip at Nyquist limit" -STARTLINE T Noise0.nyquist}
 addUserKnob {41 lacunarity T Noise0.lacunarity}
 addUserKnob {41 gain T Noise0.gain}
 addUserKnob {41 gamma T Noise0.gamma}
 addUserKnob {20 "" l Transform}
 addUserKnob {41 transform T Noise0.transform}
 addUserKnob {41 translate T Noise0.translate}
 addUserKnob {41 rotate T Noise0.rotate}
 addUserKnob {41 scale T Noise0.scale}
 addUserKnob {41 skew +INVISIBLE T Noise0.skew}
 addUserKnob {41 center T Noise0.center}
 addUserKnob {41 xrotate T Noise0.xrotate}
 addUserKnob {41 yrotate T Noise0.yrotate}
 addUserKnob {20 "" l Color}
 addUserKnob {41 color T Noise0.color}
 addUserKnob {6 color_rampBT l ramp +STARTLINE}
 addUserKnob {12 color_p0 l p0}
 color_p0 {100 500}
 addUserKnob {18 color_color2 l color}
 color_color2 {1 0 0}
 addUserKnob {6 color_color2_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {12 color_p1 l p1}
 color_p1 {2000 1500}
 addUserKnob {20 noiseTabEnd l "" +STARTLINE n -3}
 addUserKnob {26 deadSpace1 l "" +STARTLINE T "  "}
 addUserKnob {3 subdivisions}
 subdivisions 10
 addUserKnob {22 update -STARTLINE T "from __future__ import with_statement\nthisNode = nuke.thisNode()\nsubdivs = int(thisNode\['subdivisions'].value())\nresolution = int(thisNode\['resolution'].value())\n\nwith thisNode :\n\n\tnAll = nuke.allNodes()\n\n\tfor n in nAll:\n    \t\tif n.name().split('_')\[0] == 'sub' :\n        \t\t\tnuke.delete(n)\n\tfor j in range(subdivs):\n    \t\ti = j + 1\n\n    \t\t##Noise\n    \t\tnoiseKnobs = \['octaves', 'nyquist', 'lacunarity', 'gain', 'gamma', 'translate', 'rotate', 'skew', 'center', 'ramp', 'color', 'xrotate', 'yrotate']\n    \t\tnoise = nuke.nodes.Noise(xpos = nuke.toNode('Noise0').xpos()+i*150,\n                    \t                          \typos =nuke.toNode('Noise0').ypos())\n    \t\tnoise.setName('sub_' + str(i) + '_Noise')\n    \t\tnoise\['color'].setValue(\[0,0,0,0])\n    \t\tfor k in noiseKnobs :\n        \t\t\tnoise\[k].setExpression('parent.Noise0.' + str(k))\n    \t\tnoise\['size'].setValue(\[0,0])\n    \t\tnoise\['size'].setExpression('parent.Noise0.size.0',0)\n    \t\tnoise\['size'].setExpression('parent.Noise0.size.1',1)\n    \t\tnoise\['scale'].setValue(\[0,0])\n    \t\tnoise\['scale'].setExpression('parent.Noise0.scale.w',0)\n    \t\tnoise\['scale'].setExpression('parent.Noise0.scale.h',1)\n    \t\tnoise\['zoffset'].setExpression('parent.Noise0.zoffset+' + str(i) + '*parent.variancy')\n    \t\tnoise\['xrotate'].setExpression('parent.Noise0.xrotate')\n    \t\tnoise\['yrotate'].setExpression('parent.Noise0.yrotate')\n    \t\tnoise.setInput(0,nuke.toNode('Base'))\n\t\n    \t\t##Ramp\n    \t\tunpRamp = nuke.nodes.Unpremult(xpos = nuke.toNode('Noise0').xpos()+i*150,\n                    \t                                         \typos =nuke.toNode('Unpremult0').ypos())\n    \t\tunpRamp.setName('sub_' + str(i) + '_Unpremult')\n    \t\tunpRamp\['disable'].setExpression('!parent.color_rampBT')\n    \t\tunpRamp.setInput(0,noise)\n\t\n    \t\tramp = nuke.nodes.Ramp(xpos = nuke.toNode('Noise0').xpos()+i*150,\n                    \t                          \typos = nuke.toNode('Ramp0').ypos())\n    \t\tramp.setName('sub_' + str(i) + '_Ramp')\n    \t\tramp\['disable'].setExpression('!parent.color_rampBT')\n    \t\tramp\['p0'].setExpression('parent.color_p0')\n    \t\tramp\['output'].setValue('rgb')\n    \t\tramp\['color'].setValue(\[0,0,0,0])\n    \t\tramp\['color'].setExpression('parent.color_color2.r',0)\n    \t\tramp\['color'].setExpression('parent.color_color2.g',1)\n    \t\tramp\['color'].setExpression('parent.color_color2.b',2)\n    \t\tramp\['p1'].setExpression('parent.color_p1')\n    \t\tramp.setInput(0,unpRamp)\n\t\n\t    \tpreRamp = nuke.nodes.Premult(xpos = nuke.toNode('Noise0').xpos()+i*150,\n                    \t                                        \typos =nuke.toNode('Premult0').ypos())\n    \t\tpreRamp.setName('sub_' + str(i) + '_premult')\n    \t\tpreRamp\['disable'].setExpression('!parent.color_rampBT')\n    \t\tpreRamp.setInput(0,ramp)\n\t\n\n    \t\t##Blur\n    \t\tblur = nuke.nodes.Blur(xpos = nuke.toNode('Noise0').xpos()+i*150,\n                    \t                     \typos = nuke.toNode('Blur0').ypos())\n    \t\tblur.setName('sub_' + str(i) + '_Blur')\n    \t\tblur\['channel'].setValue('rgba')\n    \t\tblur\['size'].setValue(\[10,20])\n    \t\tblur\['size'].setExpression('parent.Blur0.size.w',0)\n    \t\tblur\['size'].setExpression('parent.Blur0.size.h',1)\n    \t\tblur.setInput(0,preRamp)\n\t\n\n    \t\t##Edge smooth\n    \t\tsmoothEdge = nuke.nodes.Multiply(xpos = nuke.toNode('Noise0').xpos()+i*150,\n                  \t\t\t                      \typos =nuke.toNode('Multiply0').ypos())\n    \t\tsmoothEdge.setName('sub_' + str(i) + '_Multiply_SEdges')\n    \t\tsmoothEdge\['channel'].setValue('rgba')\n    \t\tsmoothEdge\['value'].setValue(0)\n    \t\tsmoothEdge\['invert_mask'].setValue(True)\n    \t\tsmoothEdge\['disable'].setExpression('!parent.softEdges')\n    \t\tsmoothEdge.setInput(0,blur)\n    \t\tsmoothEdge.setInput(1, nuke.toNode('GradeEdge'))\n    \t\n    \t\t##All the ramps\n    \t\tdecay_x = nuke.nodes.Ramp(xpos = nuke.toNode('Noise0').xpos()+i*150,\n                    \t                               \typos =nuke.toNode('Ramp_X0').ypos())\n    \t\tdecay_x.setName('sub_' + str(i) + '_Ramp_x')\n    \t\tdecay_x\['type'].setValue('smooth')\n    \t\tdecay_x\['color'].setValue(0)\n    \t\tdecay_x\['disable'].setExpression('!parent.decay_XBT')\n    \t\tdecay_x\['p0'].setValue(\[100,100])\n    \t\tdecay_x\['p0'].setExpression('(parent.decay_Xmax==0?1:parent.decay_Xmax)*20.48',0)\n    \t\tdecay_x\['p1'].setValue(\[100,100])\n    \t\tdecay_x\['p1'].setExpression('(parent.decay_Xmin>=parent.decay_Xmax?parent.decay_Xmax-1:parent.decay_Xmin)*20.48',0)\n    \t\tdecay_x.setInput(0,smoothEdge)\n\t\t\n    \t\tdecayx = nuke.nodes.Ramp(xpos = nuke.toNode('Noise0').xpos()+i*150,\n                                        \t           \typos =nuke.toNode('RampX0').ypos())\n    \t\tdecayx.setName('sub_' + str(i) + '_Rampx')\n    \t\tdecayx\['type'].setValue('smooth')\n    \t\tdecayx\['color'].setValue(0)\n    \t\tdecayx\['disable'].setExpression('!parent.decayXBT')\n    \t\tdecayx\['p0'].setValue(\[100,100])\n    \t\tdecayx\['p0'].setExpression('2048-(parent.decayXmax==0?1:parent.decayXmax)*20.48',0)\n    \t\tdecayx\['p1'].setValue(\[100,100])\n    \t\tdecayx\['p1'].setExpression('2048-(parent.decayXmin>=parent.decayXmax?parent.decayXmax-1:parent.decayXmin)*20.48',0)\n    \t\tdecayx.setInput(0,decay_x)\n\t\t\n    \t\tdecay_y = nuke.nodes.Ramp(xpos = nuke.toNode('Noise0').xpos()+i*150,\n                    \t                               \typos =nuke.toNode('Ramp_Y0').ypos())\n    \t\tdecay_y.setName('sub_' + str(i) + '_Ramp_y')\n    \t\tdecay_y\['type'].setValue('smooth')\n    \t\tdecay_y\['color'].setValue(0)\n    \t\tdecay_y\['disable'].setExpression('!parent.decay_YBT')\n    \t\tdecay_y\['p0'].setExpression('(parent.decay_Ymax==0?1:parent.decay_Ymax)*20.48',1)\n    \t\tdecay_y\['p1'].setExpression('(parent.decay_Ymin>=parent.decay_Ymax?parent.decay_Ymax-1:parent.decay_Ymin)*20.48',1)    \t\t\t\t\t\t\t\n\t\tdecay_y.setInput(0,decayx)\n\n\n\t    \tdecayy = nuke.nodes.Ramp(xpos = nuke.toNode('Noise0').xpos()+i*150,\n\t\t\t\typos =nuke.toNode('RampY0').ypos())\n\t    \tdecayy.setName('sub_' + str(i) + '_Rampy')\n\t    \tdecayy\['type'].setValue('smooth')\n\t    \tdecayy\['color'].setValue(0)\n\t    \tdecayy\['disable'].setExpression('!parent.decayYBT')\n\t    \tdecayy\['p0'].setExpression('2048-(parent.decayYmax==0?1:parent.decayYmax)*20.48',1)\n\t    \tdecayy\['p1'].setExpression('2048-(parent.decayYmin>=parent.decayYmax?parent.decayYmax-1:parent.decayYmin)*20.48',1)\n\t    \tdecayy.setInput(0,decay_y)\n\t\n\t    \tdecay_z = nuke.nodes.Dissolve(xpos = nuke.toNode('Noise0').xpos()+i*150,\n\t                                                       \typos =nuke.toNode('Dissolve_Z0').ypos())\n\t    \tdecay_z.setName('sub_' + str(i) + '_Dissolve_z')\n\t    \tdecay_z\['channel'].setValue('rgba')\n\t    \tdecay_z\['disable'].setExpression('!parent.decay_ZBT')\n\t    \tdecay_z\['which'].setExpression('parent.decay_Zmin>='+str(i)+'*100/'+str(subdivs)+'?1:parent.decay_Zmax<='+str(i)+'*100/'+str(subdivs)+'?0:1-('+str(i)+'*100/'+str(subdivs)+'-(parent.decay_Zmin>=parent.decay_Zmax?parent.decay_Zmax-0.01:parent.decay_Zmin))/(parent.decay_Zmax-(parent.decay_Zmin>=parent.decay_Zmax?parent.decay_Zmax-0.01:parent.decay_Zmin))')\n\t    \tdecay_z\['disable'].setExpression('!parent.decay_ZBT')\n    \t\tdecay_z.setInput(1,nuke.toNode('Base'))\n    \t\tdecay_z.setInput(0,decayy)\n\t\n\n\n \t   \t##Opacity\n    \t\tdissolve = nuke.nodes.Dissolve(xpos = nuke.toNode('Noise0').xpos()+i*150,\n                                        \t               \typos =nuke.toNode('Dissolve0').ypos())\n    \t\tdissolve.setName('sub_' + str(i) + '_Dissolve')\n    \t\tdissolve\['channel'].setValue('rgba')\n    \t\tdissolve\['which'].setExpression('parent.Dissolve0.which')\n    \t\tdissolve.setInput(1,decay_z)\n    \t\tdissolve.setInput(0,nuke.toNode('Base'))\n\t\t\n\n\t    \t##Card\n\t    \tcard = nuke.nodes.Card2(xpos = nuke.toNode('Noise0').xpos()+i*150,\n\t                                              \typos =nuke.toNode('Card0').ypos())\n\t    \tcard.setName('sub_' + str(i) + '_Card')\n\t    \tcard\['rows'].setExpression('parent.resolution')\n\t    \tcard\['columns'].setExpression('parent.resolution')\n\t    \tcard\['translate'].setValue(\[0,0,0.5-i*1/subdivs])\n\t    \tcard.setInput(0,dissolve)\n\n\n\n    \t\t##ProcGeo\n\t    \tproc = nuke.nodes.ProcGeo(xpos = nuke.toNode('Noise0').xpos()+i*150,\n                     \t                         \typos =nuke.toNode('ProcGeo0').ypos())\n    \t\tproc.setName('sub_' + str(i) + '_ProcGeo')\n    \t\tproc\['x_size'].setExpression('parent.dNoiseX')\n    \t\tproc\['x_offset'].setExpression('parent.dNoiseXoffset+' + str(i) + '*parent.dNoiseVariancy')\n    \t\tproc\['y_size'].setExpression('parent.dNoiseY')\n    \t\tproc\['y_offset'].setExpression('parent.dNoiseYoffset+' + str(i) + '*parent.dNoiseVariancy')\n    \t\tproc\['Octaves'].setExpression('parent.dNoiseOctaves')\n    \t\tproc\['Lacunarity'].setExpression('parent.dNoiseLacunarity')\n    \t\tproc\['Gain'].setExpression('parent.dNoiseGain')\n    \t\tproc\['Speed'].setExpression('parent.dNoiseSpeed')\n    \t\tproc\['disable'].setExpression('!parent.dNoise')\n    \t\tproc.setInput(0,card)\n    \t\tnuke.toNode('Scene_layers').setInput(i,proc)\n\n\n\n\n"}
 addUserKnob {3 resolution l "   resolution" -STARTLINE}
 resolution 10
 addUserKnob {26 noiseAdvSetupDiv l "<b>noise advance settings</b>"}
 addUserKnob {14 blurSize l "blur size" R 0 100}
 addUserKnob {6 softEdges l "soft edges" +STARTLINE}
 softEdges true
 addUserKnob {7 softEdgesSize l "  size" -STARTLINE R 0 300}
 softEdgesSize 200
 addUserKnob {7 opacity}
 opacity 1
 addUserKnob {7 variancy R 0 200}
 variancy 100
 addUserKnob {20 decayGroup l decay n 1}
 decayGroup 0
 addUserKnob {6 decay_XBT l -x +STARTLINE}
 addUserKnob {7 decay_Xmin l "  min" -STARTLINE R 0 100}
 addUserKnob {7 decay_Xmax l "  max" -STARTLINE R 0 100}
 decay_Xmax 25
 addUserKnob {6 decayXBT l " x" +STARTLINE}
 addUserKnob {7 decayXmin l "  min" -STARTLINE R 0 100}
 addUserKnob {7 decayXmax l "  max" -STARTLINE R 0 100}
 decayXmax 25
 addUserKnob {6 decay_YBT l -y +STARTLINE}
 addUserKnob {7 decay_Ymin l "  min" -STARTLINE R 0 100}
 addUserKnob {7 decay_Ymax l "  max" -STARTLINE R 0 100}
 decay_Ymax 25
 addUserKnob {6 decayYBT l " y" +STARTLINE}
 addUserKnob {7 decayYmin l "  min" -STARTLINE R 0 100}
 addUserKnob {7 decayYmax l "  max" -STARTLINE R 0 100}
 decayYmax 25
 addUserKnob {6 decay_ZBT l -z +STARTLINE}
 addUserKnob {7 decay_Zmin l "  min" -STARTLINE R 0 100}
 addUserKnob {7 decay_Zmax l "  max" -STARTLINE R 0 100}
 decay_Zmax 25
 addUserKnob {6 decayZBT l INVISIBLE +INVISIBLE +STARTLINE}
 addUserKnob {20 endGroup l decayEndGroup n -1}
 addUserKnob {20 cage n 1}
 cage 0
 addUserKnob {41 cube l cage T Cube1.cube}
 addUserKnob {13 cage_position l translate}
 addUserKnob {13 cage_rotation l rotate}
 addUserKnob {7 cage_scale l scale R 0 50}
 cage_scale 1
 addUserKnob {20 endGroup_1 l endGroup n -1}
 addUserKnob {20 displace n 1}
 displace 0
 addUserKnob {6 bend +STARTLINE}
 addUserKnob {7 bendX l x R -1 1}
 addUserKnob {7 bendY l y R -1 1}
 addUserKnob {26 noisetxt l "" +STARTLINE T " "}
 addUserKnob {6 dNoise l noise +STARTLINE}
 addUserKnob {7 dNoiseX l "x size" R 0 20}
 dNoiseX 2
 addUserKnob {7 dNoiseXoffset l "x offset" R 0 100}
 addUserKnob {7 dNoiseY l "y size" R 0 20}
 dNoiseY 2
 addUserKnob {7 dNoiseYoffset l "y offset" R 0 100}
 addUserKnob {7 dNoiseVariancy l variancy R 0 10}
 dNoiseVariancy 1
 addUserKnob {3 dNoiseOctaves l octaves}
 dNoiseOctaves 5
 addUserKnob {7 dNoiseLacunarity l lacunarity R 0 5}
 dNoiseLacunarity 5
 addUserKnob {7 dNoiseGain l gain R -1 1}
 addUserKnob {7 dNoiseSpeed l speed R 0 10}
 addUserKnob {20 endGroup_2 l endGroup n -1}
 addUserKnob {26 dummy1 l " " T " "}
 addUserKnob {26 credit l "v2.1 -  Tomas Lefebvre"}
}
 Constant {
  inputs 0
  channels rgb
  color {0 0 0 0}
  format "2048 2048 0 0 2048 2048 1 square_2K"
  name Base
  xpos -371
  ypos -473
 }
set N9a1ede0 [stack 0]
push $N9a1ede0
 Shuffle {
  alpha white
  name ShuffleEdge
  label "\[value in]"
  xpos -23
  ypos -456
 }
 Crop {
  box {0 0 2048 2048}
  softness {{parent.BlurEdge.size i}}
  reformat true
  crop false
  name CropEdge
  xpos -23
  ypos -374
 }
 Blur {
  channels alpha
  size {{parent.softEdgesSize i}}
  name BlurEdge
  label "\[value size]"
  xpos -23
  ypos -348
 }
 Grade {
  channels alpha
  blackpoint 0.15
  white_clamp true
  mix {{parent.BlurEdge.size/100 i}}
  name GradeEdge
  xpos -23
  ypos -290
 }
set N9a4f210 [stack 0]
push $N9a1ede0
 Noise {
  size {{parent.Noise0.size.0} {parent.Noise0.size.1}}
  zoffset {{parent.Noise0.zoffset+10*parent.variancy}}
  octaves {{parent.Noise0.octaves}}
  nyquist {{parent.Noise0.nyquist}}
  lacunarity {{parent.Noise0.lacunarity}}
  gain {{parent.Noise0.gain}}
  gamma {{parent.Noise0.gamma}}
  translate {{parent.Noise0.translate} {parent.Noise0.translate}}
  rotate {{parent.Noise0.rotate}}
  scale {{parent.Noise0.scale.w} {parent.Noise0.scale.h}}
  center {{parent.Noise0.center} {parent.Noise0.center}}
  xrotate {{parent.Noise0.xrotate}}
  yrotate {{parent.Noise0.yrotate}}
  ramp {{parent.Noise0.ramp}}
  color {{parent.Noise0.color} {parent.Noise0.color} {parent.Noise0.color} {parent.Noise0.color}}
  name sub_10_Noise
  xpos 236
  ypos -20
 }
 Unpremult {
  name sub_10_Unpremult
  xpos 236
  ypos 6
  disable {{!parent.color_rampBT}}
 }
 Ramp {
  output rgb
  p0 {{parent.color_p0} {parent.color_p0}}
  p1 {{parent.color_p1} {parent.color_p1}}
  color {{parent.color_color2.r} {parent.color_color2.g} {parent.color_color2.b} 0}
  name sub_10_Ramp
  xpos 236
  ypos 32
  disable {{!parent.color_rampBT}}
 }
 Premult {
  name sub_10_premult
  xpos 236
  ypos 58
  disable {{!parent.color_rampBT}}
 }
 Blur {
  channels rgba
  size {{parent.Blur0.size.w} {parent.Blur0.size.h}}
  name sub_10_Blur
  xpos 236
  ypos 107
 }
 Multiply {
  inputs 1+1
  channels rgba
  value 0
  invert_mask true
  name sub_10_Multiply_SEdges
  xpos 236
  ypos 210
  disable {{!parent.softEdges}}
 }
 Ramp {
  p0 {{(parent.decay_Xmax==0?1:parent.decay_Xmax)*20.48} 100}
  p1 {{(parent.decay_Xmin>=parent.decay_Xmax?parent.decay_Xmax-1:parent.decay_Xmin)*20.48} 100}
  type smooth
  color 0
  name sub_10_Ramp_x
  xpos 236
  ypos 271
  disable {{!parent.decay_XBT}}
 }
 Ramp {
  p0 {{2048-(parent.decayXmax==0?1:parent.decayXmax)*20.48} 100}
  p1 {{2048-(parent.decayXmin>=parent.decayXmax?parent.decayXmax-1:parent.decayXmin)*20.48} 100}
  type smooth
  color 0
  name sub_10_Rampx
  xpos 236
  ypos 297
  disable {{!parent.decayXBT}}
 }
 Ramp {
  p0 {100 {(parent.decay_Ymax==0?1:parent.decay_Ymax)*20.48}}
  p1 {100 {(parent.decay_Ymin>=parent.decay_Ymax?parent.decay_Ymax-1:parent.decay_Ymin)*20.48}}
  type smooth
  color 0
  name sub_10_Ramp_y
  xpos 236
  ypos 327
  disable {{!parent.decay_YBT}}
 }
 Ramp {
  p0 {100 {2048-(parent.decayYmax==0?1:parent.decayYmax)*20.48}}
  p1 {100 {2048-(parent.decayYmin>=parent.decayYmax?parent.decayYmax-1:parent.decayYmin)*20.48}}
  type smooth
  color 0
  name sub_10_Rampy
  xpos 236
  ypos 353
  disable {{!parent.decayYBT}}
 }
 Dissolve {
  inputs 2
  channels rgba
  which {{parent.decay_Zmin>=10*100/10?1:parent.decay_Zmax<=10*100/10?0:1-(10*100/10-(parent.decay_Zmin>=parent.decay_Zmax?parent.decay_Zmax-0.01:parent.decay_Zmin))/(parent.decay_Zmax-(parent.decay_Zmin>=parent.decay_Zmax?parent.decay_Zmax-0.01:parent.decay_Zmin))}}
  name sub_10_Dissolve_z
  xpos 236
  ypos 407
  disable {{!parent.decay_ZBT}}
 }
push $N9a1ede0
 Dissolve {
  inputs 2
  channels rgba
  which {{parent.Dissolve0.which}}
  name sub_10_Dissolve
  xpos 236
  ypos 577
 }
set N9af4760 [stack 0]
 Card2 {
  rows {{parent.resolution}}
  columns {{parent.resolution}}
  translate {0 0 -0.5}
  control_points {3 3 3 6 

1 {-0.5 -0.5 0} 1 {0.1666666865 0 0} 1 {0 0 0} 1 {0 0.1666666865 0} 1 {0 0 0} 1 {0 0 0} 
1 {0 -0.5 0} 1 {0.1666666716 0 0} 1 {-0.1666666716 0 0} 1 {0 0.1666666865 0} 1 {0 0 0} 1 {0.5 0 0} 
1 {0.5 -0.5 0} 1 {0 0 0} 1 {-0.1666666865 0 0} 1 {0 0.1666666865 0} 1 {0 0 0} 1 {1 0 0} 
1 {-0.5 0 0} 1 {0.1666666865 0 0} 1 {0 0 0} 1 {0 0.1666666716 0} 1 {0 -0.1666666716 0} 1 {0 0.5 0} 
1 {0 0 0} 1 {0.1666666716 0 0} 1 {-0.1666666716 0 0} 1 {0 0.1666666716 0} 1 {0 -0.1666666716 0} 1 {0.5 0.5 0} 
1 {0.5 0 0} 1 {0 0 0} 1 {-0.1666666865 0 0} 1 {0 0.1666666716 0} 1 {0 -0.1666666716 0} 1 {1 0.5 0} 
1 {-0.5 0.5 0} 1 {0.1666666865 0 0} 1 {0 0 0} 1 {0 0 0} 1 {0 -0.1666666865 0} 1 {0 1 0} 
1 {0 0.5 0} 1 {0.1666666716 0 0} 1 {-0.1666666716 0 0} 1 {0 0 0} 1 {0 -0.1666666865 0} 1 {0.5 1 0} 
1 {0.5 0.5 0} 1 {0 0 0} 1 {-0.1666666865 0 0} 1 {0 0 0} 1 {0 -0.1666666865 0} 1 {1 1 0} }
  name sub_10_Card
  xpos 236
  ypos 779
 }
 ProcGeo {
  x_size {{parent.dNoiseX}}
  x_offset {{parent.dNoiseXoffset+10*parent.dNoiseVariancy}}
  y_size {{parent.dNoiseY}}
  y_offset {{parent.dNoiseYoffset+10*parent.dNoiseVariancy}}
  Octaves {{parent.dNoiseOctaves}}
  Lacunarity {{parent.dNoiseLacunarity}}
  Gain {{parent.dNoiseGain}}
  Speed {{parent.dNoiseSpeed}}
  name sub_10_ProcGeo
  xpos 236
  ypos 805
  disable {{!parent.dNoise}}
 }
push $N9a1ede0
push $N9a4f210
push $N9a1ede0
 Noise {
  size {{parent.Noise0.size.0} {parent.Noise0.size.1}}
  zoffset {{parent.Noise0.zoffset+9*parent.variancy}}
  octaves {{parent.Noise0.octaves}}
  nyquist {{parent.Noise0.nyquist}}
  lacunarity {{parent.Noise0.lacunarity}}
  gain {{parent.Noise0.gain}}
  gamma {{parent.Noise0.gamma}}
  translate {{parent.Noise0.translate} {parent.Noise0.translate}}
  rotate {{parent.Noise0.rotate}}
  scale {{parent.Noise0.scale.w} {parent.Noise0.scale.h}}
  center {{parent.Noise0.center} {parent.Noise0.center}}
  xrotate {{parent.Noise0.xrotate}}
  yrotate {{parent.Noise0.yrotate}}
  ramp {{parent.Noise0.ramp}}
  color {{parent.Noise0.color} {parent.Noise0.color} {parent.Noise0.color} {parent.Noise0.color}}
  name sub_9_Noise
  xpos 86
  ypos -20
 }
 Unpremult {
  name sub_9_Unpremult
  xpos 86
  ypos 6
  disable {{!parent.color_rampBT}}
 }
 Ramp {
  output rgb
  p0 {{parent.color_p0} {parent.color_p0}}
  p1 {{parent.color_p1} {parent.color_p1}}
  color {{parent.color_color2.r} {parent.color_color2.g} {parent.color_color2.b} 0}
  name sub_9_Ramp
  xpos 86
  ypos 32
  disable {{!parent.color_rampBT}}
 }
 Premult {
  name sub_9_premult
  xpos 86
  ypos 58
  disable {{!parent.color_rampBT}}
 }
 Blur {
  channels rgba
  size {{parent.Blur0.size.w} {parent.Blur0.size.h}}
  name sub_9_Blur
  xpos 86
  ypos 107
 }
 Multiply {
  inputs 1+1
  channels rgba
  value 0
  invert_mask true
  name sub_9_Multiply_SEdges
  xpos 86
  ypos 210
  disable {{!parent.softEdges}}
 }
 Ramp {
  p0 {{(parent.decay_Xmax==0?1:parent.decay_Xmax)*20.48} 100}
  p1 {{(parent.decay_Xmin>=parent.decay_Xmax?parent.decay_Xmax-1:parent.decay_Xmin)*20.48} 100}
  type smooth
  color 0
  name sub_9_Ramp_x
  xpos 86
  ypos 271
  disable {{!parent.decay_XBT}}
 }
 Ramp {
  p0 {{2048-(parent.decayXmax==0?1:parent.decayXmax)*20.48} 100}
  p1 {{2048-(parent.decayXmin>=parent.decayXmax?parent.decayXmax-1:parent.decayXmin)*20.48} 100}
  type smooth
  color 0
  name sub_9_Rampx
  xpos 86
  ypos 297
  disable {{!parent.decayXBT}}
 }
 Ramp {
  p0 {100 {(parent.decay_Ymax==0?1:parent.decay_Ymax)*20.48}}
  p1 {100 {(parent.decay_Ymin>=parent.decay_Ymax?parent.decay_Ymax-1:parent.decay_Ymin)*20.48}}
  type smooth
  color 0
  name sub_9_Ramp_y
  xpos 86
  ypos 327
  disable {{!parent.decay_YBT}}
 }
 Ramp {
  p0 {100 {2048-(parent.decayYmax==0?1:parent.decayYmax)*20.48}}
  p1 {100 {2048-(parent.decayYmin>=parent.decayYmax?parent.decayYmax-1:parent.decayYmin)*20.48}}
  type smooth
  color 0
  name sub_9_Rampy
  xpos 86
  ypos 353
  disable {{!parent.decayYBT}}
 }
 Dissolve {
  inputs 2
  channels rgba
  which {{parent.decay_Zmin>=9*100/10?1:parent.decay_Zmax<=9*100/10?0:1-(9*100/10-(parent.decay_Zmin>=parent.decay_Zmax?parent.decay_Zmax-0.01:parent.decay_Zmin))/(parent.decay_Zmax-(parent.decay_Zmin>=parent.decay_Zmax?parent.decay_Zmax-0.01:parent.decay_Zmin))}}
  name sub_9_Dissolve_z
  xpos 86
  ypos 407
  disable {{!parent.decay_ZBT}}
 }
push $N9a1ede0
 Dissolve {
  inputs 2
  channels rgba
  which {{parent.Dissolve0.which}}
  name sub_9_Dissolve
  xpos 86
  ypos 579
 }
set N9bdb4f0 [stack 0]
 Card2 {
  rows {{parent.resolution}}
  columns {{parent.resolution}}
  translate {0 0 -0.4}
  control_points {3 3 3 6 

1 {-0.5 -0.5 0} 1 {0.1666666865 0 0} 1 {0 0 0} 1 {0 0.1666666865 0} 1 {0 0 0} 1 {0 0 0} 
1 {0 -0.5 0} 1 {0.1666666716 0 0} 1 {-0.1666666716 0 0} 1 {0 0.1666666865 0} 1 {0 0 0} 1 {0.5 0 0} 
1 {0.5 -0.5 0} 1 {0 0 0} 1 {-0.1666666865 0 0} 1 {0 0.1666666865 0} 1 {0 0 0} 1 {1 0 0} 
1 {-0.5 0 0} 1 {0.1666666865 0 0} 1 {0 0 0} 1 {0 0.1666666716 0} 1 {0 -0.1666666716 0} 1 {0 0.5 0} 
1 {0 0 0} 1 {0.1666666716 0 0} 1 {-0.1666666716 0 0} 1 {0 0.1666666716 0} 1 {0 -0.1666666716 0} 1 {0.5 0.5 0} 
1 {0.5 0 0} 1 {0 0 0} 1 {-0.1666666865 0 0} 1 {0 0.1666666716 0} 1 {0 -0.1666666716 0} 1 {1 0.5 0} 
1 {-0.5 0.5 0} 1 {0.1666666865 0 0} 1 {0 0 0} 1 {0 0 0} 1 {0 -0.1666666865 0} 1 {0 1 0} 
1 {0 0.5 0} 1 {0.1666666716 0 0} 1 {-0.1666666716 0 0} 1 {0 0 0} 1 {0 -0.1666666865 0} 1 {0.5 1 0} 
1 {0.5 0.5 0} 1 {0 0 0} 1 {-0.1666666865 0 0} 1 {0 0 0} 1 {0 -0.1666666865 0} 1 {1 1 0} }
  name sub_9_Card
  xpos 86
  ypos 779
 }
 ProcGeo {
  x_size {{parent.dNoiseX}}
  x_offset {{parent.dNoiseXoffset+9*parent.dNoiseVariancy}}
  y_size {{parent.dNoiseY}}
  y_offset {{parent.dNoiseYoffset+9*parent.dNoiseVariancy}}
  Octaves {{parent.dNoiseOctaves}}
  Lacunarity {{parent.dNoiseLacunarity}}
  Gain {{parent.dNoiseGain}}
  Speed {{parent.dNoiseSpeed}}
  name sub_9_ProcGeo
  xpos 86
  ypos 805
  disable {{!parent.dNoise}}
 }
push $N9a1ede0
push $N9a4f210
push $N9a1ede0
 Noise {
  size {{parent.Noise0.size.0} {parent.Noise0.size.1}}
  zoffset {{parent.Noise0.zoffset+8*parent.variancy}}
  octaves {{parent.Noise0.octaves}}
  nyquist {{parent.Noise0.nyquist}}
  lacunarity {{parent.Noise0.lacunarity}}
  gain {{parent.Noise0.gain}}
  gamma {{parent.Noise0.gamma}}
  translate {{parent.Noise0.translate} {parent.Noise0.translate}}
  rotate {{parent.Noise0.rotate}}
  scale {{parent.Noise0.scale.w} {parent.Noise0.scale.h}}
  center {{parent.Noise0.center} {parent.Noise0.center}}
  xrotate {{parent.Noise0.xrotate}}
  yrotate {{parent.Noise0.yrotate}}
  ramp {{parent.Noise0.ramp}}
  color {{parent.Noise0.color} {parent.Noise0.color} {parent.Noise0.color} {parent.Noise0.color}}
  name sub_8_Noise
  xpos -64
  ypos -20
 }
 Unpremult {
  name sub_8_Unpremult
  xpos -64
  ypos 6
  disable {{!parent.color_rampBT}}
 }
 Ramp {
  output rgb
  p0 {{parent.color_p0} {parent.color_p0}}
  p1 {{parent.color_p1} {parent.color_p1}}
  color {{parent.color_color2.r} {parent.color_color2.g} {parent.color_color2.b} 0}
  name sub_8_Ramp
  xpos -64
  ypos 32
  disable {{!parent.color_rampBT}}
 }
 Premult {
  name sub_8_premult
  xpos -64
  ypos 58
  disable {{!parent.color_rampBT}}
 }
 Blur {
  channels rgba
  size {{parent.Blur0.size.w} {parent.Blur0.size.h}}
  name sub_8_Blur
  xpos -64
  ypos 107
 }
 Multiply {
  inputs 1+1
  channels rgba
  value 0
  invert_mask true
  name sub_8_Multiply_SEdges
  xpos -64
  ypos 210
  disable {{!parent.softEdges}}
 }
 Ramp {
  p0 {{(parent.decay_Xmax==0?1:parent.decay_Xmax)*20.48} 100}
  p1 {{(parent.decay_Xmin>=parent.decay_Xmax?parent.decay_Xmax-1:parent.decay_Xmin)*20.48} 100}
  type smooth
  color 0
  name sub_8_Ramp_x
  xpos -64
  ypos 271
  disable {{!parent.decay_XBT}}
 }
 Ramp {
  p0 {{2048-(parent.decayXmax==0?1:parent.decayXmax)*20.48} 100}
  p1 {{2048-(parent.decayXmin>=parent.decayXmax?parent.decayXmax-1:parent.decayXmin)*20.48} 100}
  type smooth
  color 0
  name sub_8_Rampx
  xpos -64
  ypos 297
  disable {{!parent.decayXBT}}
 }
 Ramp {
  p0 {100 {(parent.decay_Ymax==0?1:parent.decay_Ymax)*20.48}}
  p1 {100 {(parent.decay_Ymin>=parent.decay_Ymax?parent.decay_Ymax-1:parent.decay_Ymin)*20.48}}
  type smooth
  color 0
  name sub_8_Ramp_y
  xpos -64
  ypos 327
  disable {{!parent.decay_YBT}}
 }
 Ramp {
  p0 {100 {2048-(parent.decayYmax==0?1:parent.decayYmax)*20.48}}
  p1 {100 {2048-(parent.decayYmin>=parent.decayYmax?parent.decayYmax-1:parent.decayYmin)*20.48}}
  type smooth
  color 0
  name sub_8_Rampy
  xpos -64
  ypos 353
  disable {{!parent.decayYBT}}
 }
 Dissolve {
  inputs 2
  channels rgba
  which {{parent.decay_Zmin>=8*100/10?1:parent.decay_Zmax<=8*100/10?0:1-(8*100/10-(parent.decay_Zmin>=parent.decay_Zmax?parent.decay_Zmax-0.01:parent.decay_Zmin))/(parent.decay_Zmax-(parent.decay_Zmin>=parent.decay_Zmax?parent.decay_Zmax-0.01:parent.decay_Zmin))}}
  name sub_8_Dissolve_z
  xpos -64
  ypos 407
  disable {{!parent.decay_ZBT}}
 }
push $N9a1ede0
 Dissolve {
  inputs 2
  channels rgba
  which {{parent.Dissolve0.which}}
  name sub_8_Dissolve
  xpos -64
  ypos 579
 }
set N9cc17f0 [stack 0]
 Card2 {
  rows {{parent.resolution}}
  columns {{parent.resolution}}
  translate {0 0 -0.3}
  control_points {3 3 3 6 

1 {-0.5 -0.5 0} 1 {0.1666666865 0 0} 1 {0 0 0} 1 {0 0.1666666865 0} 1 {0 0 0} 1 {0 0 0} 
1 {0 -0.5 0} 1 {0.1666666716 0 0} 1 {-0.1666666716 0 0} 1 {0 0.1666666865 0} 1 {0 0 0} 1 {0.5 0 0} 
1 {0.5 -0.5 0} 1 {0 0 0} 1 {-0.1666666865 0 0} 1 {0 0.1666666865 0} 1 {0 0 0} 1 {1 0 0} 
1 {-0.5 0 0} 1 {0.1666666865 0 0} 1 {0 0 0} 1 {0 0.1666666716 0} 1 {0 -0.1666666716 0} 1 {0 0.5 0} 
1 {0 0 0} 1 {0.1666666716 0 0} 1 {-0.1666666716 0 0} 1 {0 0.1666666716 0} 1 {0 -0.1666666716 0} 1 {0.5 0.5 0} 
1 {0.5 0 0} 1 {0 0 0} 1 {-0.1666666865 0 0} 1 {0 0.1666666716 0} 1 {0 -0.1666666716 0} 1 {1 0.5 0} 
1 {-0.5 0.5 0} 1 {0.1666666865 0 0} 1 {0 0 0} 1 {0 0 0} 1 {0 -0.1666666865 0} 1 {0 1 0} 
1 {0 0.5 0} 1 {0.1666666716 0 0} 1 {-0.1666666716 0 0} 1 {0 0 0} 1 {0 -0.1666666865 0} 1 {0.5 1 0} 
1 {0.5 0.5 0} 1 {0 0 0} 1 {-0.1666666865 0 0} 1 {0 0 0} 1 {0 -0.1666666865 0} 1 {1 1 0} }
  name sub_8_Card
  xpos -64
  ypos 779
 }
 ProcGeo {
  x_size {{parent.dNoiseX}}
  x_offset {{parent.dNoiseXoffset+8*parent.dNoiseVariancy}}
  y_size {{parent.dNoiseY}}
  y_offset {{parent.dNoiseYoffset+8*parent.dNoiseVariancy}}
  Octaves {{parent.dNoiseOctaves}}
  Lacunarity {{parent.dNoiseLacunarity}}
  Gain {{parent.dNoiseGain}}
  Speed {{parent.dNoiseSpeed}}
  name sub_8_ProcGeo
  xpos -64
  ypos 805
  disable {{!parent.dNoise}}
 }
push $N9a1ede0
push $N9a4f210
push $N9a1ede0
 Noise {
  size {{parent.Noise0.size.0} {parent.Noise0.size.1}}
  zoffset {{parent.Noise0.zoffset+7*parent.variancy}}
  octaves {{parent.Noise0.octaves}}
  nyquist {{parent.Noise0.nyquist}}
  lacunarity {{parent.Noise0.lacunarity}}
  gain {{parent.Noise0.gain}}
  gamma {{parent.Noise0.gamma}}
  translate {{parent.Noise0.translate} {parent.Noise0.translate}}
  rotate {{parent.Noise0.rotate}}
  scale {{parent.Noise0.scale.w} {parent.Noise0.scale.h}}
  center {{parent.Noise0.center} {parent.Noise0.center}}
  xrotate {{parent.Noise0.xrotate}}
  yrotate {{parent.Noise0.yrotate}}
  ramp {{parent.Noise0.ramp}}
  color {{parent.Noise0.color} {parent.Noise0.color} {parent.Noise0.color} {parent.Noise0.color}}
  name sub_7_Noise
  xpos -214
  ypos -20
 }
 Unpremult {
  name sub_7_Unpremult
  xpos -214
  ypos 6
  disable {{!parent.color_rampBT}}
 }
 Ramp {
  output rgb
  p0 {{parent.color_p0} {parent.color_p0}}
  p1 {{parent.color_p1} {parent.color_p1}}
  color {{parent.color_color2.r} {parent.color_color2.g} {parent.color_color2.b} 0}
  name sub_7_Ramp
  xpos -214
  ypos 32
  disable {{!parent.color_rampBT}}
 }
 Premult {
  name sub_7_premult
  xpos -214
  ypos 58
  disable {{!parent.color_rampBT}}
 }
 Blur {
  channels rgba
  size {{parent.Blur0.size.w} {parent.Blur0.size.h}}
  name sub_7_Blur
  xpos -214
  ypos 107
 }
 Multiply {
  inputs 1+1
  channels rgba
  value 0
  invert_mask true
  name sub_7_Multiply_SEdges
  xpos -214
  ypos 210
  disable {{!parent.softEdges}}
 }
 Ramp {
  p0 {{(parent.decay_Xmax==0?1:parent.decay_Xmax)*20.48} 100}
  p1 {{(parent.decay_Xmin>=parent.decay_Xmax?parent.decay_Xmax-1:parent.decay_Xmin)*20.48} 100}
  type smooth
  color 0
  name sub_7_Ramp_x
  xpos -214
  ypos 271
  disable {{!parent.decay_XBT}}
 }
 Ramp {
  p0 {{2048-(parent.decayXmax==0?1:parent.decayXmax)*20.48} 100}
  p1 {{2048-(parent.decayXmin>=parent.decayXmax?parent.decayXmax-1:parent.decayXmin)*20.48} 100}
  type smooth
  color 0
  name sub_7_Rampx
  xpos -214
  ypos 297
  disable {{!parent.decayXBT}}
 }
 Ramp {
  p0 {100 {(parent.decay_Ymax==0?1:parent.decay_Ymax)*20.48}}
  p1 {100 {(parent.decay_Ymin>=parent.decay_Ymax?parent.decay_Ymax-1:parent.decay_Ymin)*20.48}}
  type smooth
  color 0
  name sub_7_Ramp_y
  xpos -214
  ypos 327
  disable {{!parent.decay_YBT}}
 }
 Ramp {
  p0 {100 {2048-(parent.decayYmax==0?1:parent.decayYmax)*20.48}}
  p1 {100 {2048-(parent.decayYmin>=parent.decayYmax?parent.decayYmax-1:parent.decayYmin)*20.48}}
  type smooth
  color 0
  name sub_7_Rampy
  xpos -214
  ypos 353
  disable {{!parent.decayYBT}}
 }
 Dissolve {
  inputs 2
  channels rgba
  which {{parent.decay_Zmin>=7*100/10?1:parent.decay_Zmax<=7*100/10?0:1-(7*100/10-(parent.decay_Zmin>=parent.decay_Zmax?parent.decay_Zmax-0.01:parent.decay_Zmin))/(parent.decay_Zmax-(parent.decay_Zmin>=parent.decay_Zmax?parent.decay_Zmax-0.01:parent.decay_Zmin))}}
  name sub_7_Dissolve_z
  xpos -214
  ypos 407
  disable {{!parent.decay_ZBT}}
 }
push $N9a1ede0
 Dissolve {
  inputs 2
  channels rgba
  which {{parent.Dissolve0.which}}
  name sub_7_Dissolve
  xpos -214
  ypos 579
 }
set N9da8990 [stack 0]
 Card2 {
  rows {{parent.resolution}}
  columns {{parent.resolution}}
  translate {0 0 -0.2}
  control_points {3 3 3 6 

1 {-0.5 -0.5 0} 1 {0.1666666865 0 0} 1 {0 0 0} 1 {0 0.1666666865 0} 1 {0 0 0} 1 {0 0 0} 
1 {0 -0.5 0} 1 {0.1666666716 0 0} 1 {-0.1666666716 0 0} 1 {0 0.1666666865 0} 1 {0 0 0} 1 {0.5 0 0} 
1 {0.5 -0.5 0} 1 {0 0 0} 1 {-0.1666666865 0 0} 1 {0 0.1666666865 0} 1 {0 0 0} 1 {1 0 0} 
1 {-0.5 0 0} 1 {0.1666666865 0 0} 1 {0 0 0} 1 {0 0.1666666716 0} 1 {0 -0.1666666716 0} 1 {0 0.5 0} 
1 {0 0 0} 1 {0.1666666716 0 0} 1 {-0.1666666716 0 0} 1 {0 0.1666666716 0} 1 {0 -0.1666666716 0} 1 {0.5 0.5 0} 
1 {0.5 0 0} 1 {0 0 0} 1 {-0.1666666865 0 0} 1 {0 0.1666666716 0} 1 {0 -0.1666666716 0} 1 {1 0.5 0} 
1 {-0.5 0.5 0} 1 {0.1666666865 0 0} 1 {0 0 0} 1 {0 0 0} 1 {0 -0.1666666865 0} 1 {0 1 0} 
1 {0 0.5 0} 1 {0.1666666716 0 0} 1 {-0.1666666716 0 0} 1 {0 0 0} 1 {0 -0.1666666865 0} 1 {0.5 1 0} 
1 {0.5 0.5 0} 1 {0 0 0} 1 {-0.1666666865 0 0} 1 {0 0 0} 1 {0 -0.1666666865 0} 1 {1 1 0} }
  name sub_7_Card
  xpos -214
  ypos 779
 }
 ProcGeo {
  x_size {{parent.dNoiseX}}
  x_offset {{parent.dNoiseXoffset+7*parent.dNoiseVariancy}}
  y_size {{parent.dNoiseY}}
  y_offset {{parent.dNoiseYoffset+7*parent.dNoiseVariancy}}
  Octaves {{parent.dNoiseOctaves}}
  Lacunarity {{parent.dNoiseLacunarity}}
  Gain {{parent.dNoiseGain}}
  Speed {{parent.dNoiseSpeed}}
  name sub_7_ProcGeo
  xpos -214
  ypos 805
  disable {{!parent.dNoise}}
 }
push $N9a1ede0
push $N9a4f210
push $N9a1ede0
 Noise {
  size {{parent.Noise0.size.0} {parent.Noise0.size.1}}
  zoffset {{parent.Noise0.zoffset+6*parent.variancy}}
  octaves {{parent.Noise0.octaves}}
  nyquist {{parent.Noise0.nyquist}}
  lacunarity {{parent.Noise0.lacunarity}}
  gain {{parent.Noise0.gain}}
  gamma {{parent.Noise0.gamma}}
  translate {{parent.Noise0.translate} {parent.Noise0.translate}}
  rotate {{parent.Noise0.rotate}}
  scale {{parent.Noise0.scale.w} {parent.Noise0.scale.h}}
  center {{parent.Noise0.center} {parent.Noise0.center}}
  xrotate {{parent.Noise0.xrotate}}
  yrotate {{parent.Noise0.yrotate}}
  ramp {{parent.Noise0.ramp}}
  color {{parent.Noise0.color} {parent.Noise0.color} {parent.Noise0.color} {parent.Noise0.color}}
  name sub_6_Noise
  xpos -364
  ypos -20
 }
 Unpremult {
  name sub_6_Unpremult
  xpos -364
  ypos 6
  disable {{!parent.color_rampBT}}
 }
 Ramp {
  output rgb
  p0 {{parent.color_p0} {parent.color_p0}}
  p1 {{parent.color_p1} {parent.color_p1}}
  color {{parent.color_color2.r} {parent.color_color2.g} {parent.color_color2.b} 0}
  name sub_6_Ramp
  xpos -364
  ypos 32
  disable {{!parent.color_rampBT}}
 }
 Premult {
  name sub_6_premult
  xpos -364
  ypos 58
  disable {{!parent.color_rampBT}}
 }
 Blur {
  channels rgba
  size {{parent.Blur0.size.w} {parent.Blur0.size.h}}
  name sub_6_Blur
  xpos -364
  ypos 107
 }
 Multiply {
  inputs 1+1
  channels rgba
  value 0
  invert_mask true
  name sub_6_Multiply_SEdges
  xpos -364
  ypos 210
  disable {{!parent.softEdges}}
 }
 Ramp {
  p0 {{(parent.decay_Xmax==0?1:parent.decay_Xmax)*20.48} 100}
  p1 {{(parent.decay_Xmin>=parent.decay_Xmax?parent.decay_Xmax-1:parent.decay_Xmin)*20.48} 100}
  type smooth
  color 0
  name sub_6_Ramp_x
  xpos -364
  ypos 271
  disable {{!parent.decay_XBT}}
 }
 Ramp {
  p0 {{2048-(parent.decayXmax==0?1:parent.decayXmax)*20.48} 100}
  p1 {{2048-(parent.decayXmin>=parent.decayXmax?parent.decayXmax-1:parent.decayXmin)*20.48} 100}
  type smooth
  color 0
  name sub_6_Rampx
  xpos -364
  ypos 297
  disable {{!parent.decayXBT}}
 }
 Ramp {
  p0 {100 {(parent.decay_Ymax==0?1:parent.decay_Ymax)*20.48}}
  p1 {100 {(parent.decay_Ymin>=parent.decay_Ymax?parent.decay_Ymax-1:parent.decay_Ymin)*20.48}}
  type smooth
  color 0
  name sub_6_Ramp_y
  xpos -364
  ypos 327
  disable {{!parent.decay_YBT}}
 }
 Ramp {
  p0 {100 {2048-(parent.decayYmax==0?1:parent.decayYmax)*20.48}}
  p1 {100 {2048-(parent.decayYmin>=parent.decayYmax?parent.decayYmax-1:parent.decayYmin)*20.48}}
  type smooth
  color 0
  name sub_6_Rampy
  xpos -364
  ypos 353
  disable {{!parent.decayYBT}}
 }
 Dissolve {
  inputs 2
  channels rgba
  which {{parent.decay_Zmin>=6*100/10?1:parent.decay_Zmax<=6*100/10?0:1-(6*100/10-(parent.decay_Zmin>=parent.decay_Zmax?parent.decay_Zmax-0.01:parent.decay_Zmin))/(parent.decay_Zmax-(parent.decay_Zmin>=parent.decay_Zmax?parent.decay_Zmax-0.01:parent.decay_Zmin))}}
  name sub_6_Dissolve_z
  xpos -364
  ypos 407
  disable {{!parent.decay_ZBT}}
 }
push $N9a1ede0
 Dissolve {
  inputs 2
  channels rgba
  which {{parent.Dissolve0.which}}
  name sub_6_Dissolve
  xpos -364
  ypos 579
 }
set N9e8f3d0 [stack 0]
 Card2 {
  rows {{parent.resolution}}
  columns {{parent.resolution}}
  translate {0 0 -0.1}
  control_points {3 3 3 6 

1 {-0.5 -0.5 0} 1 {0.1666666865 0 0} 1 {0 0 0} 1 {0 0.1666666865 0} 1 {0 0 0} 1 {0 0 0} 
1 {0 -0.5 0} 1 {0.1666666716 0 0} 1 {-0.1666666716 0 0} 1 {0 0.1666666865 0} 1 {0 0 0} 1 {0.5 0 0} 
1 {0.5 -0.5 0} 1 {0 0 0} 1 {-0.1666666865 0 0} 1 {0 0.1666666865 0} 1 {0 0 0} 1 {1 0 0} 
1 {-0.5 0 0} 1 {0.1666666865 0 0} 1 {0 0 0} 1 {0 0.1666666716 0} 1 {0 -0.1666666716 0} 1 {0 0.5 0} 
1 {0 0 0} 1 {0.1666666716 0 0} 1 {-0.1666666716 0 0} 1 {0 0.1666666716 0} 1 {0 -0.1666666716 0} 1 {0.5 0.5 0} 
1 {0.5 0 0} 1 {0 0 0} 1 {-0.1666666865 0 0} 1 {0 0.1666666716 0} 1 {0 -0.1666666716 0} 1 {1 0.5 0} 
1 {-0.5 0.5 0} 1 {0.1666666865 0 0} 1 {0 0 0} 1 {0 0 0} 1 {0 -0.1666666865 0} 1 {0 1 0} 
1 {0 0.5 0} 1 {0.1666666716 0 0} 1 {-0.1666666716 0 0} 1 {0 0 0} 1 {0 -0.1666666865 0} 1 {0.5 1 0} 
1 {0.5 0.5 0} 1 {0 0 0} 1 {-0.1666666865 0 0} 1 {0 0 0} 1 {0 -0.1666666865 0} 1 {1 1 0} }
  name sub_6_Card
  xpos -364
  ypos 779
 }
 ProcGeo {
  x_size {{parent.dNoiseX}}
  x_offset {{parent.dNoiseXoffset+6*parent.dNoiseVariancy}}
  y_size {{parent.dNoiseY}}
  y_offset {{parent.dNoiseYoffset+6*parent.dNoiseVariancy}}
  Octaves {{parent.dNoiseOctaves}}
  Lacunarity {{parent.dNoiseLacunarity}}
  Gain {{parent.dNoiseGain}}
  Speed {{parent.dNoiseSpeed}}
  name sub_6_ProcGeo
  xpos -364
  ypos 805
  disable {{!parent.dNoise}}
 }
push $N9a1ede0
push $N9a4f210
push $N9a1ede0
 Noise {
  size {{parent.Noise0.size.0} {parent.Noise0.size.1}}
  zoffset {{parent.Noise0.zoffset+5*parent.variancy}}
  octaves {{parent.Noise0.octaves}}
  nyquist {{parent.Noise0.nyquist}}
  lacunarity {{parent.Noise0.lacunarity}}
  gain {{parent.Noise0.gain}}
  gamma {{parent.Noise0.gamma}}
  translate {{parent.Noise0.translate} {parent.Noise0.translate}}
  rotate {{parent.Noise0.rotate}}
  scale {{parent.Noise0.scale.w} {parent.Noise0.scale.h}}
  center {{parent.Noise0.center} {parent.Noise0.center}}
  xrotate {{parent.Noise0.xrotate}}
  yrotate {{parent.Noise0.yrotate}}
  ramp {{parent.Noise0.ramp}}
  color {{parent.Noise0.color} {parent.Noise0.color} {parent.Noise0.color} {parent.Noise0.color}}
  name sub_5_Noise
  xpos -514
  ypos -20
 }
 Unpremult {
  name sub_5_Unpremult
  xpos -514
  ypos 6
  disable {{!parent.color_rampBT}}
 }
 Ramp {
  output rgb
  p0 {{parent.color_p0} {parent.color_p0}}
  p1 {{parent.color_p1} {parent.color_p1}}
  color {{parent.color_color2.r} {parent.color_color2.g} {parent.color_color2.b} 0}
  name sub_5_Ramp
  xpos -514
  ypos 32
  disable {{!parent.color_rampBT}}
 }
 Premult {
  name sub_5_premult
  xpos -514
  ypos 58
  disable {{!parent.color_rampBT}}
 }
 Blur {
  channels rgba
  size {{parent.Blur0.size.w} {parent.Blur0.size.h}}
  name sub_5_Blur
  xpos -514
  ypos 107
 }
 Multiply {
  inputs 1+1
  channels rgba
  value 0
  invert_mask true
  name sub_5_Multiply_SEdges
  xpos -514
  ypos 210
  disable {{!parent.softEdges}}
 }
 Ramp {
  p0 {{(parent.decay_Xmax==0?1:parent.decay_Xmax)*20.48} 100}
  p1 {{(parent.decay_Xmin>=parent.decay_Xmax?parent.decay_Xmax-1:parent.decay_Xmin)*20.48} 100}
  type smooth
  color 0
  name sub_5_Ramp_x
  xpos -514
  ypos 271
  disable {{!parent.decay_XBT}}
 }
 Ramp {
  p0 {{2048-(parent.decayXmax==0?1:parent.decayXmax)*20.48} 100}
  p1 {{2048-(parent.decayXmin>=parent.decayXmax?parent.decayXmax-1:parent.decayXmin)*20.48} 100}
  type smooth
  color 0
  name sub_5_Rampx
  xpos -514
  ypos 297
  disable {{!parent.decayXBT}}
 }
 Ramp {
  p0 {100 {(parent.decay_Ymax==0?1:parent.decay_Ymax)*20.48}}
  p1 {100 {(parent.decay_Ymin>=parent.decay_Ymax?parent.decay_Ymax-1:parent.decay_Ymin)*20.48}}
  type smooth
  color 0
  name sub_5_Ramp_y
  xpos -514
  ypos 327
  disable {{!parent.decay_YBT}}
 }
 Ramp {
  p0 {100 {2048-(parent.decayYmax==0?1:parent.decayYmax)*20.48}}
  p1 {100 {2048-(parent.decayYmin>=parent.decayYmax?parent.decayYmax-1:parent.decayYmin)*20.48}}
  type smooth
  color 0
  name sub_5_Rampy
  xpos -514
  ypos 353
  disable {{!parent.decayYBT}}
 }
 Dissolve {
  inputs 2
  channels rgba
  which {{parent.decay_Zmin>=5*100/10?1:parent.decay_Zmax<=5*100/10?0:1-(5*100/10-(parent.decay_Zmin>=parent.decay_Zmax?parent.decay_Zmax-0.01:parent.decay_Zmin))/(parent.decay_Zmax-(parent.decay_Zmin>=parent.decay_Zmax?parent.decay_Zmax-0.01:parent.decay_Zmin))}}
  name sub_5_Dissolve_z
  xpos -514
  ypos 407
  disable {{!parent.decay_ZBT}}
 }
push $N9a1ede0
 Dissolve {
  inputs 2
  channels rgba
  which {{parent.Dissolve0.which}}
  name sub_5_Dissolve
  xpos -514
  ypos 579
 }
set N9f75dc0 [stack 0]
 Card2 {
  rows {{parent.resolution}}
  columns {{parent.resolution}}
  control_points {3 3 3 6 

1 {-0.5 -0.5 0} 1 {0.1666666865 0 0} 1 {0 0 0} 1 {0 0.1666666865 0} 1 {0 0 0} 1 {0 0 0} 
1 {0 -0.5 0} 1 {0.1666666716 0 0} 1 {-0.1666666716 0 0} 1 {0 0.1666666865 0} 1 {0 0 0} 1 {0.5 0 0} 
1 {0.5 -0.5 0} 1 {0 0 0} 1 {-0.1666666865 0 0} 1 {0 0.1666666865 0} 1 {0 0 0} 1 {1 0 0} 
1 {-0.5 0 0} 1 {0.1666666865 0 0} 1 {0 0 0} 1 {0 0.1666666716 0} 1 {0 -0.1666666716 0} 1 {0 0.5 0} 
1 {0 0 0} 1 {0.1666666716 0 0} 1 {-0.1666666716 0 0} 1 {0 0.1666666716 0} 1 {0 -0.1666666716 0} 1 {0.5 0.5 0} 
1 {0.5 0 0} 1 {0 0 0} 1 {-0.1666666865 0 0} 1 {0 0.1666666716 0} 1 {0 -0.1666666716 0} 1 {1 0.5 0} 
1 {-0.5 0.5 0} 1 {0.1666666865 0 0} 1 {0 0 0} 1 {0 0 0} 1 {0 -0.1666666865 0} 1 {0 1 0} 
1 {0 0.5 0} 1 {0.1666666716 0 0} 1 {-0.1666666716 0 0} 1 {0 0 0} 1 {0 -0.1666666865 0} 1 {0.5 1 0} 
1 {0.5 0.5 0} 1 {0 0 0} 1 {-0.1666666865 0 0} 1 {0 0 0} 1 {0 -0.1666666865 0} 1 {1 1 0} }
  name sub_5_Card
  xpos -514
  ypos 779
 }
 ProcGeo {
  x_size {{parent.dNoiseX}}
  x_offset {{parent.dNoiseXoffset+5*parent.dNoiseVariancy}}
  y_size {{parent.dNoiseY}}
  y_offset {{parent.dNoiseYoffset+5*parent.dNoiseVariancy}}
  Octaves {{parent.dNoiseOctaves}}
  Lacunarity {{parent.dNoiseLacunarity}}
  Gain {{parent.dNoiseGain}}
  Speed {{parent.dNoiseSpeed}}
  name sub_5_ProcGeo
  xpos -514
  ypos 805
  disable {{!parent.dNoise}}
 }
push $N9a1ede0
push $N9a4f210
push $N9a1ede0
 Noise {
  size {{parent.Noise0.size.0} {parent.Noise0.size.1}}
  zoffset {{parent.Noise0.zoffset+4*parent.variancy}}
  octaves {{parent.Noise0.octaves}}
  nyquist {{parent.Noise0.nyquist}}
  lacunarity {{parent.Noise0.lacunarity}}
  gain {{parent.Noise0.gain}}
  gamma {{parent.Noise0.gamma}}
  translate {{parent.Noise0.translate} {parent.Noise0.translate}}
  rotate {{parent.Noise0.rotate}}
  scale {{parent.Noise0.scale.w} {parent.Noise0.scale.h}}
  center {{parent.Noise0.center} {parent.Noise0.center}}
  xrotate {{parent.Noise0.xrotate}}
  yrotate {{parent.Noise0.yrotate}}
  ramp {{parent.Noise0.ramp}}
  color {{parent.Noise0.color} {parent.Noise0.color} {parent.Noise0.color} {parent.Noise0.color}}
  name sub_4_Noise
  xpos -664
  ypos -20
 }
 Unpremult {
  name sub_4_Unpremult
  xpos -664
  ypos 6
  disable {{!parent.color_rampBT}}
 }
 Ramp {
  output rgb
  p0 {{parent.color_p0} {parent.color_p0}}
  p1 {{parent.color_p1} {parent.color_p1}}
  color {{parent.color_color2.r} {parent.color_color2.g} {parent.color_color2.b} 0}
  name sub_4_Ramp
  xpos -664
  ypos 32
  disable {{!parent.color_rampBT}}
 }
 Premult {
  name sub_4_premult
  xpos -664
  ypos 58
  disable {{!parent.color_rampBT}}
 }
 Blur {
  channels rgba
  size {{parent.Blur0.size.w} {parent.Blur0.size.h}}
  name sub_4_Blur
  xpos -664
  ypos 107
 }
 Multiply {
  inputs 1+1
  channels rgba
  value 0
  invert_mask true
  name sub_4_Multiply_SEdges
  xpos -664
  ypos 210
  disable {{!parent.softEdges}}
 }
 Ramp {
  p0 {{(parent.decay_Xmax==0?1:parent.decay_Xmax)*20.48} 100}
  p1 {{(parent.decay_Xmin>=parent.decay_Xmax?parent.decay_Xmax-1:parent.decay_Xmin)*20.48} 100}
  type smooth
  color 0
  name sub_4_Ramp_x
  xpos -664
  ypos 271
  disable {{!parent.decay_XBT}}
 }
 Ramp {
  p0 {{2048-(parent.decayXmax==0?1:parent.decayXmax)*20.48} 100}
  p1 {{2048-(parent.decayXmin>=parent.decayXmax?parent.decayXmax-1:parent.decayXmin)*20.48} 100}
  type smooth
  color 0
  name sub_4_Rampx
  xpos -664
  ypos 297
  disable {{!parent.decayXBT}}
 }
 Ramp {
  p0 {100 {(parent.decay_Ymax==0?1:parent.decay_Ymax)*20.48}}
  p1 {100 {(parent.decay_Ymin>=parent.decay_Ymax?parent.decay_Ymax-1:parent.decay_Ymin)*20.48}}
  type smooth
  color 0
  name sub_4_Ramp_y
  xpos -664
  ypos 327
  disable {{!parent.decay_YBT}}
 }
 Ramp {
  p0 {100 {2048-(parent.decayYmax==0?1:parent.decayYmax)*20.48}}
  p1 {100 {2048-(parent.decayYmin>=parent.decayYmax?parent.decayYmax-1:parent.decayYmin)*20.48}}
  type smooth
  color 0
  name sub_4_Rampy
  xpos -664
  ypos 353
  disable {{!parent.decayYBT}}
 }
 Dissolve {
  inputs 2
  channels rgba
  which {{parent.decay_Zmin>=4*100/10?1:parent.decay_Zmax<=4*100/10?0:1-(4*100/10-(parent.decay_Zmin>=parent.decay_Zmax?parent.decay_Zmax-0.01:parent.decay_Zmin))/(parent.decay_Zmax-(parent.decay_Zmin>=parent.decay_Zmax?parent.decay_Zmax-0.01:parent.decay_Zmin))}}
  name sub_4_Dissolve_z
  xpos -664
  ypos 407
  disable {{!parent.decay_ZBT}}
 }
push $N9a1ede0
 Dissolve {
  inputs 2
  channels rgba
  which {{parent.Dissolve0.which}}
  name sub_4_Dissolve
  xpos -664
  ypos 579
 }
set Na05d550 [stack 0]
 Card2 {
  rows {{parent.resolution}}
  columns {{parent.resolution}}
  translate {0 0 0.1}
  control_points {3 3 3 6 

1 {-0.5 -0.5 0} 1 {0.1666666865 0 0} 1 {0 0 0} 1 {0 0.1666666865 0} 1 {0 0 0} 1 {0 0 0} 
1 {0 -0.5 0} 1 {0.1666666716 0 0} 1 {-0.1666666716 0 0} 1 {0 0.1666666865 0} 1 {0 0 0} 1 {0.5 0 0} 
1 {0.5 -0.5 0} 1 {0 0 0} 1 {-0.1666666865 0 0} 1 {0 0.1666666865 0} 1 {0 0 0} 1 {1 0 0} 
1 {-0.5 0 0} 1 {0.1666666865 0 0} 1 {0 0 0} 1 {0 0.1666666716 0} 1 {0 -0.1666666716 0} 1 {0 0.5 0} 
1 {0 0 0} 1 {0.1666666716 0 0} 1 {-0.1666666716 0 0} 1 {0 0.1666666716 0} 1 {0 -0.1666666716 0} 1 {0.5 0.5 0} 
1 {0.5 0 0} 1 {0 0 0} 1 {-0.1666666865 0 0} 1 {0 0.1666666716 0} 1 {0 -0.1666666716 0} 1 {1 0.5 0} 
1 {-0.5 0.5 0} 1 {0.1666666865 0 0} 1 {0 0 0} 1 {0 0 0} 1 {0 -0.1666666865 0} 1 {0 1 0} 
1 {0 0.5 0} 1 {0.1666666716 0 0} 1 {-0.1666666716 0 0} 1 {0 0 0} 1 {0 -0.1666666865 0} 1 {0.5 1 0} 
1 {0.5 0.5 0} 1 {0 0 0} 1 {-0.1666666865 0 0} 1 {0 0 0} 1 {0 -0.1666666865 0} 1 {1 1 0} }
  name sub_4_Card
  xpos -664
  ypos 779
 }
 ProcGeo {
  x_size {{parent.dNoiseX}}
  x_offset {{parent.dNoiseXoffset+4*parent.dNoiseVariancy}}
  y_size {{parent.dNoiseY}}
  y_offset {{parent.dNoiseYoffset+4*parent.dNoiseVariancy}}
  Octaves {{parent.dNoiseOctaves}}
  Lacunarity {{parent.dNoiseLacunarity}}
  Gain {{parent.dNoiseGain}}
  Speed {{parent.dNoiseSpeed}}
  name sub_4_ProcGeo
  xpos -664
  ypos 805
  disable {{!parent.dNoise}}
 }
push $N9a1ede0
push $N9a4f210
push $N9a1ede0
 Noise {
  size {{parent.Noise0.size.0} {parent.Noise0.size.1}}
  zoffset {{parent.Noise0.zoffset+3*parent.variancy}}
  octaves {{parent.Noise0.octaves}}
  nyquist {{parent.Noise0.nyquist}}
  lacunarity {{parent.Noise0.lacunarity}}
  gain {{parent.Noise0.gain}}
  gamma {{parent.Noise0.gamma}}
  translate {{parent.Noise0.translate} {parent.Noise0.translate}}
  rotate {{parent.Noise0.rotate}}
  scale {{parent.Noise0.scale.w} {parent.Noise0.scale.h}}
  center {{parent.Noise0.center} {parent.Noise0.center}}
  xrotate {{parent.Noise0.xrotate}}
  yrotate {{parent.Noise0.yrotate}}
  ramp {{parent.Noise0.ramp}}
  color {{parent.Noise0.color} {parent.Noise0.color} {parent.Noise0.color} {parent.Noise0.color}}
  name sub_3_Noise
  xpos -814
  ypos -20
 }
 Unpremult {
  name sub_3_Unpremult
  xpos -814
  ypos 6
  disable {{!parent.color_rampBT}}
 }
 Ramp {
  output rgb
  p0 {{parent.color_p0} {parent.color_p0}}
  p1 {{parent.color_p1} {parent.color_p1}}
  color {{parent.color_color2.r} {parent.color_color2.g} {parent.color_color2.b} 0}
  name sub_3_Ramp
  xpos -814
  ypos 32
  disable {{!parent.color_rampBT}}
 }
 Premult {
  name sub_3_premult
  xpos -814
  ypos 58
  disable {{!parent.color_rampBT}}
 }
 Blur {
  channels rgba
  size {{parent.Blur0.size.w} {parent.Blur0.size.h}}
  name sub_3_Blur
  xpos -814
  ypos 107
 }
 Multiply {
  inputs 1+1
  channels rgba
  value 0
  invert_mask true
  name sub_3_Multiply_SEdges
  xpos -814
  ypos 210
  disable {{!parent.softEdges}}
 }
 Ramp {
  p0 {{(parent.decay_Xmax==0?1:parent.decay_Xmax)*20.48} 100}
  p1 {{(parent.decay_Xmin>=parent.decay_Xmax?parent.decay_Xmax-1:parent.decay_Xmin)*20.48} 100}
  type smooth
  color 0
  name sub_3_Ramp_x
  xpos -814
  ypos 271
  disable {{!parent.decay_XBT}}
 }
 Ramp {
  p0 {{2048-(parent.decayXmax==0?1:parent.decayXmax)*20.48} 100}
  p1 {{2048-(parent.decayXmin>=parent.decayXmax?parent.decayXmax-1:parent.decayXmin)*20.48} 100}
  type smooth
  color 0
  name sub_3_Rampx
  xpos -814
  ypos 297
  disable {{!parent.decayXBT}}
 }
 Ramp {
  p0 {100 {(parent.decay_Ymax==0?1:parent.decay_Ymax)*20.48}}
  p1 {100 {(parent.decay_Ymin>=parent.decay_Ymax?parent.decay_Ymax-1:parent.decay_Ymin)*20.48}}
  type smooth
  color 0
  name sub_3_Ramp_y
  xpos -814
  ypos 327
  disable {{!parent.decay_YBT}}
 }
 Ramp {
  p0 {100 {2048-(parent.decayYmax==0?1:parent.decayYmax)*20.48}}
  p1 {100 {2048-(parent.decayYmin>=parent.decayYmax?parent.decayYmax-1:parent.decayYmin)*20.48}}
  type smooth
  color 0
  name sub_3_Rampy
  xpos -814
  ypos 353
  disable {{!parent.decayYBT}}
 }
 Dissolve {
  inputs 2
  channels rgba
  which {{parent.decay_Zmin>=3*100/10?1:parent.decay_Zmax<=3*100/10?0:1-(3*100/10-(parent.decay_Zmin>=parent.decay_Zmax?parent.decay_Zmax-0.01:parent.decay_Zmin))/(parent.decay_Zmax-(parent.decay_Zmin>=parent.decay_Zmax?parent.decay_Zmax-0.01:parent.decay_Zmin))}}
  name sub_3_Dissolve_z
  xpos -814
  ypos 407
  disable {{!parent.decay_ZBT}}
 }
push $N9a1ede0
 Dissolve {
  inputs 2
  channels rgba
  which {{parent.Dissolve0.which}}
  name sub_3_Dissolve
  xpos -814
  ypos 578
 }
set Na143760 [stack 0]
 Card2 {
  rows {{parent.resolution}}
  columns {{parent.resolution}}
  translate {0 0 0.2}
  control_points {3 3 3 6 

1 {-0.5 -0.5 0} 1 {0.1666666865 0 0} 1 {0 0 0} 1 {0 0.1666666865 0} 1 {0 0 0} 1 {0 0 0} 
1 {0 -0.5 0} 1 {0.1666666716 0 0} 1 {-0.1666666716 0 0} 1 {0 0.1666666865 0} 1 {0 0 0} 1 {0.5 0 0} 
1 {0.5 -0.5 0} 1 {0 0 0} 1 {-0.1666666865 0 0} 1 {0 0.1666666865 0} 1 {0 0 0} 1 {1 0 0} 
1 {-0.5 0 0} 1 {0.1666666865 0 0} 1 {0 0 0} 1 {0 0.1666666716 0} 1 {0 -0.1666666716 0} 1 {0 0.5 0} 
1 {0 0 0} 1 {0.1666666716 0 0} 1 {-0.1666666716 0 0} 1 {0 0.1666666716 0} 1 {0 -0.1666666716 0} 1 {0.5 0.5 0} 
1 {0.5 0 0} 1 {0 0 0} 1 {-0.1666666865 0 0} 1 {0 0.1666666716 0} 1 {0 -0.1666666716 0} 1 {1 0.5 0} 
1 {-0.5 0.5 0} 1 {0.1666666865 0 0} 1 {0 0 0} 1 {0 0 0} 1 {0 -0.1666666865 0} 1 {0 1 0} 
1 {0 0.5 0} 1 {0.1666666716 0 0} 1 {-0.1666666716 0 0} 1 {0 0 0} 1 {0 -0.1666666865 0} 1 {0.5 1 0} 
1 {0.5 0.5 0} 1 {0 0 0} 1 {-0.1666666865 0 0} 1 {0 0 0} 1 {0 -0.1666666865 0} 1 {1 1 0} }
  name sub_3_Card
  xpos -814
  ypos 779
 }
 ProcGeo {
  x_size {{parent.dNoiseX}}
  x_offset {{parent.dNoiseXoffset+3*parent.dNoiseVariancy}}
  y_size {{parent.dNoiseY}}
  y_offset {{parent.dNoiseYoffset+3*parent.dNoiseVariancy}}
  Octaves {{parent.dNoiseOctaves}}
  Lacunarity {{parent.dNoiseLacunarity}}
  Gain {{parent.dNoiseGain}}
  Speed {{parent.dNoiseSpeed}}
  name sub_3_ProcGeo
  xpos -814
  ypos 805
  disable {{!parent.dNoise}}
 }
push $N9a1ede0
push $N9a4f210
push $N9a1ede0
 Noise {
  size {{parent.Noise0.size.0} {parent.Noise0.size.1}}
  zoffset {{parent.Noise0.zoffset+2*parent.variancy}}
  octaves {{parent.Noise0.octaves}}
  nyquist {{parent.Noise0.nyquist}}
  lacunarity {{parent.Noise0.lacunarity}}
  gain {{parent.Noise0.gain}}
  gamma {{parent.Noise0.gamma}}
  translate {{parent.Noise0.translate} {parent.Noise0.translate}}
  rotate {{parent.Noise0.rotate}}
  scale {{parent.Noise0.scale.w} {parent.Noise0.scale.h}}
  center {{parent.Noise0.center} {parent.Noise0.center}}
  xrotate {{parent.Noise0.xrotate}}
  yrotate {{parent.Noise0.yrotate}}
  ramp {{parent.Noise0.ramp}}
  color {{parent.Noise0.color} {parent.Noise0.color} {parent.Noise0.color} {parent.Noise0.color}}
  name sub_2_Noise
  xpos -964
  ypos -20
 }
 Unpremult {
  name sub_2_Unpremult
  xpos -964
  ypos 6
  disable {{!parent.color_rampBT}}
 }
 Ramp {
  output rgb
  p0 {{parent.color_p0} {parent.color_p0}}
  p1 {{parent.color_p1} {parent.color_p1}}
  color {{parent.color_color2.r} {parent.color_color2.g} {parent.color_color2.b} 0}
  name sub_2_Ramp
  xpos -964
  ypos 32
  disable {{!parent.color_rampBT}}
 }
 Premult {
  name sub_2_premult
  xpos -964
  ypos 58
  disable {{!parent.color_rampBT}}
 }
 Blur {
  channels rgba
  size {{parent.Blur0.size.w} {parent.Blur0.size.h}}
  name sub_2_Blur
  xpos -964
  ypos 107
 }
 Multiply {
  inputs 1+1
  channels rgba
  value 0
  invert_mask true
  name sub_2_Multiply_SEdges
  xpos -964
  ypos 210
  disable {{!parent.softEdges}}
 }
 Ramp {
  p0 {{(parent.decay_Xmax==0?1:parent.decay_Xmax)*20.48} 100}
  p1 {{(parent.decay_Xmin>=parent.decay_Xmax?parent.decay_Xmax-1:parent.decay_Xmin)*20.48} 100}
  type smooth
  color 0
  name sub_2_Ramp_x
  xpos -964
  ypos 271
  disable {{!parent.decay_XBT}}
 }
 Ramp {
  p0 {{2048-(parent.decayXmax==0?1:parent.decayXmax)*20.48} 100}
  p1 {{2048-(parent.decayXmin>=parent.decayXmax?parent.decayXmax-1:parent.decayXmin)*20.48} 100}
  type smooth
  color 0
  name sub_2_Rampx
  xpos -964
  ypos 297
  disable {{!parent.decayXBT}}
 }
 Ramp {
  p0 {100 {(parent.decay_Ymax==0?1:parent.decay_Ymax)*20.48}}
  p1 {100 {(parent.decay_Ymin>=parent.decay_Ymax?parent.decay_Ymax-1:parent.decay_Ymin)*20.48}}
  type smooth
  color 0
  name sub_2_Ramp_y
  xpos -964
  ypos 327
  disable {{!parent.decay_YBT}}
 }
 Ramp {
  p0 {100 {2048-(parent.decayYmax==0?1:parent.decayYmax)*20.48}}
  p1 {100 {2048-(parent.decayYmin>=parent.decayYmax?parent.decayYmax-1:parent.decayYmin)*20.48}}
  type smooth
  color 0
  name sub_2_Rampy
  xpos -964
  ypos 353
  disable {{!parent.decayYBT}}
 }
 Dissolve {
  inputs 2
  channels rgba
  which {{parent.decay_Zmin>=2*100/10?1:parent.decay_Zmax<=2*100/10?0:1-(2*100/10-(parent.decay_Zmin>=parent.decay_Zmax?parent.decay_Zmax-0.01:parent.decay_Zmin))/(parent.decay_Zmax-(parent.decay_Zmin>=parent.decay_Zmax?parent.decay_Zmax-0.01:parent.decay_Zmin))}}
  name sub_2_Dissolve_z
  xpos -964
  ypos 407
  disable {{!parent.decay_ZBT}}
 }
push $N9a1ede0
 Dissolve {
  inputs 2
  channels rgba
  which {{parent.Dissolve0.which}}
  name sub_2_Dissolve
  xpos -964
  ypos 577
 }
set Na229fb0 [stack 0]
 Card2 {
  rows {{parent.resolution}}
  columns {{parent.resolution}}
  translate {0 0 0.3}
  control_points {3 3 3 6 

1 {-0.5 -0.5 0} 1 {0.1666666865 0 0} 1 {0 0 0} 1 {0 0.1666666865 0} 1 {0 0 0} 1 {0 0 0} 
1 {0 -0.5 0} 1 {0.1666666716 0 0} 1 {-0.1666666716 0 0} 1 {0 0.1666666865 0} 1 {0 0 0} 1 {0.5 0 0} 
1 {0.5 -0.5 0} 1 {0 0 0} 1 {-0.1666666865 0 0} 1 {0 0.1666666865 0} 1 {0 0 0} 1 {1 0 0} 
1 {-0.5 0 0} 1 {0.1666666865 0 0} 1 {0 0 0} 1 {0 0.1666666716 0} 1 {0 -0.1666666716 0} 1 {0 0.5 0} 
1 {0 0 0} 1 {0.1666666716 0 0} 1 {-0.1666666716 0 0} 1 {0 0.1666666716 0} 1 {0 -0.1666666716 0} 1 {0.5 0.5 0} 
1 {0.5 0 0} 1 {0 0 0} 1 {-0.1666666865 0 0} 1 {0 0.1666666716 0} 1 {0 -0.1666666716 0} 1 {1 0.5 0} 
1 {-0.5 0.5 0} 1 {0.1666666865 0 0} 1 {0 0 0} 1 {0 0 0} 1 {0 -0.1666666865 0} 1 {0 1 0} 
1 {0 0.5 0} 1 {0.1666666716 0 0} 1 {-0.1666666716 0 0} 1 {0 0 0} 1 {0 -0.1666666865 0} 1 {0.5 1 0} 
1 {0.5 0.5 0} 1 {0 0 0} 1 {-0.1666666865 0 0} 1 {0 0 0} 1 {0 -0.1666666865 0} 1 {1 1 0} }
  name sub_2_Card
  xpos -964
  ypos 779
 }
 ProcGeo {
  x_size {{parent.dNoiseX}}
  x_offset {{parent.dNoiseXoffset+2*parent.dNoiseVariancy}}
  y_size {{parent.dNoiseY}}
  y_offset {{parent.dNoiseYoffset+2*parent.dNoiseVariancy}}
  Octaves {{parent.dNoiseOctaves}}
  Lacunarity {{parent.dNoiseLacunarity}}
  Gain {{parent.dNoiseGain}}
  Speed {{parent.dNoiseSpeed}}
  name sub_2_ProcGeo
  xpos -964
  ypos 805
  disable {{!parent.dNoise}}
 }
push $N9a1ede0
push $N9a4f210
push $N9a1ede0
 Noise {
  size {{parent.Noise0.size.0} {parent.Noise0.size.1}}
  zoffset {{parent.Noise0.zoffset+1*parent.variancy}}
  octaves {{parent.Noise0.octaves}}
  nyquist {{parent.Noise0.nyquist}}
  lacunarity {{parent.Noise0.lacunarity}}
  gain {{parent.Noise0.gain}}
  gamma {{parent.Noise0.gamma}}
  translate {{parent.Noise0.translate} {parent.Noise0.translate}}
  rotate {{parent.Noise0.rotate}}
  scale {{parent.Noise0.scale.w} {parent.Noise0.scale.h}}
  center {{parent.Noise0.center} {parent.Noise0.center}}
  xrotate {{parent.Noise0.xrotate}}
  yrotate {{parent.Noise0.yrotate}}
  ramp {{parent.Noise0.ramp}}
  color {{parent.Noise0.color} {parent.Noise0.color} {parent.Noise0.color} {parent.Noise0.color}}
  name sub_1_Noise
  xpos -1114
  ypos -20
 }
 Unpremult {
  name sub_1_Unpremult
  xpos -1114
  ypos 6
  disable {{!parent.color_rampBT}}
 }
 Ramp {
  output rgb
  p0 {{parent.color_p0} {parent.color_p0}}
  p1 {{parent.color_p1} {parent.color_p1}}
  color {{parent.color_color2.r} {parent.color_color2.g} {parent.color_color2.b} 0}
  name sub_1_Ramp
  xpos -1114
  ypos 32
  disable {{!parent.color_rampBT}}
 }
 Premult {
  name sub_1_premult
  xpos -1114
  ypos 58
  disable {{!parent.color_rampBT}}
 }
 Blur {
  channels rgba
  size {{parent.Blur0.size.w} {parent.Blur0.size.h}}
  name sub_1_Blur
  xpos -1114
  ypos 107
 }
 Multiply {
  inputs 1+1
  channels rgba
  value 0
  invert_mask true
  name sub_1_Multiply_SEdges
  xpos -1114
  ypos 210
  disable {{!parent.softEdges}}
 }
 Ramp {
  p0 {{(parent.decay_Xmax==0?1:parent.decay_Xmax)*20.48} 100}
  p1 {{(parent.decay_Xmin>=parent.decay_Xmax?parent.decay_Xmax-1:parent.decay_Xmin)*20.48} 100}
  type smooth
  color 0
  name sub_1_Ramp_x
  xpos -1114
  ypos 271
  disable {{!parent.decay_XBT}}
 }
 Ramp {
  p0 {{2048-(parent.decayXmax==0?1:parent.decayXmax)*20.48} 100}
  p1 {{2048-(parent.decayXmin>=parent.decayXmax?parent.decayXmax-1:parent.decayXmin)*20.48} 100}
  type smooth
  color 0
  name sub_1_Rampx
  xpos -1114
  ypos 297
  disable {{!parent.decayXBT}}
 }
 Ramp {
  p0 {100 {(parent.decay_Ymax==0?1:parent.decay_Ymax)*20.48}}
  p1 {100 {(parent.decay_Ymin>=parent.decay_Ymax?parent.decay_Ymax-1:parent.decay_Ymin)*20.48}}
  type smooth
  color 0
  name sub_1_Ramp_y
  xpos -1114
  ypos 327
  disable {{!parent.decay_YBT}}
 }
 Ramp {
  p0 {100 {2048-(parent.decayYmax==0?1:parent.decayYmax)*20.48}}
  p1 {100 {2048-(parent.decayYmin>=parent.decayYmax?parent.decayYmax-1:parent.decayYmin)*20.48}}
  type smooth
  color 0
  name sub_1_Rampy
  xpos -1114
  ypos 353
  disable {{!parent.decayYBT}}
 }
 Dissolve {
  inputs 2
  channels rgba
  which {{parent.decay_Zmin>=1*100/10?1:parent.decay_Zmax<=1*100/10?0:1-(1*100/10-(parent.decay_Zmin>=parent.decay_Zmax?parent.decay_Zmax-0.01:parent.decay_Zmin))/(parent.decay_Zmax-(parent.decay_Zmin>=parent.decay_Zmax?parent.decay_Zmax-0.01:parent.decay_Zmin))}}
  name sub_1_Dissolve_z
  xpos -1114
  ypos 407
  disable {{!parent.decay_ZBT}}
 }
push $N9a1ede0
 Dissolve {
  inputs 2
  channels rgba
  which {{parent.Dissolve0.which}}
  name sub_1_Dissolve
  xpos -1114
  ypos 578
 }
set Na311010 [stack 0]
 Card2 {
  rows {{parent.resolution}}
  columns {{parent.resolution}}
  translate {0 0 0.4}
  control_points {3 3 3 6 

1 {-0.5 -0.5 0} 1 {0.1666666865 0 0} 1 {0 0 0} 1 {0 0.1666666865 0} 1 {0 0 0} 1 {0 0 0} 
1 {0 -0.5 0} 1 {0.1666666716 0 0} 1 {-0.1666666716 0 0} 1 {0 0.1666666865 0} 1 {0 0 0} 1 {0.5 0 0} 
1 {0.5 -0.5 0} 1 {0 0 0} 1 {-0.1666666865 0 0} 1 {0 0.1666666865 0} 1 {0 0 0} 1 {1 0 0} 
1 {-0.5 0 0} 1 {0.1666666865 0 0} 1 {0 0 0} 1 {0 0.1666666716 0} 1 {0 -0.1666666716 0} 1 {0 0.5 0} 
1 {0 0 0} 1 {0.1666666716 0 0} 1 {-0.1666666716 0 0} 1 {0 0.1666666716 0} 1 {0 -0.1666666716 0} 1 {0.5 0.5 0} 
1 {0.5 0 0} 1 {0 0 0} 1 {-0.1666666865 0 0} 1 {0 0.1666666716 0} 1 {0 -0.1666666716 0} 1 {1 0.5 0} 
1 {-0.5 0.5 0} 1 {0.1666666865 0 0} 1 {0 0 0} 1 {0 0 0} 1 {0 -0.1666666865 0} 1 {0 1 0} 
1 {0 0.5 0} 1 {0.1666666716 0 0} 1 {-0.1666666716 0 0} 1 {0 0 0} 1 {0 -0.1666666865 0} 1 {0.5 1 0} 
1 {0.5 0.5 0} 1 {0 0 0} 1 {-0.1666666865 0 0} 1 {0 0 0} 1 {0 -0.1666666865 0} 1 {1 1 0} }
  name sub_1_Card
  xpos -1114
  ypos 779
 }
 ProcGeo {
  x_size {{parent.dNoiseX}}
  x_offset {{parent.dNoiseXoffset+1*parent.dNoiseVariancy}}
  y_size {{parent.dNoiseY}}
  y_offset {{parent.dNoiseYoffset+1*parent.dNoiseVariancy}}
  Octaves {{parent.dNoiseOctaves}}
  Lacunarity {{parent.dNoiseLacunarity}}
  Gain {{parent.dNoiseGain}}
  Speed {{parent.dNoiseSpeed}}
  name sub_1_ProcGeo
  xpos -1114
  ypos 805
  disable {{!parent.dNoise}}
 }
push $N9a1ede0
push $N9a4f210
push $N9a1ede0
 Noise {
  size 400
  center {1099 567}
  xrotate 5
  yrotate 5
  p1 {204 926}
  color0 {1 0.1200000048 0.1200000048 0}
  p0 {494 52}
  name Noise0
  xpos -1264
  ypos -20
 }
 Unpremult {
  name Unpremult0
  xpos -1264
  ypos 6
  disable {{!parent.color_rampBT i}}
 }
 Ramp {
  output rgb
  p0 {{parent.color_p0 i} {parent.color_p0 i}}
  p1 {{parent.color_p1 i} {parent.color_p1 i}}
  color {{parent.color_color2 i} {parent.color_color2 i} {parent.color_color2 i} {parent.color_color2 i}}
  name Ramp0
  xpos -1264
  ypos 32
  disable {{!parent.color_rampBT i}}
 }
 Premult {
  name Premult0
  xpos -1264
  ypos 58
  disable {{!parent.color_rampBT i}}
 }
 Blur {
  channels rgba
  size {{parent.blurSize i} {parent.blurSize i}}
  name Blur0
  label "\[value size]"
  xpos -1264
  ypos 107
 }
 Multiply {
  inputs 1+1
  channels rgba
  value 0
  invert_mask true
  name Multiply0
  xpos -1264
  ypos 210
  disable {{!parent.softEdges i}}
 }
 Ramp {
  p0 {{(parent.decay_Xmax==0?1:parent.decay_Xmax)*20.48 i} 100}
  p1 {{(parent.decay_Xmin>=parent.decay_Xmax?parent.decay_Xmax-1:parent.decay_Xmin)*20.48 i} 100}
  type smooth
  color 0
  name Ramp_X0
  xpos -1264
  ypos 271
  disable {{!parent.decay_XBT i}}
 }
 Ramp {
  p0 {{2048-(parent.decayXmax==0?1:parent.decayXmax)*20.48 i} 200}
  p1 {{2048-(parent.decayXmin>=parent.decayXmax?parent.decayXmax-1:parent.decayXmin)*20.48 i} 200}
  type smooth
  color 0
  name RampX0
  xpos -1264
  ypos 297
  disable {{!parent.decayXBT i}}
 }
 Ramp {
  p0 {100 {(parent.decay_Ymax==0?1:parent.decay_Ymax)*20.48 i}}
  p1 {100 {(parent.decay_Ymin>=parent.decay_Ymax?parent.decay_Ymax-1:parent.decay_Ymin)*20.48 i}}
  type smooth
  color 0
  name Ramp_Y0
  xpos -1264
  ypos 327
  disable {{!parent.decay_YBT i}}
 }
 Ramp {
  p0 {200 {2048-(parent.decayYmax==0?1:parent.decayYmax)*20.48 i}}
  p1 {200 {2048-(parent.decayYmin>=parent.decayYmax?parent.decayYmax-1:parent.decayYmin)*20.48 i}}
  color 0
  name RampY0
  xpos -1264
  ypos 353
  disable {{!parent.decayYBT i}}
 }
 Dissolve {
  inputs 2
  channels rgba
  which 1
  name Dissolve_Z0
  xpos -1264
  ypos 407
  disable {{!parent.decay_ZBT i}}
 }
push $N9a1ede0
 Dissolve {
  inputs 2
  channels rgba
  which {{parent.opacity}}
  name Dissolve0
  xpos -1264
  ypos 578
 }
set Na3f4390 [stack 0]
 Card2 {
  rows {{parent.resolution i}}
  columns {{parent.resolution i}}
  translate {0 0 0.5}
  control_points {3 3 3 6 

1 {-0.5 -0.5 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {0 0 0} 
1 {0 -0.5 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {0.5 0 0} 
1 {0.5 -0.5 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {1 0 0} 
1 {-0.5 0 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {0 0.5 0} 
1 {0 0 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {0.5 0.5 0} 
1 {0.5 0 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {1 0.5 0} 
1 {-0.5 0.5 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {0 1 0} 
1 {0 0.5 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {0.5 1 0} 
1 {0.5 0.5 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {1 1 0} }
  name Card0
  xpos -1264
  ypos 779
 }
 ProcGeo {
  x_size {{parent.dNoiseX i}}
  x_offset {{parent.dNoiseXoffset i}}
  y_size {{parent.dNoiseY i}}
  y_offset {{parent.dNoiseYoffset i}}
  Octaves {{parent.dNoiseOctaves i}}
  Lacunarity {{parent.dNoiseLacunarity i}}
  Gain {{parent.dNoiseGain i}}
  Speed {{parent.dNoiseSpeed i}}
  name ProcGeo0
  xpos -1264
  ypos 805
  disable {{!parent.dNoise i}}
 }
 Scene {
  inputs 11
  name Scene_layers
  xpos -206
  ypos 1173
 }
 CrosstalkGeo {
  crossover {x {}
    y {}
    z {}
    x->y {}
    x->z {(-pow2(x*2))*bendX C 0}
    y->x {}
    y->z {(-pow2(x*2))*bendY C 0}
    z->x {}
    z->y {}}
  name CrosstalkGeo_bend
  xpos -216
  ypos 1266
  disable {{!parent.bend i}}
 }
 TransformGeo {
  translate {{(parent.Cube1.cube.x+parent.Cube1.cube.r)/2 i} {(parent.Cube1.cube.y+parent.Cube1.cube.t)/2 i} {(parent.Cube1.cube.n+parent.Cube1.cube.f)/2 i}}
  scaling {{(parent.Cube1.cube.r-parent.Cube1.cube.x) i} {(parent.Cube1.cube.t-parent.Cube1.cube.y) i} {(parent.Cube1.cube.f-parent.Cube1.cube.n) i}}
  name TransformGeo_cage
  xpos -216
  ypos 1404
 }
 TransformGeo {
  translate {{parent.cage_position i} {parent.cage_position i} {parent.cage_position i}}
  rotate {{parent.cage_rotation i} {parent.cage_rotation i} {parent.cage_rotation i}}
  uniform_scale {{parent.cage_scale i}}
  name TransformGeo_transform
  xpos -216
  ypos 1467
 }
 Output {
  name Output1
  xpos -216
  ypos 1640
 }
 Cube {
  inputs 0
  display wireframe
  render_mode off
  rows 1
  columns 1
  translate {{parent.cage_position i x1001 1.745000005} {parent.cage_position i x1001 0} {parent.cage_position i x1001 0}}
  rotate {{parent.cage_rotation i} {parent.cage_rotation i} {parent.cage_rotation i}}
  uniform_scale {{parent.cage_scale i}}
  name Cube1
  xpos 48
  ypos 1402
 }
push $N9af4760
push $N9bdb4f0
push $N9cc17f0
push $N9da8990
push $N9e8f3d0
push $N9f75dc0
push $Na05d550
push $Na311010
push $Na229fb0
push 0
push $Na143760
push $Na3f4390
 Merge2 {
  inputs 11+1
  name Merge1
  selected true
  xpos -1442
  ypos 690
 }
end_group
set N997ffb0 [stack 0]
TransformGeo {
 translate {0 0 -1}
 name TransformGeo1
 xpos -296
 ypos -78
}
push $N997ffb0
Scene {
 inputs 2
 name Scene1
 xpos -399
 ypos 5
}
Reformat {
 inputs 0
 format "1280 720 0 0 1280 720 1 HD_720"
 name Reformat2
 xpos -316
 ypos 98
}
ScanlineRender {
 inputs 3
 conservative_shader_sampling false
 motion_vectors_type distance
 name ScanlineRender1
 xpos -409
 ypos 150
}
DeepColorCorrect2 {
 channels rgba
 gain 0
 zmap {0 0.08494734981 0.4008903715 1.255751117}
 name DeepColorCorrect1
 xpos -409
 ypos 207
}
Axis3 {
 inputs 0
 name Axis1
 xpos 560
 ypos -381
}
Axis3 {
 translate {0 0 10}
 name Axis2
 xpos 560
 ypos -293
}
set N97498d0 [stack 0]
Camera3 {
 translate {0 0 {curve x1 -0 x100 -20}}
 name Camera1
 xpos 560
 ypos -217
}
push $N97498d0
Camera3 {
 translate {0 0 {curve x1 0 x21 -2}}
 rotate {0 0 {curve x1 0 x21 180}}
 name Camera3
 xpos 652
 ypos -216
}
Group {
 inputs 0
 name PointFractal
 tile_color 0x434343ff
 note_font_color 0x7dadf9ff
 xpos 1287
 ypos -54
 addUserKnob {20 User t test}
 addUserKnob {26 info l "" +STARTLINE T "Point Fractal 1.12\n"}
 addUserKnob {6 boolean l "Use GPU if available" t "Un-Check to avoid using the gpu for rendering of this node." +STARTLINE}
 boolean true
 addUserKnob {26 devider_noise l "<b><font color=#7DADF9>Noise Settings</font><b>"}
 addUserKnob {6 EnableOffset l "Enable Offset Input" t "Put a map into the \"Offset\" input of this node to modulate the noise based on the luminance of the map.\n\nThe red channal controls the low frequencies while the green channel controls the high frequencies.\n\nYou can for example use this to create a radially shaped noise." +STARTLINE}
 addUserKnob {6 Noise_Absolute l "Absolute Noise" t "Negative values in the noise offset is made positive." -STARTLINE}
 addUserKnob {3 Noise_Octaves l Octaves}
 Noise_Octaves 8
 addUserKnob {7 Noise_Gain l Gain}
 Noise_Gain 0.5
 addUserKnob {7 Noise_Lacunarity l Lacunarity R 0 4}
 Noise_Lacunarity 0.5
 addUserKnob {18 Amplitude}
 Amplitude 0.5
 addUserKnob {6 Amplitude_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {3 Itterations l Iterations}
 Itterations 1
 addUserKnob {26 invis_devider_noise l "" +STARTLINE T " "}
 addUserKnob {26 Devider_Frequency l "<b><font color=#7DADF9>Freq Control</font><b>"}
 addUserKnob {19 Freq_Offset l "General Offset" t "This is like a 3D translation, letting you move the current noise pattern in the X, Y, Z and W (4th dimention)" R 0 10}
 Freq_Offset {0 0 0 0}
 addUserKnob {6 Freq_Offset_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 Freq_GeneralScale l "Genral Scale" t "This lets you control the scale of each individual noise axis."}
 Freq_GeneralScale 1
 addUserKnob {6 Freq_GeneralScale_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 invis_devider_freq l "" +STARTLINE T " "}
 addUserKnob {19 Freq_EvolveLow l "Evolve Low" t "This lets you evolve (auto animate) the noise in a particular direction. The \"Low\" part means that this only affects the low frequencies.\n\nTo avoid a \"scrolling\" effect you can use the 4th dimention to break up the spatial cohearence." R 0 10}
 Freq_EvolveLow {0.5 0 0 0.5}
 addUserKnob {6 Freq_EvolveLow_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {6 Freq_ScaleLow_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 Freq_EvolveHigh l "Evolve High" t "This lets you evolve (auto animate) the noise in a particular direction. The \"High\" part means that this only affects the high frequencies.\n\nTo avoid a \"scrolling\" effect you can use the 4th dimention to break up the spatial cohearence."}
 Freq_EvolveHigh {0 0 0 0}
 addUserKnob {6 Freq_EvolveHigh_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 invis_devider_freq2 l "" +STARTLINE T " "}
 addUserKnob {19 Freq_ScaleLow l "Scale Low" t "This lets you scale the noise in a particular axis. The \"Low\" part means that this only affects the low frequencies."}
 Freq_ScaleLow {1 1 1 1}
 addUserKnob {6 Freq_ScaleLow_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 Freq_ScaleHigh l "Scale High" t "This lets you scale the noise in a particular axis. The \"High\" part means that this only affects the high frequencies."}
 Freq_ScaleHigh {1 1 1 1}
 addUserKnob {6 Freq_ScaleHigh_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {26 invis_devider_freq3 l "" +STARTLINE T " "}
 addUserKnob {26 Curve l "<b><font color=#7DADF9>Curve Noise</font><b>"}
 addUserKnob {6 CurveNoise_Enable l Enable t "Adds a gamma curve to the noise intensity making noise near the \"Offset\" value more flat. This is a experimental feature." +STARTLINE}
 addUserKnob {6 CurveNoise_Invert l Invert t "Inverts the effect of the curved noise." -STARTLINE}
 addUserKnob {7 CurveGain l "Curve Gain" R -10 10}
 CurveGain 3
 addUserKnob {7 CurveOffset l "Curve Offset" R -2 2}
 addUserKnob {26 gabgen l "" +STARTLINE T "\n"}
 addUserKnob {26 info_mask l "<b><font color=#7DADF9>Mask</font><b>"}
 addUserKnob {41 maskChannelMask l "" t "If a node is connected to the mask input, this will let you mask off the effect of the noise.\nIts recommended that you use the Point_Texture node to ensure a correct aspect and size." -STARTLINE T Merge1.maskChannelMask}
 addUserKnob {41 inject -STARTLINE T Merge1.inject}
 addUserKnob {41 invert_mask l invert -STARTLINE T Merge1.invert_mask}
 addUserKnob {41 fringe -STARTLINE T Merge1.fringe}
 addUserKnob {41 mix T Merge1.mix}
}
 Input {
  inputs 0
  name InputMask
  xpos -714
  ypos 297
  number 1
 }
 Reformat {
  type "to box"
  box_width {{parent.InputFormat.box.r}}
  box_height {{parent.InputFormat.box.t}}
  box_fixed true
  resize distort
  name Reformat2
  xpos -714
  ypos 396
 }
 Shuffle {
  name Shuffle3
  xpos -714
  ypos 420
 }
 Input {
  inputs 0
  name InputOffset
  xpos -208
  ypos 61
  number 2
 }
 Dot {
  name Dot2
  xpos -174
  ypos 153
 }
 Input {
  inputs 0
  name InputData
  xpos -582
  ypos 73
 }
 Dot {
  name Dot1
  xpos -548
  ypos 114
 }
set N96bedd0 [stack 0]
add_layer {pos pos.red pos.green pos.blue pos.alpha}
 Shuffle {
  in pos
  name Shuffle1
  xpos -470
  ypos 110
 }
set N96eb680 [stack 0]
 Multiply {
  value 0
  name Multiply1
  xpos -338
  ypos 106
 }
 Merge2 {
  inputs 2
  operation copy
  name Merge2
  xpos -338
  ypos 150
 }
push $N96eb680
 BlinkScript {
  inputs 2
  kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Modify/Fractal_v08.cpp
  recompileCount 64
  ProgramGroup 1
  KernelDescription "2 \"Noise4D\" iterate pixelWise be1f493003df1b115acb2d181bf4caa997e214937eb46d4cd65a56edf3425cad 3 \"src\" Read Point \"modix\" Read Point \"dst\" Write Point 19 \"absNoise\" Bool 1 AA== \"curveNoise\" Bool 1 AA== \"curveInvert\" Bool 1 AA== \"radialNoise\" Bool 1 AA== \"curveGain\" Float 1 AACAPw== \"curveOffset\" Float 1 AACAPw== \"Octaves\" Int 1 CgAAAA== \"Gain\" Float 1 AAAAPw== \"Lacunarity\" Float 1 AAAAQA== \"Gamma\" Float 1 AAAAPw== \"amplitude\" Float 3 AAAAPwAAAD8AAAA/AAAAAA== \"itterations\" Int 1 AQAAAA== \"Offset\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"Scale\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"suboffset\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"topoffset\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"subscale\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"topscale\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"center\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== 19 \"absNoise\" 1 1 \"curveNoise\" 1 1 \"curveInvert\" 1 1 \"radialNoise\" 1 1 \"curveGain\" 1 1 \"curveOffset\" 1 1 \"octaves\" 1 1 \"gain\" 1 1 \"lacunarity\" 1 1 \"gamma\" 1 1 \"amplitude\" 3 1 \"itterations\" 1 1 \"offset\" 4 1 \"scale\" 4 1 \"suboffset\" 4 1 \"topoffset\" 4 1 \"subscale\" 4 1 \"topscale\" 4 1 \"center\" 3 1 0"
  kernelSource "//Based on https://github.com/Draradech/csworldgen/blob/master/simplexnoise.cpp\n//Ported by Mads Hagbarth Lund 2014\n\n/* Copyright (c) 2007-2012 Eliot Eshelman\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n\nint fastfloor( const float x ) \{ return x > 0 ? (int) x : (int) x - 1; \}\ninline float raw_noise_4d( const float x, const float y, const float z, const float w ) \n\{\nint simplex\[64]\[4] = \{\n    \{0,1,2,3\},\{0,1,3,2\},\{0,0,0,0\},\{0,2,3,1\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{1,2,3,0\},\n    \{0,2,1,3\},\{0,0,0,0\},\{0,3,1,2\},\{0,3,2,1\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{1,3,2,0\},\n    \{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\n    \{1,2,0,3\},\{0,0,0,0\},\{1,3,0,2\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{2,3,0,1\},\{2,3,1,0\},\n    \{1,0,2,3\},\{1,0,3,2\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{2,0,3,1\},\{0,0,0,0\},\{2,1,3,0\},\n    \{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\n    \{2,0,1,3\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{3,0,1,2\},\{3,0,2,1\},\{0,0,0,0\},\{3,1,2,0\},\n    \{2,1,0,3\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{3,1,0,2\},\{0,0,0,0\},\{3,2,0,1\},\{3,2,1,0\}\n\};\n    int perm\[512] = \{\n        151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,\n        8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,\n        35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,\n        134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,\n        55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208, 89,\n        18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,\n        250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,\n        189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,\n        172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,\n        228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,\n        107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,\n        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,\n\n        151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,\n        8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,\n        35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,\n        134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,\n        55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208, 89,\n        18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,\n        250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,\n        189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,\n        172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,\n        228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,\n        107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,\n        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180\n    \};\n   int grad4\[32]\[4]= \{\n    \{0,1,1,1\},  \{0,1,1,-1\},  \{0,1,-1,1\},  \{0,1,-1,-1\},\n    \{0,-1,1,1\}, \{0,-1,1,-1\}, \{0,-1,-1,1\}, \{0,-1,-1,-1\},\n    \{1,0,1,1\},  \{1,0,1,-1\},  \{1,0,-1,1\},  \{1,0,-1,-1\},\n    \{-1,0,1,1\}, \{-1,0,1,-1\}, \{-1,0,-1,1\}, \{-1,0,-1,-1\},\n    \{1,1,0,1\},  \{1,1,0,-1\},  \{1,-1,0,1\},  \{1,-1,0,-1\},\n    \{-1,1,0,1\}, \{-1,1,0,-1\}, \{-1,-1,0,1\}, \{-1,-1,0,-1\},\n    \{1,1,1,0\},  \{1,1,-1,0\},  \{1,-1,1,0\},  \{1,-1,-1,0\},\n    \{-1,1,1,0\}, \{-1,1,-1,0\}, \{-1,-1,1,0\}, \{-1,-1,-1,0\}\n   \};\n    float F4 = (sqrt(5.0f)-1.0f)/4.0f;\n    float G4 = (5.0f-sqrt(5.0f))/20.0f;\n    float n0, n1, n2, n3, n4;\n    float s = (x + y + z + w) * F4;\n    int i = fastfloor(x + s);\n    int j = fastfloor(y + s);\n    int k = fastfloor(z + s);\n    int l = fastfloor(w + s);\n    float t = (i + j + k + l) * G4;\n    float X0 = i - t;\n    float Y0 = j - t;\n    float Z0 = k - t;\n    float W0 = l - t;\n\n    float x0 = x - X0;\n    float y0 = y - Y0;\n    float z0 = z - Z0;\n    float w0 = w - W0;\n    int c1 = (x0 > y0) ? 32 : 0;\n    int c2 = (x0 > z0) ? 16 : 0;\n    int c3 = (y0 > z0) ? 8 : 0;\n    int c4 = (x0 > w0) ? 4 : 0;\n    int c5 = (y0 > w0) ? 2 : 0;\n    int c6 = (z0 > w0) ? 1 : 0;\n    int c = c1 + c2 + c3 + c4 + c5 + c6;\n\n    int i1, j1, k1, l1;\n    int i2, j2, k2, l2;\n    int i3, j3, k3, l3;\n    i1 = simplex\[c]\[0]>=3 ? 1 : 0;\n    j1 = simplex\[c]\[1]>=3 ? 1 : 0;\n    k1 = simplex\[c]\[2]>=3 ? 1 : 0;\n    l1 = simplex\[c]\[3]>=3 ? 1 : 0;\n    i2 = simplex\[c]\[0]>=2 ? 1 : 0;\n    j2 = simplex\[c]\[1]>=2 ? 1 : 0;\n    k2 = simplex\[c]\[2]>=2 ? 1 : 0;\n    l2 = simplex\[c]\[3]>=2 ? 1 : 0;\n    i3 = simplex\[c]\[0]>=1 ? 1 : 0;\n    j3 = simplex\[c]\[1]>=1 ? 1 : 0;\n    k3 = simplex\[c]\[2]>=1 ? 1 : 0;\n    l3 = simplex\[c]\[3]>=1 ? 1 : 0;\n    float x1 = x0 - i1 + G4;\n    float y1 = y0 - j1 + G4;\n    float z1 = z0 - k1 + G4;\n    float w1 = w0 - l1 + G4;\n    float x2 = x0 - i2 + 2.0*G4;\n    float y2 = y0 - j2 + 2.0*G4;\n    float z2 = z0 - k2 + 2.0*G4;\n    float w2 = w0 - l2 + 2.0*G4;\n    float x3 = x0 - i3 + 3.0*G4;\n    float y3 = y0 - j3 + 3.0*G4;\n    float z3 = z0 - k3 + 3.0*G4;\n    float w3 = w0 - l3 + 3.0*G4;\n    float x4 = x0 - 1.0 + 4.0*G4;\n    float y4 = y0 - 1.0 + 4.0*G4;\n    float z4 = z0 - 1.0 + 4.0*G4;\n    float w4 = w0 - 1.0 + 4.0*G4;\n    int ii = i & 255;\n    int jj = j & 255;\n    int kk = k & 255;\n    int ll = l & 255;\n    int gi0 = perm\[ii+perm\[jj+perm\[kk+perm\[ll]]]] % 32;\n    int gi1 = perm\[ii+i1+perm\[jj+j1+perm\[kk+k1+perm\[ll+l1]]]] % 32;\n    int gi2 = perm\[ii+i2+perm\[jj+j2+perm\[kk+k2+perm\[ll+l2]]]] % 32;\n    int gi3 = perm\[ii+i3+perm\[jj+j3+perm\[kk+k3+perm\[ll+l3]]]] % 32;\n    int gi4 = perm\[ii+1+perm\[jj+1+perm\[kk+1+perm\[ll+1]]]] % 32;\n    float t0 = 0.6 - x0*x0 - y0*y0 - z0*z0 - w0*w0;\n    if(t0<0) n0 = 0.0;\n    else \{\n        t0 *= t0;\n        n0 = t0 * t0 * dot(float4(grad4\[gi0]\[0],grad4\[gi0]\[2],grad4\[gi0]\[3],grad4\[gi0]\[3]), float4(x0, y0, z0, w0));\n    \}\n    float t1 = 0.6 - x1*x1 - y1*y1 - z1*z1 - w1*w1;\n    if(t1<0) n1 = 0.0;\n    else \{\n        t1 *= t1;\n        n1 = t1 * t1 * dot(float4(grad4\[gi1]\[0],grad4\[gi1]\[2],grad4\[gi1]\[3],grad4\[gi1]\[3]), float4(x1, y1, z1, w1));\n    \}\n    float t2 = 0.6 - x2*x2 - y2*y2 - z2*z2 - w2*w2;\n    if(t2<0) n2 = 0.0;\n    else \{\n        t2 *= t2;\n        n2 = t2 * t2 * dot(float4(grad4\[gi2]\[0],grad4\[gi2]\[2],grad4\[gi2]\[3],grad4\[gi2]\[3]), float4(x2, y2, z2, w2));\n    \}\n    float t3 = 0.6 - x3*x3 - y3*y3 - z3*z3 - w3*w3;\n    if(t3<0) n3 = 0.0;\n    else \{\n        t3 *= t3;\n        n3 = t3 * t3 * dot(float4(grad4\[gi3]\[0],grad4\[gi3]\[2],grad4\[gi3]\[3],grad4\[gi3]\[3]), float4(x3, y3, z3, w3));\n    \}\n    float t4 = 0.6 - x4*x4 - y4*y4 - z4*z4 - w4*w4;\n    if(t4<0) n4 = 0.0;\n    else \{\n        t4 *= t4;\n        n4 = t4 * t4 * dot(float4(grad4\[gi4]\[0],grad4\[gi4]\[2],grad4\[gi4]\[3],grad4\[gi4]\[3]), float4(x4, y4, z4, w4));\n    \}\n    return 27.0 * (n0 + n1 + n2 + n3 + n4);\n\}\n\n\n\n\nkernel Noise4D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n    Image<eRead, eAccessPoint, eEdgeClamped> modix;\n  Image<eWrite, eAccessPoint> dst;\nparam:\n    bool absNoise;\n    bool curveNoise;\n    bool curveInvert;\n    bool radialNoise;\n    float curveGain;\n    float curveOffset;\n    int octaves;\n    float gain;\n    float lacunarity;\n    float gamma;\n    float3 amplitude;\n    int itterations;\n    float4 offset;\n    float4 scale;\n    float4 suboffset;\n    float4 topoffset;\n    float4 subscale;\n    float4 topscale;\n    float3 center;\n\n\n  void define() \{\n        defineParam (absNoise, \"absNoise\", false);    \n        defineParam (curveNoise, \"curveNoise\", false);    \n        defineParam (curveInvert, \"curveInvert\", false);   \n        defineParam (radialNoise, \"radialNoise\", false);   //Used for radial noise\n        defineParam (curveGain, \"curveGain\", 1.0f);\n        defineParam (curveOffset, \"curveOffset\", 1.0f);\n        defineParam (octaves, \"Octaves\", 10);\n        defineParam (gain, \"Gain\", 0.5f);\n        defineParam (lacunarity, \"Lacunarity\", 2.0f);\n        defineParam (gamma, \"Gamma\", 0.5f);\n        defineParam (amplitude, \"amplitude\", float3(0.5f));\n        defineParam (itterations, \"itterations\", 1);\n        defineParam(offset, \"Offset\", float4(0.0f, 0.0f, 0.0f,0.0f));\n        defineParam(scale, \"Scale\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(suboffset, \"suboffset\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(topoffset, \"topoffset\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(subscale, \"subscale\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(topscale, \"topscale\", float4(1.0f, 1.0f, 1.0f,1.0f));   \n        defineParam(center, \"center\", float3(0.0f,0.0f,0.0f));   //Center for the radial noise      \n  \}\n\nfloat4 sphericalTransform( const float4 cartesian) \n\{\n    return float4(\n(atan2(cartesian.x-center.x,cartesian.y-center.y)+ PI)/+ (PI*2.0f),\n(atan2(cartesian.x-center.x,cartesian.z-center.z)+ PI)/+ (PI*2.0f),\n(atan2(cartesian.z-center.z,cartesian.y-center.y)+ PI)/+ (PI*2.0f),\ncartesian.w\n);\n\}\n\nfloat octave_noise_4d( float4 modulix, const float octaves, const float persistence, const float scale, const float x, const float y, const float z, const float w ) \n\{\n    float total = 0.0f;\n    float current;\n    float last = 1.0f;\n    float frequency = scale;\n    float amplitude = 1.0f;\n    float maxAmplitude = 0.0f;\n    float4 Tempoffset;\n    float4 Tempscale;\n\n\n    for( int i=0; i < octaves; i++ ) \{\n\n        /*\n        if (i == 0) \{\n            total += (float)raw_noise_4d( (x+suboffset.x) * frequency, (y+suboffset.y) * frequency, (z+suboffset.z) * frequency, (w+suboffset.w) * frequency ) * amplitude;\n        \}\n        else if (i == octaves-1) \{\n            total += (float)raw_noise_4d( (x+topoffset.x) * frequency, (y+topoffset.y) * frequency, (z+topoffset.z) * frequency, (w+topoffset.w) * frequency ) * amplitude;\n        \}\n        else \{\n            total += (float)raw_noise_4d( x * frequency, y * frequency, z * frequency, w * frequency ) * amplitude;\n        \}\n        */\n\n\n        Tempscale = (topscale * (i/(octaves-1.0f)))+(subscale * (1-(i/(octaves-1.0f))));       \n        Tempoffset = ((topoffset+modulix.y) * (i/(octaves-1.0f)))+((suboffset+modulix.x) * (1-(i/(octaves-1.0f))));\n        current = (float)raw_noise_4d(   ((x*Tempscale.x)+Tempoffset.x) * frequency, \n                                        ((y*Tempscale.y)+Tempoffset.y) * frequency, \n                                        ((z*Tempscale.z)+Tempoffset.z) * frequency, \n                                        ((w*Tempscale.w)+Tempoffset.w) * frequency \n                                        ) * amplitude;\n        if (i == 0 && curveNoise)\{\n            if (curveInvert)\{\n                last = 0.5f-current;  \n            \}\n            else\{\n                last = current;  \n            \}\n               \n        \}\n        current = curveNoise?current*((last+curveOffset)*curveGain):current;\n        total += absNoise?fabs(current):current;\n        frequency *= 2.0f;\n        maxAmplitude += amplitude;\n        amplitude *= persistence;\n\n    \}\n    return float(total / maxAmplitude);\n\}\n\n\n\n\n  void process() \{\n    float4 srcSample = float4(src(0),src(1),src(2),src(3));\n    float4 srcSampleModix = modix();\n    float sampleR,sampleG,sampleB;\n    if (radialNoise)\{\n        srcSample = sphericalTransform(srcSample);\n    \}\n\n    for( int i=0; i < itterations; i++ ) \{\n        sampleR = (float)octave_noise_4d(srcSampleModix,float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w) * amplitude.x;\n        sampleG = (float)octave_noise_4d(srcSampleModix,float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w - 100.0f) * amplitude.y;\n        sampleB = (float)octave_noise_4d(srcSampleModix,float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w + 200.0f) * amplitude.z;\n        srcSample = float4(srcSample.x+sampleR,srcSample.y+sampleG,srcSample.z+sampleB,srcSample.w);\n    \}\n    dst() = float4(srcSample.x,srcSample.y,srcSample.z,1.0f);\n\}\n\};"
  useGPUIfAvailable {{parent.boolean}}
  rebuild ""
  Noise4D_curveNoise {{parent.CurveNoise_Enable}}
  Noise4D_curveInvert {{parent.CurveNoise_Invert}}
  Noise4D_curveGain {{parent.CurveGain}}
  Noise4D_curveOffset {{parent.CurveOffset}}
  Noise4D_Octaves {{parent.Noise_Octaves}}
  Noise4D_Gain {{parent.Noise_Gain}}
  Noise4D_Lacunarity {{parent.Noise_Lacunarity}}
  Noise4D_Gamma 0.79
  Noise4D_amplitude {{parent.Amplitude.r} {parent.Amplitude.g} {parent.Amplitude.b}}
  Noise4D_itterations {{parent.Itterations}}
  Noise4D_Offset {{parent.Freq_Offset} {parent.Freq_Offset} {parent.Freq_Offset} {parent.Freq_Offset}}
  Noise4D_Scale {{parent.Freq_GeneralScale} {parent.Freq_GeneralScale} {parent.Freq_GeneralScale} {parent.Freq_GeneralScale}}
  Noise4D_suboffset {{(frame*parent.Freq_EvolveLow.r)/50} {(frame*parent.Freq_EvolveLow.g)/50} {(frame*parent.Freq_EvolveLow.b)/50} {(frame*parent.Freq_EvolveLow.a)/50}}
  Noise4D_topoffset {{(frame*parent.Freq_EvolveHigh.r)/10} {(frame*parent.Freq_EvolveHigh.g)/10} {(frame*parent.Freq_EvolveHigh.b)/10} {(frame*parent.Freq_EvolveHigh.a)/10}}
  Noise4D_subscale {{parent.Freq_ScaleLow} {parent.Freq_ScaleLow} {parent.Freq_ScaleLow} {parent.Freq_ScaleLow}}
  Noise4D_topscale {{parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh}}
  rebuild_finalise ""
  name Noise4D2
  xpos -338
  ypos 319
 }
push $N96eb680
 BlinkScript {
  kernelSourceFile /Users/madshagbarth/Github/Nuke-Private/Blink/PointRender/Modify/Fractal_v06.cpp
  recompileCount 60
  ProgramGroup 1
  KernelDescription "2 \"Noise4D\" iterate pixelWise d54284af3e5573ad197bef9032773e8653de2cad590694fcc9fd5af993e97da3 2 \"src\" Read Point \"dst\" Write Point 17 \"absNoise\" Bool 1 AA== \"curveNoise\" Bool 1 AA== \"curveInvert\" Bool 1 AA== \"curveGain\" Float 1 AACAPw== \"curveOffset\" Float 1 AACAPw== \"Octaves\" Int 1 CgAAAA== \"Gain\" Float 1 AAAAPw== \"Lacunarity\" Float 1 AAAAQA== \"Gamma\" Float 1 AAAAPw== \"amplitude\" Float 3 AAAAPwAAAD8AAAA/AAAAAA== \"itterations\" Int 1 AQAAAA== \"Offset\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"Scale\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"suboffset\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"topoffset\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"subscale\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"topscale\" Float 4 AACAPwAAgD8AAIA/AACAPw== 17 \"absNoise\" 1 1 \"curveNoise\" 1 1 \"curveInvert\" 1 1 \"curveGain\" 1 1 \"curveOffset\" 1 1 \"octaves\" 1 1 \"gain\" 1 1 \"lacunarity\" 1 1 \"gamma\" 1 1 \"amplitude\" 3 1 \"itterations\" 1 1 \"offset\" 4 1 \"scale\" 4 1 \"suboffset\" 4 1 \"topoffset\" 4 1 \"subscale\" 4 1 \"topscale\" 4 1 0"
  kernelSource "//Based on https://github.com/Draradech/csworldgen/blob/master/simplexnoise.cpp\n//Ported by Mads Hagbarth Lund 2014\n\n/* Copyright (c) 2007-2012 Eliot Eshelman\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n\nint fastfloor( const float x ) \{ return x > 0 ? (int) x : (int) x - 1; \}\ninline float raw_noise_4d( const float x, const float y, const float z, const float w ) \n\{\nint simplex\[64]\[4] = \{\n    \{0,1,2,3\},\{0,1,3,2\},\{0,0,0,0\},\{0,2,3,1\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{1,2,3,0\},\n    \{0,2,1,3\},\{0,0,0,0\},\{0,3,1,2\},\{0,3,2,1\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{1,3,2,0\},\n    \{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\n    \{1,2,0,3\},\{0,0,0,0\},\{1,3,0,2\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{2,3,0,1\},\{2,3,1,0\},\n    \{1,0,2,3\},\{1,0,3,2\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{2,0,3,1\},\{0,0,0,0\},\{2,1,3,0\},\n    \{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\n    \{2,0,1,3\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{3,0,1,2\},\{3,0,2,1\},\{0,0,0,0\},\{3,1,2,0\},\n    \{2,1,0,3\},\{0,0,0,0\},\{0,0,0,0\},\{0,0,0,0\},\{3,1,0,2\},\{0,0,0,0\},\{3,2,0,1\},\{3,2,1,0\}\n\};\n    int perm\[512] = \{\n        151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,\n        8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,\n        35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,\n        134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,\n        55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208, 89,\n        18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,\n        250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,\n        189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,\n        172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,\n        228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,\n        107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,\n        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,\n\n        151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,\n        8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,\n        35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,\n        134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,\n        55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208, 89,\n        18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,\n        250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,\n        189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,\n        172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,\n        228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,\n        107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,\n        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180\n    \};\n   int grad4\[32]\[4]= \{\n    \{0,1,1,1\},  \{0,1,1,-1\},  \{0,1,-1,1\},  \{0,1,-1,-1\},\n    \{0,-1,1,1\}, \{0,-1,1,-1\}, \{0,-1,-1,1\}, \{0,-1,-1,-1\},\n    \{1,0,1,1\},  \{1,0,1,-1\},  \{1,0,-1,1\},  \{1,0,-1,-1\},\n    \{-1,0,1,1\}, \{-1,0,1,-1\}, \{-1,0,-1,1\}, \{-1,0,-1,-1\},\n    \{1,1,0,1\},  \{1,1,0,-1\},  \{1,-1,0,1\},  \{1,-1,0,-1\},\n    \{-1,1,0,1\}, \{-1,1,0,-1\}, \{-1,-1,0,1\}, \{-1,-1,0,-1\},\n    \{1,1,1,0\},  \{1,1,-1,0\},  \{1,-1,1,0\},  \{1,-1,-1,0\},\n    \{-1,1,1,0\}, \{-1,1,-1,0\}, \{-1,-1,1,0\}, \{-1,-1,-1,0\}\n   \};\n    float F4 = (sqrt(5.0f)-1.0f)/4.0f;\n    float G4 = (5.0f-sqrt(5.0f))/20.0f;\n    float n0, n1, n2, n3, n4;\n    float s = (x + y + z + w) * F4;\n    int i = fastfloor(x + s);\n    int j = fastfloor(y + s);\n    int k = fastfloor(z + s);\n    int l = fastfloor(w + s);\n    float t = (i + j + k + l) * G4;\n    float X0 = i - t;\n    float Y0 = j - t;\n    float Z0 = k - t;\n    float W0 = l - t;\n\n    float x0 = x - X0;\n    float y0 = y - Y0;\n    float z0 = z - Z0;\n    float w0 = w - W0;\n    int c1 = (x0 > y0) ? 32 : 0;\n    int c2 = (x0 > z0) ? 16 : 0;\n    int c3 = (y0 > z0) ? 8 : 0;\n    int c4 = (x0 > w0) ? 4 : 0;\n    int c5 = (y0 > w0) ? 2 : 0;\n    int c6 = (z0 > w0) ? 1 : 0;\n    int c = c1 + c2 + c3 + c4 + c5 + c6;\n\n    int i1, j1, k1, l1;\n    int i2, j2, k2, l2;\n    int i3, j3, k3, l3;\n    i1 = simplex\[c]\[0]>=3 ? 1 : 0;\n    j1 = simplex\[c]\[1]>=3 ? 1 : 0;\n    k1 = simplex\[c]\[2]>=3 ? 1 : 0;\n    l1 = simplex\[c]\[3]>=3 ? 1 : 0;\n    i2 = simplex\[c]\[0]>=2 ? 1 : 0;\n    j2 = simplex\[c]\[1]>=2 ? 1 : 0;\n    k2 = simplex\[c]\[2]>=2 ? 1 : 0;\n    l2 = simplex\[c]\[3]>=2 ? 1 : 0;\n    i3 = simplex\[c]\[0]>=1 ? 1 : 0;\n    j3 = simplex\[c]\[1]>=1 ? 1 : 0;\n    k3 = simplex\[c]\[2]>=1 ? 1 : 0;\n    l3 = simplex\[c]\[3]>=1 ? 1 : 0;\n    float x1 = x0 - i1 + G4;\n    float y1 = y0 - j1 + G4;\n    float z1 = z0 - k1 + G4;\n    float w1 = w0 - l1 + G4;\n    float x2 = x0 - i2 + 2.0*G4;\n    float y2 = y0 - j2 + 2.0*G4;\n    float z2 = z0 - k2 + 2.0*G4;\n    float w2 = w0 - l2 + 2.0*G4;\n    float x3 = x0 - i3 + 3.0*G4;\n    float y3 = y0 - j3 + 3.0*G4;\n    float z3 = z0 - k3 + 3.0*G4;\n    float w3 = w0 - l3 + 3.0*G4;\n    float x4 = x0 - 1.0 + 4.0*G4;\n    float y4 = y0 - 1.0 + 4.0*G4;\n    float z4 = z0 - 1.0 + 4.0*G4;\n    float w4 = w0 - 1.0 + 4.0*G4;\n    int ii = i & 255;\n    int jj = j & 255;\n    int kk = k & 255;\n    int ll = l & 255;\n    int gi0 = perm\[ii+perm\[jj+perm\[kk+perm\[ll]]]] % 32;\n    int gi1 = perm\[ii+i1+perm\[jj+j1+perm\[kk+k1+perm\[ll+l1]]]] % 32;\n    int gi2 = perm\[ii+i2+perm\[jj+j2+perm\[kk+k2+perm\[ll+l2]]]] % 32;\n    int gi3 = perm\[ii+i3+perm\[jj+j3+perm\[kk+k3+perm\[ll+l3]]]] % 32;\n    int gi4 = perm\[ii+1+perm\[jj+1+perm\[kk+1+perm\[ll+1]]]] % 32;\n    float t0 = 0.6 - x0*x0 - y0*y0 - z0*z0 - w0*w0;\n    if(t0<0) n0 = 0.0;\n    else \{\n        t0 *= t0;\n        n0 = t0 * t0 * dot(float4(grad4\[gi0]\[0],grad4\[gi0]\[2],grad4\[gi0]\[3],grad4\[gi0]\[3]), float4(x0, y0, z0, w0));\n    \}\n    float t1 = 0.6 - x1*x1 - y1*y1 - z1*z1 - w1*w1;\n    if(t1<0) n1 = 0.0;\n    else \{\n        t1 *= t1;\n        n1 = t1 * t1 * dot(float4(grad4\[gi1]\[0],grad4\[gi1]\[2],grad4\[gi1]\[3],grad4\[gi1]\[3]), float4(x1, y1, z1, w1));\n    \}\n    float t2 = 0.6 - x2*x2 - y2*y2 - z2*z2 - w2*w2;\n    if(t2<0) n2 = 0.0;\n    else \{\n        t2 *= t2;\n        n2 = t2 * t2 * dot(float4(grad4\[gi2]\[0],grad4\[gi2]\[2],grad4\[gi2]\[3],grad4\[gi2]\[3]), float4(x2, y2, z2, w2));\n    \}\n    float t3 = 0.6 - x3*x3 - y3*y3 - z3*z3 - w3*w3;\n    if(t3<0) n3 = 0.0;\n    else \{\n        t3 *= t3;\n        n3 = t3 * t3 * dot(float4(grad4\[gi3]\[0],grad4\[gi3]\[2],grad4\[gi3]\[3],grad4\[gi3]\[3]), float4(x3, y3, z3, w3));\n    \}\n    float t4 = 0.6 - x4*x4 - y4*y4 - z4*z4 - w4*w4;\n    if(t4<0) n4 = 0.0;\n    else \{\n        t4 *= t4;\n        n4 = t4 * t4 * dot(float4(grad4\[gi4]\[0],grad4\[gi4]\[2],grad4\[gi4]\[3],grad4\[gi4]\[3]), float4(x4, y4, z4, w4));\n    \}\n    return 27.0 * (n0 + n1 + n2 + n3 + n4);\n\}\n\n\n\n\nkernel Noise4D : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite, eAccessPoint> dst;\nparam:\n    bool absNoise;\n    bool curveNoise;\n    bool curveInvert;\n    float curveGain;\n    float curveOffset;\n    int octaves;\n    float gain;\n    float lacunarity;\n    float gamma;\n    float3 amplitude;\n    int itterations;\n    float4 offset;\n    float4 scale;\n    float4 suboffset;\n    float4 topoffset;\n    float4 subscale;\n    float4 topscale;\n\n\n  void define() \{\n        defineParam (absNoise, \"absNoise\", false);    \n        defineParam (curveNoise, \"curveNoise\", false);    \n        defineParam (curveInvert, \"curveInvert\", false);   \n        defineParam (curveGain, \"curveGain\", 1.0f);\n        defineParam (curveOffset, \"curveOffset\", 1.0f);\n        defineParam (octaves, \"Octaves\", 10);\n        defineParam (gain, \"Gain\", 0.5f);\n        defineParam (lacunarity, \"Lacunarity\", 2.0f);\n        defineParam (gamma, \"Gamma\", 0.5f);\n        defineParam (amplitude, \"amplitude\", float3(0.5f));\n        defineParam (itterations, \"itterations\", 1);\n        defineParam(offset, \"Offset\", float4(0.0f, 0.0f, 0.0f,0.0f));\n        defineParam(scale, \"Scale\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(suboffset, \"suboffset\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(topoffset, \"topoffset\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(subscale, \"subscale\", float4(1.0f, 1.0f, 1.0f,1.0f));\n        defineParam(topscale, \"topscale\", float4(1.0f, 1.0f, 1.0f,1.0f));        \n  \}\n\nfloat octave_noise_4d( const float octaves, const float persistence, const float scale, const float x, const float y, const float z, const float w ) \n\{\n    float total = 0.0f;\n    float current;\n    float last = 1.0f;\n    float frequency = scale;\n    float amplitude = 1.0f;\n    float maxAmplitude = 0.0f;\n    float4 Tempoffset;\n    float4 Tempscale;\n\n\n    for( int i=0; i < octaves; i++ ) \{\n\n        /*\n        if (i == 0) \{\n            total += (float)raw_noise_4d( (x+suboffset.x) * frequency, (y+suboffset.y) * frequency, (z+suboffset.z) * frequency, (w+suboffset.w) * frequency ) * amplitude;\n        \}\n        else if (i == octaves-1) \{\n            total += (float)raw_noise_4d( (x+topoffset.x) * frequency, (y+topoffset.y) * frequency, (z+topoffset.z) * frequency, (w+topoffset.w) * frequency ) * amplitude;\n        \}\n        else \{\n            total += (float)raw_noise_4d( x * frequency, y * frequency, z * frequency, w * frequency ) * amplitude;\n        \}\n        */\n\n\n        Tempscale = (topscale * (i/(octaves-1.0f)))+(subscale * (1-(i/(octaves-1.0f))));       \n        Tempoffset = (topoffset * (i/(octaves-1.0f)))+(suboffset * (1-(i/(octaves-1.0f))));\n        current = (float)raw_noise_4d(   ((x*Tempscale.x)+Tempoffset.x) * frequency, \n                                        ((y*Tempscale.y)+Tempoffset.y) * frequency, \n                                        ((z*Tempscale.z)+Tempoffset.z) * frequency, \n                                        ((w*Tempscale.w)+Tempoffset.w) * frequency \n                                        ) * amplitude;\n        if (i == 0 && curveNoise)\{\n            if (curveInvert)\{\n                last = 0.5f-current;  \n            \}\n            else\{\n                last = current;  \n            \}\n               \n        \}\n        current = curveNoise?current*((last+curveOffset)*curveGain):current;\n        total += absNoise?fabs(current):current;\n        frequency *= 2.0f;\n        maxAmplitude += amplitude;\n        amplitude *= persistence;\n\n    \}\n    return float(total / maxAmplitude);\n\}\n\n\n\n\n  void process() \{\n    float4 srcSample = float4(src(0),src(1),src(2),src(3));\n    float sampleR,sampleG,sampleB;\n    for( int i=0; i < itterations; i++ ) \{\n        sampleR = (float)octave_noise_4d(float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w) * amplitude.x;\n        sampleG = (float)octave_noise_4d(float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w - 100.0f) * amplitude.y;\n        sampleB = (float)octave_noise_4d(float(octaves), gain, lacunarity, ( srcSample.x * scale.x ) + offset.x, ( srcSample.y * scale.y ) + offset.y,  ( srcSample.z * scale.z ) + offset.z, ( srcSample.w * scale.w ) + offset.w + 200.0f) * amplitude.z;\n        srcSample = float4(srcSample.x+sampleR,srcSample.y+sampleG,srcSample.z+sampleB,srcSample.w);\n    \}\n    dst() = float4(srcSample.x,srcSample.y,srcSample.z,1.0f);\n\}\n\};"
  useGPUIfAvailable {{parent.boolean}}
  rebuild ""
  Noise4D_curveNoise {{parent.CurveNoise_Enable}}
  Noise4D_curveInvert {{parent.CurveNoise_Invert}}
  Noise4D_curveGain {{parent.CurveGain}}
  Noise4D_curveOffset {{parent.CurveOffset}}
  Noise4D_Octaves {{parent.Noise_Octaves}}
  Noise4D_Gain {{parent.Noise_Gain}}
  Noise4D_Lacunarity {{parent.Noise_Lacunarity}}
  Noise4D_Gamma 0.79
  Noise4D_amplitude {{parent.Amplitude.r} {parent.Amplitude.g} {parent.Amplitude.b}}
  Noise4D_itterations {{parent.Itterations}}
  Noise4D_Offset {{parent.Freq_Offset} {parent.Freq_Offset} {parent.Freq_Offset} {parent.Freq_Offset}}
  Noise4D_Scale {{parent.Freq_GeneralScale} {parent.Freq_GeneralScale} {parent.Freq_GeneralScale} {parent.Freq_GeneralScale}}
  Noise4D_suboffset {{(frame*parent.Freq_EvolveLow.r)/50} {(frame*parent.Freq_EvolveLow.g)/50} {(frame*parent.Freq_EvolveLow.b)/50} {(frame*parent.Freq_EvolveLow.a)/50}}
  Noise4D_topoffset {{(frame*parent.Freq_EvolveHigh.r)/10} {(frame*parent.Freq_EvolveHigh.g)/10} {(frame*parent.Freq_EvolveHigh.b)/10} {(frame*parent.Freq_EvolveHigh.a)/10}}
  Noise4D_subscale {{parent.Freq_ScaleLow} {parent.Freq_ScaleLow} {parent.Freq_ScaleLow} {parent.Freq_ScaleLow}}
  Noise4D_topscale {{parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh} {parent.Freq_ScaleHigh}}
  rebuild_finalise ""
  name Noise4D1
  selected true
  xpos -470
  ypos 267
 }
 Switch {
  inputs 2
  which {{parent.EnableOffset}}
  name Switch1
  xpos -470
  ypos 325
 }
 Expression {
  expr0 abs(r)
  expr1 abs(g)
  expr2 abs(b)
  name Expression2
  xpos -470
  ypos 349
  disable {{!parent.Noise_Absolute}}
 }
 Shuffle {
  out pos
  name Shuffle2
  xpos -470
  ypos 420
 }
push $N96bedd0
 Merge2 {
  inputs 2+1
  operation copy
  bbox B
  Achannels {pos.red pos.green pos.blue -pos.alpha}
  Bchannels {pos.red pos.green pos.blue -pos.alpha}
  output {pos.red pos.green pos.blue -pos.alpha}
  maskChannelMask -rgba.alpha
  name Merge1
  xpos -582
  ypos 416
 }
 Output {
  name Output1
  xpos -582
  ypos 587
 }
push $N96bedd0
 Crop {
  box {0 0 {width} {height}}
  reformat true
  crop false
  name InputFormat
  xpos -713
  ypos 111
 }
 StickyNote {
  inputs 0
  name StickyNote1
  label "These two noise scripts are alsmost identical.\nThe problem is that adding 1 extra input does eat up a lot of performence,\nso when we don't need the input we should avoid using it."
  xpos -239
  ypos 269
 }
end_group
Noise {
 inputs 0
 zoffset {{frame}}
 center {1024 778}
 name Noise1
 xpos 1407
 ypos -468
}
Grade {
 channels all
 white 0.4
 name Grade1
 xpos 1407
 ypos -393
 disable true
}
Dot {
 name Dot2
 xpos 1441
 ypos -261
}
set N1c7d8c20 [stack 0]
TimeOffset {
 time_offset 1
 time ""
 name TimeOffset1
 xpos 1520
 ypos -265
}
set N20bf8230 [stack 0]
TimeOffset {
 time_offset 1
 time ""
 name TimeOffset2
 xpos 1630
 ypos -265
}
set N138e0180 [stack 0]
TimeOffset {
 time_offset 1
 time ""
 name TimeOffset3
 xpos 1750
 ypos -265
}
set N1346d7b0 [stack 0]
TimeOffset {
 time_offset 1
 time ""
 name TimeOffset4
 xpos 1860
 ypos -265
}
set N1364d910 [stack 0]
TimeOffset {
 time_offset 1
 time ""
 name TimeOffset5
 xpos 1980
 ypos -265
}
set N149af530 [stack 0]
TimeOffset {
 time_offset 1
 time ""
 name TimeOffset6
 xpos 2090
 ypos -265
}
set N13241bd0 [stack 0]
TimeOffset {
 time_offset 1
 time ""
 name TimeOffset7
 xpos 2210
 ypos -265
}
set N307fbaf0 [stack 0]
TimeOffset {
 time_offset 1
 time ""
 name TimeOffset8
 xpos 2320
 ypos -265
}
set N4afa700 [stack 0]
push $N307fbaf0
push $N13241bd0
push $N149af530
push $N1364d910
push $N1346d7b0
push $N138e0180
push $N20bf8230
push $N1c7d8c20
Merge2 {
 inputs 2
 name Merge5
 xpos 1554
 ypos -89
}
Merge2 {
 inputs 2
 name Merge6
 xpos 1606
 ypos -55
}
Merge2 {
 inputs 2
 name Merge7
 xpos 1673
 ypos -5
}
Merge2 {
 inputs 2
 name Merge8
 xpos 1771
 ypos 35
}
Merge2 {
 inputs 2
 name Merge9
 xpos 1887
 ypos 47
}
Merge2 {
 inputs 2
 name Merge10
 xpos 1993
 ypos 67
}
Merge2 {
 inputs 2
 name Merge11
 xpos 2114
 ypos 77
}
Merge2 {
 inputs 2
 name Merge12
 xpos 2253
 ypos 90
}
push $N20bf8230
push $N138e0180
push $N1346d7b0
push $N1364d910
push $N149af530
push $N13241bd0
push $N307fbaf0
push 0
push $N4afa700
push $N1c7d8c20
Merge2 {
 inputs 9+1
 name Merge4
 xpos 1407
 ypos -147
}
ColorWheel {
 inputs 0
 gamma 0.45
 name ColorWheel1
 xpos 1668
 ypos -850
}
Noise {
 inputs 0
 zoffset {{frame}}
 center {1024 778}
 name Noise2
 xpos 1584
 ypos -783
}
Dot {
 name Dot3
 xpos 1619
 ypos -688
}
set N141f6af0 [stack 0]
CheckerBoard2 {
 inputs 0
 name CheckerBoard2
 xpos 1892
 ypos -814
}
set N13476470 [stack 0]
Merge2 {
 inputs 2
 name Merge1
 xpos 1892
 ypos -652
}
push $N141f6af0
Expression {
 expr0 a
 expr1 a
 expr2 a
 expr3 a
 name Expression1
 xpos 1717
 ypos -667
 disable true
}
Expression {
 expr0 1-a
 expr1 1-a
 expr2 1-a
 expr3 1-a
 name Expression2
 xpos 1717
 ypos -641
}
push $N13476470
Merge2 {
 inputs 2
 operation multiply
 name Merge2
 xpos 1809
 ypos -581
}
push $N141f6af0
Merge2 {
 inputs 2
 operation plus
 name Merge3
 xpos 1585
 ypos -472
}
Reformat {
 inputs 0
 format "2048 1024 0 0 2048 1024 1 2K_LatLong"
 name Reformat1
 xpos 1056
 ypos -42
}
Dot {
 name Dot1
 xpos 1090
 ypos 2
}
Axis3 {
 inputs 0
 rotate {0 {frame*5} 0}
 name Axis3
 xpos 814
 ypos -481
}
Camera3 {
 translate {0 0 20}
 name Camera4
 xpos 814
 ypos -360
}
Group {
 inputs 0
 name fog_noise
 tile_color 0xffffffff
 selected true
 xpos 181
 ypos -127
 addUserKnob {20 User l "SDF Noise"}
 addUserKnob {7 size t "The size of the noise." R 1 300}
 size 20
 addUserKnob {4 type t "The noise type." M {turbulence fBm "" ""}}
 type fBm
 addUserKnob {13 translation t "Translate the noise by this amount."}
 addUserKnob {3 octaves t "The number of different frequencies to use."}
 octaves 8
 addUserKnob {7 lacunarity t "The per octave frequency multiplier." R 1 10}
 lacunarity 3
 addUserKnob {7 gain t "The per octave amplitude multiplier."}
 gain 0.5
 addUserKnob {7 gamma t "The result will be raised to 1 over this power."}
 gamma 0.5
 addUserKnob {19 low_frequency_scale l "low frequency scale"}
 low_frequency_scale {1 1 1 1}
 addUserKnob {6 low_frequency_scale_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 high_frequency_scale l "high frequency scale"}
 high_frequency_scale {1 1 1 1}
 addUserKnob {6 high_frequency_scale_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 low_frequency_translation l "low frequency translation"}
 low_frequency_translation {0 0 0 0}
 addUserKnob {6 low_frequency_translation_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {19 high_frequency_translation l "high frequency translation"}
 high_frequency_translation {0 0 0 0}
 addUserKnob {6 high_frequency_translation_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 black_point l "black point" t "The black point of the noise."}
 addUserKnob {7 white_point l "white point" t "The white point of the noise."}
 addUserKnob {7 lift t "The amount to lift the noise."}
 addUserKnob {6 invert t "Invert the noise ie. white becomes black and vice versa." +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {6 diffuse t "Apply the noise to the diffuse material property." +STARTLINE}
 addUserKnob {6 specular t "Apply the noise to the specular material property." -STARTLINE}
 addUserKnob {6 transmission t "Apply the noise to the transmission material property." -STARTLINE}
 addUserKnob {6 emission t "Apply the noise to the emission material property." -STARTLINE}
 addUserKnob {6 specular_roughness l "specular roughness" t "Apply the noise to the specular roughness material property." +STARTLINE}
 addUserKnob {6 transmission_roughness l "transmission roughness" t "Apply the noise to the transmission roughness material property." -STARTLINE}
 addUserKnob {6 refractive_index l "refractive index" t "Apply the noise to the refractive index material property." +STARTLINE}
 addUserKnob {6 scattering t "Apply the noise to the scattering material property." +STARTLINE}
 scattering true
 addUserKnob {6 extinction t "Apply the noise to the extinction material property." -STARTLINE}
 extinction true
 addUserKnob {26 div0 l "" +STARTLINE}
 addUserKnob {26 info l "" +STARTLINE T "v2.1.0 - (c) Owen Bulka - 2022"}
}
add_layer {sdf_noise_params0 sdf_noise_params0.noise_options sdf_noise_params0.translationX sdf_noise_params0.translationY sdf_noise_params0.translationZ sdf_noise_params0.options sdf_noise_params0.x sdf_noise_params0.y sdf_noise_params0.z}
 Constant {
  inputs 0
  channels sdf_noise_params0
  color {{"(parent.extinction << 11) | (parent.scattering << 10) | (parent.invert << 9) | (parent.specular_roughness << 8) | (parent.transmission_roughness << 7) | (parent.refractive_index << 6) | (parent.emission << 5) | (parent.transmission << 4) | (parent.specular << 3) | (parent.diffuse << 2) | (parent.type << 1) | 1"} {-parent.translation.x} {-parent.translation.y} {-parent.translation.z}}
  format "1 1 0 0 1 1 1 1x1"
  name noise_params0
  xpos 862
  ypos 447
 }
 Dot {
  name Dot3
  xpos 896
  ypos 646
 }
add_layer {sdf_noise_params1 sdf_noise_params1.octaves sdf_noise_params1.lacunarity sdf_noise_params1.gain sdf_noise_params1.gamma}
 Constant {
  inputs 0
  channels sdf_noise_params1
  color {{parent.octaves} {parent.lacunarity} {parent.gain} {parent.gamma}}
  format "1 1 0 0 1 1 1 1x1"
  name noise_params1
  xpos 987
  ypos 447
 }
 Copy {
  inputs 2
  channels all
  name Copy8
  xpos 987
  ypos 714
 }
add_layer {sdf_noise_params2 sdf_noise_params2.size sdf_noise_params2.white_point sdf_noise_params2.black_point sdf_noise_params2.lift}
 Constant {
  inputs 0
  channels sdf_noise_params2
  color {{parent.size} {parent.white_point} {parent.black_point} {parent.lift}}
  format "1 1 0 0 1 1 1 1x1"
  name noise_params2
  xpos 1103
  ypos 449
 }
 Copy {
  inputs 2
  channels all
  name Copy1
  xpos 1103
  ypos 714
 }
add_layer {sdf_noise_params3 sdf_noise_params3.lowFrequencyX sdf_noise_params3.lowFrequencyY sdf_noise_params3.lowFrequencyZ sdf_noise_params3.lowFrequencyW}
 Constant {
  inputs 0
  channels sdf_noise_params3
  color {{parent.low_frequency_scale} {parent.low_frequency_scale} {parent.low_frequency_scale} {parent.low_frequency_scale}}
  format "1 1 0 0 1 1 1 1x1"
  name noise_params3
  xpos 1225
  ypos 449
 }
 Copy {
  inputs 2
  channels all
  name Copy4
  xpos 1225
  ypos 714
 }
add_layer {sdf_noise_params4 sdf_noise_params4.highFrequencyX sdf_noise_params4.highFrequencyY sdf_noise_params4.highFrequencyZ sdf_noise_params4.highFrequencyW}
 Constant {
  inputs 0
  channels sdf_noise_params4
  color {{parent.high_frequency_scale} {parent.high_frequency_scale} {parent.high_frequency_scale} {parent.high_frequency_scale}}
  format "1 1 0 0 1 1 1 1x1"
  name noise_params4
  xpos 1349
  ypos 450
 }
 Copy {
  inputs 2
  channels all
  name Copy3
  xpos 1349
  ypos 714
 }
add_layer {sdf_noise_params5 sdf_noise_params5.lowFrequencyTranslationX sdf_noise_params5.lowFrequencyTranslationY sdf_noise_params5.lowFrequencyTranslationZ sdf_noise_params5.lowFrequencyTranslationW}
 Constant {
  inputs 0
  channels sdf_noise_params5
  color {{parent.low_frequency_translation} {parent.low_frequency_translation} {parent.low_frequency_translation} {parent.low_frequency_translation}}
  format "1 1 0 0 1 1 1 1x1"
  name noise_params5
  xpos 1477
  ypos 452
 }
 Copy {
  inputs 2
  channels all
  name Copy2
  xpos 1477
  ypos 714
 }
add_layer {sdf_noise_params6 sdf_noise_params6.highFrequencyTranslationX sdf_noise_params6.highFrequencyTranslationY sdf_noise_params6.highFrequencyTranslationZ sdf_noise_params6.highFrequencyTranslationW}
 Constant {
  inputs 0
  channels sdf_noise_params6
  color {{parent.high_frequency_translation} {parent.high_frequency_translation} {parent.high_frequency_translation} {parent.high_frequency_translation}}
  format "1 1 0 0 1 1 1 1x1"
  name noise_params6
  xpos 1594
  ypos 453
 }
 Copy {
  inputs 2
  channels all
  name Copy5
  xpos 1594
  ypos 714
 }
 Output {
  name Output1
  xpos 1594
  ypos 818
 }
end_group
push 0
Constant {
 inputs 0
 channels rgb
 color 10
 name Constant1
 xpos 860
 ypos -218
}
Group {
 inputs 5
 name fog
 knobChanged "__import__('sdf.path_march', fromlist='PathMarch').PathMarch().handle_knob_changed()"
 xpos 550
 ypos 40
 addUserKnob {20 User l "Ray March"}
 addUserKnob {3 paths_per_pixel l "paths per pixel" t "The minimum number of paths to trace for each pixel. This is only used when a previous render with a 'variance' layer is plugged into the 'previous' input."}
 paths_per_pixel 1
 addUserKnob {6 roulette t "Randomly terminate rays with a probability proportional to the remaining strength, or throughput of a ray." +STARTLINE}
 roulette true
 addUserKnob {26 ""}
 addUserKnob {7 ray_distance l "max distance" t "Each ray, once spawned is only allowed to travel this distance before it is culled." R 10 10000}
 ray_distance 100
 addUserKnob {3 max_ray_steps l "max ray steps" t "Limit the number of steps a ray can be marched before it is culled. Shadow rays are given half this number of steps."}
 max_ray_steps 1000
 addUserKnob {3 max_bounces l "max bounces" t "Limits the number of times the rays can intersect an object per subpixel."}
 max_bounces 7
 addUserKnob {7 hit_tolerance l "hit tolerance" t "The ray will be considered to have hit an object when it is within this distance of its surface" R 1e-06 0.01}
 hit_tolerance 0.25
 addUserKnob {7 shadow_bias l "shadow bias" t "Increase the distance a ray is offset from a surface after intersecting by this factor." R 1 5}
 shadow_bias 1
 addUserKnob {7 max_brightness l "max brightness" t "The maximum brightness of a pixel. This protects against overflowing to infinity." R 1 1e+08}
 max_brightness 100000000
 addUserKnob {26 ""}
 addUserKnob {13 seeds t "The seeds used to generate per-pixel, random seeds. Be sure to change this on each render used for adaptive sampling, or set the expression on these knobs to be `random()`"}
 seeds {1 2 3}
 addUserKnob {6 enable_dof l "enable depth of field" t "Enable the use of depth of field. The amount to defocus is driven by the camera parameters." +STARTLINE}
 addUserKnob {6 level_of_detail l "dynamic level of detail" t "Increase the hit tolerance the farther the ray travels without hitting a surface. This has performance and antialiasing benefits." +STARTLINE}
 level_of_detail true
 addUserKnob {26 ""}
 addUserKnob {3 max_light_sampling_bounces l "max light sampling bounces" t "The maximum number of bounces during light sampling. Light sampling will be disabled if this is 0. Light sampling means that each time a surface is hit, the direct illumination from lights in the scene will be computed, which helps to reduce noise very quickly."}
 max_light_sampling_bounces 7
 addUserKnob {6 sample_hdri l "sample hdri" t "Include the HDRI in the list of lights that can be sampled during light sampling." -STARTLINE}
 addUserKnob {6 sample_all_lights l "sample all lights" t "Sample every light in the scene during light sampling, rather than just one random one. This will reduce noise quickly but slow things down." -STARTLINE}
 sample_all_lights true
 addUserKnob {7 light_sampling_bias l "light sampling bias" t "A fully biased (1) light sampling means that on each light sample the ray will be initialised pointing directly at the light. Reducing this bias means that some rays will be pointed away from the light. This, when combined with multiple 'max light sampling bounces' allows the renderer to find difficult paths, such as volumetric caustics."}
 light_sampling_bias 1
 addUserKnob {6 secondary_sampling l "secondary sampling" t "Sample the artificial lights (those in the 'lights' input) while casting shadow rays for light sampling." +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {3 equiangular_samples l "equi-angular samples" t "The number of equi-angular samples to perform if the extinction/scattering coefficients are greater than 0. This enables participating media such as fog/smoke/clouds to be traced."}
 equiangular_samples 100
 addUserKnob {6 sample_hdri_equiangular l "sample hdri" t "Sample the HDRI during equi-angular sampling. If there are no lights in the scene, this will allow you to see the participating media. With more than one light in the scene, this will increase noise." -STARTLINE}
 addUserKnob {7 refractive_index l "refractive index" t "The index of refraction of the medium that the camera is currently in." R 1 4}
 refractive_index 1
 addUserKnob {18 extinction_colour l "extinction colour" t "The colour absorbed as light travels through the material that the camera is in."}
 extinction_colour 1
 addUserKnob {6 extinction_colour_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 extinction_coefficient l "extinction coefficient" t "The amount of energy lost as the light travells through the material." R 0 10}
 addUserKnob {18 scattering_colour l "scattering colour" t "The colour being scattered by the participating media."}
 scattering_colour {1 1 1}
 addUserKnob {6 scattering_colour_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 addUserKnob {7 scattering_coefficient l "scattering coefficient" t "The amount of light being scattered by the participating media."}
 scattering_coefficient 1
 addUserKnob {26 ""}
 addUserKnob {7 hdri_offset_angle l "hdri offset angle" t "Rotate the hdri image by this amount around the y-axis." R 0 360}
 addUserKnob {26 ""}
 addUserKnob {6 use_precomputed_irradiance l "use precomputed irradiance" t "Use precomputed irradiance on diffuse bounces. This will mean that noise is all but illiminated imediately, and so will be fast, but will not give correct occlusion, or indirect illumination." +STARTLINE}
 addUserKnob {7 hdri_lighting_scale l "hdri irradiance scale" t "The amount to scale the precomputed irradiance. A smaller scale will improve memory usage and lookup times." R 0.1 1}
 hdri_lighting_scale 0.25
 addUserKnob {3 hdri_irradiance_samples l "hdri irradiance samples" t "The number of samples to use when precomputing the irradiance."}
 hdri_irradiance_samples 100
 addUserKnob {7 hdri_lighting_blur l "hdri irradiance blur" t "The amount to blur the precomputed irradiance. This can be necessary to increase when there are small, very bright, points in the HDRI, because they will not be sampled smoothly and quickly." R 0 10}
 hdri_lighting_blur 10
 addUserKnob {26 ""}
 addUserKnob {3 variance_range l "variance range" t "The number of adjacent pixels that will contribute to the variance of a pixel for the variance AOV which is automatically output."}
 variance_range 1
 addUserKnob {26 ""}
 addUserKnob {4 output_type l output t "The AOV type to output.\n\nThe stats AOV has the average number of steps in the red channel, the average number of bounces in the green channel, and the total number of paths that have been traced for a pixel in the blue channel." M {Beauty "World Position" "Local Position" Normal Depth Stats "" "" "" "" "" "" "" "" ""}}
 addUserKnob {41 format t "The format to output." T format_.format}
 addUserKnob {6 latlong l LatLong t "Output a LatLong, 360 degree field of view image." +STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {26 info l "" +STARTLINE T "v2.1.0 - (c) Owen Bulka - 2022"}
}
 BackdropNode {
  inputs 0
  name Lights
  xpos -47
  ypos -1617
  bdwidth 410
  bdheight 851
 }
 BackdropNode {
  inputs 0
  name Objects
  xpos 418
  ypos -1616
  bdwidth 936
  bdheight 850
 }
 Constant {
  inputs 0
  format "2 1 0 0 2 1 1 lights"
  name Constant3
  xpos 1500
  ypos -1545
 }
 Input {
  inputs 0
  name hdri
  xpos 1610
  ypos -1572
  number 4
 }
 Merge2 {
  inputs 2
  name Merge1
  xpos 1610
  ypos -1522
 }
 Reformat {
  type scale
  format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
  black_outside true
  name Reformat5
  xpos 1610
  ypos -1498
 }
 Dot {
  name hdri_dot
  xpos 1644
  ypos -1453
 }
set N959f050 [stack 0]
 Reformat {
  type scale
  scale {{"floor(min(parent.hdri_dot.height, parent.hdri_dot.width) * parent.hdri_lighting_scale) > 0 ? parent.hdri_lighting_scale : 1"}}
  resize fill
  name Reformat
  xpos 1720
  ypos -1457
 }
 Blur {
  size {{parent.hdri_lighting_blur}}
  name Blur2
  xpos 1720
  ypos -1415
 }
 BlinkScript {
  kernelSourceFile /home/ob1/software/nuke/dev/fog/src/blink/kernels/hdri_irradiance.blink
  recompileCount 125
  ProgramGroup 1
  KernelDescription "2 \"HDRIrradiance\" iterate pixelWise 251c656cf29b40ef05c9c200e71e39b6428a5444f09467de8d30a84319a82047 2 \"hdri\" Read Random \"dst\" Write Point 1 \"Samples\" Int 2 ZAAAADIAAAA= 1 \"_samples\" 2 1 3 \"__hdriPixelSize\" Float 2 1 AAAAAAAAAAA= \"__up\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"__sampleStep\" Float 2 1 AAAAAAAAAAA="
  kernelSource "// Copyright 2022 by Owen Bulka.\n// All rights reserved.\n// This file is released under the \"MIT License Agreement\".\n// Please see the LICENSE.md file that should have been included as part\n// of this package.\n\n\n/**\n * Get the equivalent theta and phi values that lie between \[0, 2 * PI),\n * and \[0, PI) respectively.\n *\n * @arg angles: The spherical angles in radians.\n *\n * @returns: The equivalent theta and phi.\n */\ninline float2 normalizeAngles(const float2 &angles)\n\{\n    float2 normalizedAngles = float2(\n        fmod(angles.x, 2.0f * PI),\n        fmod(angles.y, PI)\n    );\n    normalizedAngles.x += 2 * PI * (normalizedAngles.x < 0);\n    normalizedAngles.y += PI * (normalizedAngles.y < 0);\n\n    return normalizedAngles;\n\}\n\n\n/**\n * Convert a cartesion unit vector to spherical.\n *\n * @arg rayDirection: The cartesion unit vector.\n * @arg thetaOffset: Offset the theta angle by this amount.\n *\n * @returns: The spherical angles in radians.\n */\ninline float2 cartesionUnitVectorToSpherical(\n        const float3 &rayDirection,\n        const float thetaOffset)\n\{\n    return normalizeAngles(float2(\n        atan2(rayDirection.z, rayDirection.x) + thetaOffset,\n        acos(rayDirection.y)\n    ));\n\}\n\n\n/**\n * Convert a cartesion unit vector to spherical.\n *\n * @arg rayDirection: The cartesion unit vector.\n *\n * @returns: The spherical angles in radians.\n */\ninline float2 cartesionUnitVectorToSpherical(const float3 &rayDirection)\n\{\n    return normalizeAngles(float2(\n        atan2(rayDirection.z, rayDirection.x),\n        acos(rayDirection.y)\n    ));\n\}\n\n\n/**\n * Convert location of a pixel in an image into UV.\n *\n * @arg pixelLocation: The x, and y positions of the pixel.\n * @arg format: The image width, and height.\n *\n * @returns: The UV position.\n */\ninline float2 pixelsToUV(const float2 &pixelLocation, const float2 &format)\n\{\n    return float2(\n        2.0f * pixelLocation.x / format.x - 1.0f,\n        2.0f * pixelLocation.y / format.y - 1.0f\n    );\n\}\n\n\n/**\n * Convert a spherical unit vector (unit radius) to cartesion.\n *\n * @arg angles: The spherical angles in radians.\n *\n * @returns: The equivalent cartesion vector.\n */\ninline float3 sphericalUnitVectorToCartesion(const float2 &angles)\n\{\n    const float sinPhi = sin(angles.y);\n    return float3(\n        cos(angles.x) * sinPhi,\n        cos(angles.y),\n        sin(angles.x) * sinPhi\n    );\n\}\n\n\n/**\n * Convert the uv position in a latlong image to angles.\n *\n * @arg uvPosition: The UV position.\n *\n * @returns: The equivalent angles in radians.\n */\ninline float2 uvPositionToAngles(const float2 &uvPosition)\n\{\n    return float2(\n        (uvPosition.x + 1.0f) * PI,\n        (1.0f - uvPosition.y) * PI / 2.0f\n    );\n\}\n\n\nkernel HDRIrradiance : ImageComputationKernel<ePixelWise>\n\{\n    Image<eRead, eAccessRandom, eEdgeClamped> hdri; // the input image\n    Image<eWrite> dst; // the output image\n\n    param:\n        int2 _samples;\n\n    local:\n        float2 __hdriPixelSize;\n        float3 __up;\n        float2 __sampleStep;\n\n\n    /**\n     * Give the parameters labels and default values.\n     */\n    void define()\n    \{\n        defineParam(_samples, \"Samples\", int2(100, 50));\n    \}\n\n\n    /**\n     * Initialize the local variables.\n     */\n    void init()\n    \{\n        __hdriPixelSize = float2(hdri.bounds.width() / (2.0f * PI), hdri.bounds.height() / PI);\n        __up = float3(0, 1, 0);\n\n        __sampleStep = float2(\n            2.0f * PI / (float) _samples.x,\n            PI / (2.0f * (float) _samples.y)\n        );\n    \}\n\n\n    /**\n     * Get the value of hdri the ray would hit at infinite distance\n     *\n     * @arg rayDirection: The direction of the ray.\n     *\n     * @returns: The colour of the pixel in the direction of the ray.\n     */\n    float4 readHDRIValue(float3 rayDirection)\n    \{\n        const float2 angles = cartesionUnitVectorToSpherical(rayDirection);\n\n        // Why does bilinear give nans? :(\n        return hdri(\n            round(__hdriPixelSize.x * angles.x) - 1,\n            round(hdri.bounds.height() - (__hdriPixelSize.y * angles.y)) - 1\n        );\n    \}\n\n\n    /**\n     * Compute the irradiance of a pixel.\n     *\n     * @arg pos: The x, and y location we are currently processing.\n     */\n    void process(int2 pos)\n    \{\n        const float2 uvPosition = pixelsToUV(\n            float2(pos.x, pos.y),\n            float2(hdri.bounds.width(), hdri.bounds.height())\n        );\n        const float3 direction = sphericalUnitVectorToCartesion(\n            uvPositionToAngles(uvPosition)\n        );\n\n        const float3 tangentRight = normalize(cross(__up, direction));\n        const float3 tangentUp = normalize(cross(direction, tangentRight));\n\n        float4 irradiance = float4(0);\n\n        for (float theta = 0.0f; theta < 2.0f * PI; theta += __sampleStep.x)\n        \{\n            for (float phi = PI / 2.0f; phi > 0.0f; phi -= __sampleStep.y)\n            \{\n                const float3 tangent = sphericalUnitVectorToCartesion(float2(theta, phi));\n                const float3 sampleDirection = (\n                    tangent.x * tangentRight\n                    + tangent.z * tangentUp\n                    + tangent.y * direction\n                );\n\n                irradiance += readHDRIValue(sampleDirection) * cos(phi) * sin(phi);\n            \}\n        \}\n\n        dst() = PI * irradiance / (float) (_samples.x * _samples.y);\n    \}\n\};\n"
  rebuild ""
  HDRIrradiance_Samples {{parent.hdri_irradiance_samples} {parent.hdri_irradiance_samples/2}}
  rebuild_finalise ""
  name HDRIrradiance
  xpos 1720
  ypos -1363
 }
 Reformat {
  type scale
  format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
  black_outside true
  name Reformat3
  xpos 1720
  ypos -1305
 }
 Dot {
  name Dot33
  xpos 1754
  ypos -558
 }
 Constant {
  inputs 0
  format "1 1 0 0 1 1 1 1x1"
  name Constant4
  xpos -542
  ypos -1704
 }
 Dot {
  name Dot7
  xpos -508
  ypos -1533
 }
 Dot {
  name Dot1
  xpos -432
  ypos -1533
 }
set N971d110 [stack 0]
 Dot {
  name Dot25
  xpos -68
  ypos -1533
 }
set N970b4d0 [stack 0]
 Dot {
  name Dot15
  xpos -68
  ypos -1437
 }
push $N970b4d0
 Input {
  inputs 0
  name lights
  xpos 8
  ypos -1577
  number 1
 }
 Merge2 {
  inputs 2
  name light_merge
  xpos 8
  ypos -1489
 }
 Group {
  inputs 2
  name light_input_protection
  xpos 8
  ypos -1441
  disable {{"width > 1"}}
  addUserKnob {20 User}
  addUserKnob {26 warning l Warning: T "Only merge lights with lights, and primitives with primitives"}
 }
  Reformat {
   inputs 0
   type "to box"
   box_width 1
   box_height 1
   box_fixed true
   name Reformat1
   xpos -119
   ypos 440
  }
  Input {
   inputs 0
   name Input2
   xpos 158
   ypos -28
   number 1
  }
  Dot {
   name Dot2
   xpos 192
   ypos -2
  }
set N9874230 [stack 0]
  Dot {
   name Dot3
   xpos 329
   ypos -2
  }
  Dot {
   name Dot4
   xpos 329
   ypos 391
  }
  Input {
   inputs 0
   name Input1
   xpos 0
   ypos -32
  }
  Dot {
   name Dot1
   xpos 34
   ypos -6
  }
set N95d4270 [stack 0]
  Dot {
   name Dot6
   xpos -98
   ypos -6
  }
  Dot {
   name Dot5
   xpos -98
   ypos 336
  }
push $N9874230
  Crop {
   box {0 0 {Dot1.width+Dot2.width} 1}
   reformat true
   crop false
   name Crop3
   xpos 158
   ypos 69
  }
  Crop {
   box {0 0 {parent.Dot2.width} 1}
   name Crop4
   xpos 158
   ypos 95
  }
  Transform {
   translate {{parent.Dot1.width} 0}
   center {1 0.5}
   name Transform2
   xpos 158
   ypos 121
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop5
   xpos 158
   ypos 167
  }
push $N95d4270
  Crop {
   box {0 0 {Dot1.width+Dot2.width} 1}
   reformat true
   crop false
   name Crop6
   xpos 0
   ypos 66
  }
  Crop {
   box {0 0 {parent.Dot1.width} 1}
   name Crop7
   xpos 0
   ypos 92
  }
  Crop {
   box {0 0 {width} {height}}
   crop false
   name Crop8
   xpos 0
   ypos 164
  }
  Merge2 {
   inputs 2
   also_merge all
   name Merge1
   xpos 0
   ypos 262
   disable {{"\[exists parent.input1] ? 0:1"}}
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input1] ? 0:1"}}
   name Switch2
   xpos 0
   ypos 332
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input0] ? 0:1"}}
   name Switch1
   xpos 0
   ypos 387
  }
  Switch {
   inputs 2
   which {{"\[exists parent.input0] ? 0:\[exists parent.input1] ? 0:1"}}
   name Switch3
   xpos 0
   ypos 456
  }
  Dot {
   name out_dot
   xpos 36
   ypos 518
  }
  Output {
   name Output1
   xpos 2
   ypos 661
  }
 end_group
 Dot {
  name light_dot
  xpos 42
  ypos -1293
 }
set N87433b0 [stack 0]
add_layer {sdf_light_properties1 sdf_light_properties1.shadow_hardness sdf_light_properties1.falloff}
 Shuffle {
  in sdf_light_properties1
  blue green
  alpha green
  name light_props1
  xpos 228
  ypos -985
 }
 Dot {
  name Dot22
  xpos 262
  ypos -813
 }
push $N87433b0
add_layer {sdf_light_properties sdf_light_properties.colour_r sdf_light_properties.colour_g sdf_light_properties.colour_b sdf_light_properties.type}
 Shuffle {
  in sdf_light_properties
  name light_props
  xpos 118
  ypos -985
 }
 Dot {
  name Dot23
  xpos 152
  ypos -813
 }
push $N87433b0
add_layer {sdf_light sdf_light.light_pos_dir_x sdf_light.light_pos_dir_y sdf_light.light_pos_dir_z sdf_light.intensity}
 Shuffle {
  in sdf_light
  name light
  xpos 8
  ypos -985
 }
 Dot {
  name Dot24
  xpos 42
  ypos -813
 }
push $N970b4d0
 Dot {
  name Dot36
  xpos 501
  ypos -1533
 }
 Input {
  inputs 0
  name noise
  xpos 577
  ypos -1549
  number 2
 }
 Merge2 {
  inputs 2
  name noise_merge
  xpos 577
  ypos -1489
 }
 Reformat {
  format "2 1 0 0 2 1 1 2butt"
  filter impulse
  black_outside true
  name Reformat2
  xpos 577
  ypos -1404
  disable true
 }
 Dot {
  name Dot35
  xpos 611
  ypos -1221
 }
set N8d585f0 [stack 0]
 Shuffle {
  in sdf_noise_params6
  name noise_params6
  xpos 1233
  ypos -982
 }
 Dot {
  name Dot46
  xpos 1267
  ypos -815
 }
push $N8d585f0
 Shuffle {
  in sdf_noise_params5
  name noise_params5
  xpos 1122
  ypos -984
 }
 Dot {
  name Dot45
  xpos 1156
  ypos -814
 }
push $N8d585f0
 Shuffle {
  in sdf_noise_params4
  name noise_params4
  xpos 1013
  ypos -987
 }
 Dot {
  name Dot44
  xpos 1047
  ypos -815
 }
push $N8d585f0
 Shuffle {
  in sdf_noise_params3
  name noise_params3
  xpos 911
  ypos -986
 }
 Dot {
  name Dot43
  xpos 945
  ypos -814
 }
push $N8d585f0
 Shuffle {
  in sdf_noise_params2
  name noise_params2
  xpos 797
  ypos -985
 }
 Dot {
  name Dot28
  xpos 831
  ypos -813
 }
push $N8d585f0
 Shuffle {
  in sdf_noise_params1
  name noise_params1
  xpos 687
  ypos -985
 }
 Dot {
  name Dot26
  xpos 721
  ypos -813
 }
push $N8d585f0
 Shuffle {
  in sdf_noise_params0
  name noise_params0
  xpos 577
  ypos -985
 }
 Dot {
  name Dot27
  xpos 611
  ypos -813
 }
push $N959f050
push $N971d110
 Input {
  inputs 0
  name depth
  xpos -349
  ypos -1615
 }
 Merge2 {
  inputs 2
  name light_merge1
  xpos -349
  ypos -1471
 }
 Dot {
  name Dot2
  xpos -315
  ypos -459
 }
 Constant {
  inputs 0
  channels {rgba.red rgba.green rgba.blue -rgba.alpha}
  name format_
  xpos 1830
  ypos -707
 }
 Noise {
  output {rgba.red -rgba.green -rgba.blue -rgba.alpha}
  type turbulence
  size 1
  zoffset {{parent.seeds.x}}
  lacunarity 1.6
  center {512 389}
  name Noise1
  xpos 1830
  ypos -636
 }
 Noise {
  output {-rgba.red rgba.green -rgba.blue -rgba.alpha}
  type turbulence
  size 1
  zoffset {{parent.seeds.y}}
  center {512 389}
  name Noise2
  xpos 1830
  ypos -612
 }
 Noise {
  output {-rgba.red -rgba.green rgba.blue -rgba.alpha}
  type turbulence
  size 1
  zoffset {{parent.seeds.z}}
  lacunarity 2.14
  center {512 389}
  name Noise3
  xpos 1830
  ypos -588
 }
 Noise {
  output {-rgba.red -rgba.green -rgba.blue rgba.alpha}
  type turbulence
  size 1
  zoffset {{parent.seeds.z}}
  lacunarity 2.14
  center {512 389}
  name Noise4
  xpos 1830
  ypos -562
 }
 BlinkScript {
  kernelSourceFile /home/ob1/software/nuke/dev/fog/src/blink/kernels/random.blink
  recompileCount 11
  ProgramGroup 1
  KernelDescription "2 \"Random\" iterate pixelWise 3f1c9af5a0660665ff261b4618c0b62fe5317414e0e936f0cb46bd242700f88e 2 \"seed\" Read Point \"dst\" Write Point 1 \"Inclusive Range\" Float 2 AAAAAAAAgD8= 1 \"_inclusiveRange\" 2 1 1 \"__rangeLength\" Float 1 1 AAAAAA=="
  kernelSource "// Copyright 2022 by Owen Bulka.\n// All rights reserved.\n// This file is released under the \"MIT License Agreement\".\n// Please see the LICENSE.md file that should have been included as part\n// of this package.\n\n\n/**\n * Compute the fractional portion of the value. Ex. 3.5 returns 0.5\n *\n * @arg value: The value to get the fractional portion of.\n *\n * @returns: The fractional portion of the value.\n */\ninline float fract(const float value)\n\{\n    return value - floor(value);\n\}\n\n\n/**\n * Get a random value on the interval \[0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval \[0, 1].\n */\ninline float random(const float seed)\n\{\n    return fract(sin(seed * 91.3458f) * 47453.5453f);\n\}\n\n\n/**\n * Get a random value on the interval \[0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval \[0, 1].\n */\ninline float3 random(const float3 &seed)\n\{\n    return float3(\n        random(seed.x),\n        random(seed.y),\n        random(seed.z)\n    );\n\}\n\n\n/**\n * Get a random value on the interval \[0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval \[0, 1].\n */\ninline float4 random(const float4 &seed)\n\{\n    return float4(\n        random(seed.x),\n        random(seed.y),\n        random(seed.z),\n        random(seed.w)\n    );\n\}\n\n\nkernel Random : ImageComputationKernel<ePixelWise>\n\{\n    Image<eRead, eAccessPoint, eEdgeNone> seed; // the input image\n    Image<eWrite> dst; // the output image\n\n\n    param:\n        float2 _inclusiveRange;\n\n    local:\n        float __rangeLength;\n\n\n    /**\n     * Give the parameters labels and default values.\n     */\n    void define()\n    \{\n        defineParam(_inclusiveRange, \"Inclusive Range\", float2(0, 1));\n    \}\n\n\n    /**\n     * Initialize the local variables.\n     */\n    void init()\n    \{\n        __rangeLength = _inclusiveRange.y - _inclusiveRange.x;\n    \}\n\n\n    /**\n     * Compute a random pixel value.\n     */\n    void process()\n    \{\n        dst() = __rangeLength * random(seed()) + _inclusiveRange.x;\n    \}\n\};\n"
  rebuild ""
  rebuild_finalise ""
  name BlinkScript7
  xpos 1830
  ypos -524
 }
 Dot {
  name resolution_dot
  xpos 1864
  ypos -459
 }
 BlinkScript {
  inputs 14
  kernelSourceFile /home/ob1/software/nuke/dev/fog/src/blink/kernels/fog.blink
  recompileCount 58
  ProgramGroup 1
  KernelDescription "2 \"FogKernel\" iterate pixelWise 0a18c50453e93a8c04d249aac281e2457d115bed2be18f45a1f9895459e32fa3 15 \"noise\" Read Point \"depth\" Read Point \"hdri\" Read Random \"noiseParams0\" Read Random \"noiseParams1\" Read Random \"noiseParams2\" Read Random \"noiseParams3\" Read Random \"noiseParams4\" Read Random \"noiseParams5\" Read Random \"noiseParams6\" Read Random \"lights\" Read Random \"lightProperties\" Read Random \"lightProperties1\" Read Random \"irradiance\" Read Random \"dst\" Write Point 21 \"Focal Length\" Float 1 AABIQg== \"Horizontal Aperture\" Float 1 ppvEQQ== \"Near Plane\" Float 1 zczMPQ== \"Far Plane\" Float 1 AEAcRg== \"Camera World Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"Focal Distance\" Float 1 AACAQA== \"fstop\" Float 1 AACAQQ== \"Enable Depth Of Field\" Bool 1 AQ== \"Screen Width\" Float 1 AABwRQ== \"Screen Height\" Float 1 AAAHRQ== \"HDRI Offset Angle\" Float 1 AAAAAA== \"Use Precomputed Irradiance\" Bool 1 AQ== \"Paths Per Pixel\" Int 1 AQAAAA== \"Sample HDRI\" Bool 1 AQ== \"Hit Tolerance\" Float 1 bxKDOg== \"Maximum Brightness\" Float 1 /iN0SQ== \"Scattering Coefficient\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"Extinction Coefficient\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"Equi-Angular Samples\" Int 1 BQAAAA== \"Light Texture Width\" Int 1 AAAAAA== \"Output LatLong\" Bool 1 AA== 21 \"_focalLength\" 1 1 \"_horizontalAperture\" 1 1 \"_nearPlane\" 1 1 \"_farPlane\" 1 1 \"_cameraWorldMatrix\" 16 1 \"_focalDistance\" 1 1 \"_fStop\" 1 1 \"_depthOfFieldEnabled\" 1 1 \"_formatWidth\" 1 1 \"_formatHeight\" 1 1 \"_hdriOffsetAngle\" 1 1 \"_usePrecomputedIrradiance\" 1 1 \"_pathsPerPixel\" 1 1 \"_sampleHDRI\" 1 1 \"_hitTolerance\" 1 1 \"_maxBrightness\" 1 1 \"_scatteringCoefficient\" 4 1 \"_extinctionCoefficient\" 4 1 \"_equiangularSamples\" 1 1 \"_lightTextureWidth\" 1 1 \"_latLong\" 1 1 12 \"__inverseCameraProjectionMatrix\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"__aperture\" Float 1 1 AAAAAA== \"__hdriPixelSize\" Float 2 1 AAAAAAAAAAA= \"__irradiancePixelSize\" Float 2 1 AAAAAAAAAAA= \"__hdriOffsetRadians\" Float 1 1 AAAAAA== \"__offset0\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"__offset1\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"__offset2\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"__offset3\" Float 3 1 AAAAAAAAAAAAAAAAAAAAAA== \"__simplex\" Int 1 256 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"__perm\" Int 1 512 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"__grad4\" Int 1 128 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
  kernelSource "// Copyright 2022 by Owen Bulka.\n// All rights reserved.\n// This file is released under the \"MIT License Agreement\".\n// Please see the LICENSE.md file that should have been included as part\n// of this package.\n\n\n//\n// Matrix and vector math operations\n//\n\n#define PI_BY_TWO (PI / 2.0f)\n#define TWO_PI (2.0f * PI)\n\n\n/**\n * Convert degrees to radians.\n *\n * @arg angle: The angle in degrees.\n *\n * @returns: The angle in radians.\n */\ninline float degreesToRadians(const float angle)\n\{\n    return angle * PI / 180.0f;\n\}\n\n\n/**\n * Convert radians to degrees.\n *\n * @arg angle: The angle in radians.\n *\n * @returns: The angle in degrees.\n */\ninline float radiansToDegrees(const float angle)\n\{\n    return angle * 180.0f / PI;\n\}\n\n\n/**\n * Convert degrees to radians.\n *\n * @arg angle: The angle in degrees.\n *\n * @returns: The angle in radians.\n */\ninline float2 degreesToRadians(const float2 &angle)\n\{\n    return angle * PI / 180.0f;\n\}\n\n\n/**\n * Convert radians to degrees.\n *\n * @arg angle: The angle in radians.\n *\n * @returns: The angle in degrees.\n */\ninline float2 radiansToDegrees(const float2 &angle)\n\{\n    return angle * 180.0f / PI;\n\}\n\n\n/**\n * Convert degrees to radians.\n *\n * @arg angle: The angle in degrees.\n *\n * @returns: The angle in radians.\n */\ninline float3 degreesToRadians(const float3 &angle)\n\{\n    return angle * PI / 180.0f;\n\}\n\n\n/**\n * Convert radians to degrees.\n *\n * @arg angle: The angle in radians.\n *\n * @returns: The angle in degrees.\n */\ninline float3 radiansToDegrees(const float3 &angle)\n\{\n    return angle * 180.0f / PI;\n\}\n\n\n/**\n * Compute the fractional portion of the value. Ex. 3.5 returns 0.5\n *\n * @arg value: The value to get the fractional portion of.\n *\n * @returns: The fractional portion of the value.\n */\ninline float fract(const float value)\n\{\n    return value - floor(value);\n\}\n\n\n/**\n * The minimum of three values.\n *\n * @arg value0: The first value.\n * @arg value1: The second value.\n * @arg value2: The third value.\n *\n * @returns: The minimum of the three values.\n */\ninline float min(const float value0, const float value1, const float value2)\n\{\n    return min(value0, min(value1, value2));\n\}\n\n\n/**\n * The maximum of three values.\n *\n * @arg value0: The first value.\n * @arg value1: The second value.\n * @arg value2: The third value.\n *\n * @returns: The maximum of the three values.\n */\ninline float max(const float value0, const float value1, const float value2)\n\{\n    return max(value0, max(value1, value2));\n\}\n\n\n/**\n * Saturate a value ie. clamp between 0 and 1\n *\n * @arg value: The value to saturate\n *\n * @returns: The clamped value\n */\ninline float saturate(float value)\n\{\n    return clamp(value, 0.0f, 1.0f);\n\}\n\n\n/**\n * Saturate a value ie. clamp between 0 and 1\n *\n * @arg value: The value to saturate\n *\n * @returns: The clamped value\n */\ninline float2 saturate(const float2 &value)\n\{\n    return clamp(value, float2(0), float2(1));\n\}\n\n\n/**\n * Saturate a value ie. clamp between 0 and 1\n *\n * @arg value: The value to saturate\n *\n * @returns: The clamped value\n */\ninline float3 saturate(const float3 &value)\n\{\n    return clamp(value, float3(0), float3(1));\n\}\n\n\n/**\n * Saturate a value ie. clamp between 0 and 1\n *\n * @arg value: The value to saturate\n *\n * @returns: The clamped value\n */\ninline float4 saturate(const float4 &value)\n\{\n    return clamp(value, float4(0), float4(1));\n\}\n\n\n/**\n * Custom clamp for int3 because the builtin clamp fails to compile for\n * int3.\n *\n * @arg value: The value to clamp.\n * @arg lower: The lower bound to clamp to.\n * @arg upper: The upper bound to clamp to.\n *\n * @returns: The clamped value.\n */\ninline int3 clamp_(const int3 value, const int3 lower, const int3 upper)\n\{\n    int3 result;\n    result.x = clamp(value.x, lower.x, upper.x);\n    result.y = clamp(value.y, lower.y, upper.y);\n    result.z = clamp(value.z, lower.y, upper.z);\n\n    return result;\n\}\n\n\n/**\n * Clamp vector components between float values.\n *\n * @arg value: The value to clamp.\n * @arg lower: The lower bound to clamp to.\n * @arg upper: The upper bound to clamp to.\n *\n * @returns: The clamped value.\n */\ninline float2 clamp(const float2 &value, const float lower, const float upper)\n\{\n    return clamp(value, float2(lower), float2(upper));\n\}\n\n\n/**\n * Clamp vector components between float values.\n *\n * @arg value: The value to clamp.\n * @arg lower: The lower bound to clamp to.\n * @arg upper: The upper bound to clamp to.\n *\n * @returns: The clamped value.\n */\ninline float3 clamp(const float3 &value, const float lower, const float upper)\n\{\n    return clamp(value, float3(lower), float3(upper));\n\}\n\n\n/**\n * Clamp vector components between float values.\n *\n * @arg value: The value to clamp.\n * @arg lower: The lower bound to clamp to.\n * @arg upper: The upper bound to clamp to.\n *\n * @returns: The clamped value.\n */\ninline float4 clamp(const float4 &value, const float lower, const float upper)\n\{\n    return clamp(value, float4(lower), float4(upper));\n\}\n\n\n/**\n * Custom round for int3 because the builtin round fails to compile for\n * int3.\n *\n * @arg value: The value to round.\n *\n * @returns: The rounded value.\n */\ninline int3 round_(const float3 value)\n\{\n    return int3(round(value.x), round(value.y), round(value.z));\n\}\n\n\n/**\n * Sum the components of a vector.\n *\n * @arg vector: The vector to sum the components of.\n *\n * @returns: The sum of the components.\n */\ninline float sumComponent(const float2 &vector)\n\{\n    return vector.x + vector.y;\n\}\n\n\n/**\n * Sum the components of a vector.\n *\n * @arg vector: The vector to sum the components of.\n *\n * @returns: The sum of the components.\n */\ninline float sumComponent(const float3 &vector)\n\{\n    return vector.x + vector.y + vector.z;\n\}\n\n\n/**\n * Sum the components of a vector.\n *\n * @arg vector: The vector to sum the components of.\n *\n * @returns: The sum of the components.\n */\ninline float sumComponent(const float4 &vector)\n\{\n    return vector.x + vector.y + vector.z + vector.w;\n\}\n\n\n/**\n * Sum the components of a vector.\n *\n * @arg vector: The vector to sum the components of.\n *\n * @returns: The sum of the components.\n */\ninline int sumComponent(const int2 &vector)\n\{\n    return vector.x + vector.y;\n\}\n\n\n/**\n * Sum the components of a vector.\n *\n * @arg vector: The vector to sum the components of.\n *\n * @returns: The sum of the components.\n */\ninline int sumComponent(const int3 &vector)\n\{\n    return vector.x + vector.y + vector.z;\n\}\n\n\n/**\n * Sum the components of a vector.\n *\n * @arg vector: The vector to sum the components of.\n *\n * @returns: The sum of the components.\n */\ninline int sumComponent(const int4 &vector)\n\{\n    return vector.x + vector.y + vector.z + vector.w;\n\}\n\n\n/**\n * The maximum component of a vector.\n *\n * @arg vector: The vector.\n *\n * @returns: The maximum component of the vector.\n */\ninline float maxComponent(const float2 &vector)\n\{\n    return max(vector.x, vector.y);\n\}\n\n\n/**\n * The maximum component of a vector.\n *\n * @arg vector: The vector.\n *\n * @returns: The maximum component of the vector.\n */\ninline float maxComponent(const float3 &vector)\n\{\n    return max(vector.x, max(vector.y, vector.z));\n\}\n\n\n/**\n * The maximum component of a vector.\n *\n * @arg vector: The vector.\n *\n * @returns: The maximum component of the vector.\n */\ninline float maxComponent(const float4 &vector)\n\{\n    return max(vector.x, max(vector.y, max(vector.z, vector.w)));\n\}\n\n\n/**\n * The minimum component of a vector.\n *\n * @arg vector: The vector.\n *\n * @returns: The minimum component of the vector.\n */\ninline float minComponent(const float2 &vector)\n\{\n    return min(vector.x, vector.y);\n\}\n\n\n/**\n * The minimum component of a vector.\n *\n * @arg vector: The vector.\n *\n * @returns: The minimum component of the vector.\n */\ninline float minComponent(const float3 &vector)\n\{\n    return min(vector.x, min(vector.y, vector.z));\n\}\n\n\n/**\n * The minimum component of a vector.\n *\n * @arg vector: The vector.\n *\n * @returns: The minimum component of the vector.\n */\ninline float minComponent(const float4 &vector)\n\{\n    return min(vector.x, min(vector.y, min(vector.z, vector.w)));\n\}\n\n\n/**\n * The positive part of the vector. Ie. any negative values will be 0.\n *\n * @arg vector: The vector.\n *\n * @returns: The positive part of the vector.\n */\ninline float4 positivePart(const float4 &vector)\n\{\n    return max(vector, float4(0));\n\}\n\n\n/**\n * The positive part of the vector. Ie. any negative values will be 0.\n *\n * @arg vector: The vector.\n *\n * @returns: The positive part of the vector.\n */\ninline float3 positivePart(const float3 &vector)\n\{\n    return max(vector, float3(0));\n\}\n\n\n/**\n * The positive part of the vector. Ie. any negative values will be 0.\n *\n * @arg vector: The vector.\n *\n * @returns: The positive part of the vector.\n */\ninline float2 positivePart(const float2 &vector)\n\{\n    return max(vector, float2(0));\n\}\n\n\n/**\n * The positive part of the vector. Ie. any negative values will be 0.\n *\n * @arg vector: The vector.\n *\n * @returns: The positive part of the vector.\n */\ninline float positivePart(const float value)\n\{\n    return max(value, 0.0f);\n\}\n\n\n/**\n * The negative part of the vector. Ie. any positive values will be 0,\n * and the negative values will be positive.\n *\n * @arg vector: The vector.\n *\n * @returns: The negative part of the vector.\n */\ninline float3 negativePart(const float3 &vector)\n\{\n    return -min(vector, float3(0));\n\}\n\n\n/**\n * The negative part of the vector. Ie. any positive values will be 0,\n * and the negative values will be positive.\n *\n * @arg vector: The vector.\n *\n * @returns: The negative part of the vector.\n */\ninline float2 negativePart(const float2 &vector)\n\{\n    return -min(vector, float2(0));\n\}\n\n\n/**\n * The negative part of the vector. Ie. any positive values will be 0,\n * and the negative values will be positive.\n *\n * @arg vector: The vector.\n *\n * @returns: The negative part of the vector.\n */\ninline float negativePart(const float value)\n\{\n    return -min(value, 0.0f);\n\}\n\n\n/**\n * Dot product of a vector with itself.\n *\n * @arg vector: The vector to take the dot product of.\n *\n * @returns: The dot product.\n */\ninline float dot2(const float2 &vector)\n\{\n    return dot(vector, vector);\n\}\n\n\n/**\n * Dot product of a vector with itself.\n *\n * @arg vector: The vector to take the dot product of.\n *\n * @returns: The dot product.\n */\ninline float dot2(const float3 &vector)\n\{\n    return dot(vector, vector);\n\}\n\n\n/**\n * Dot product of a vector with itself.\n *\n * @arg vector: The vector to take the dot product of.\n *\n * @returns: The dot product.\n */\ninline float dot2(const float4 &vector)\n\{\n    return dot(vector, vector);\n\}\n\n\n/**\n * Check whether or not two vectors are identical.\n *\n * @arg vector0: The first vector to compare.\n * @arg vector1: The other vector to compare.\n *\n * @returns: True if the vectors are identical.\n */\ninline bool vectorsAreEqual(const float2 &vector0, const float2 &vector1)\n\{\n    return vector0.x == vector1.x && vector0.y == vector1.y;\n\}\n\n\n/**\n * Check whether or not two vectors are identical.\n *\n * @arg vector0: The first vector to compare.\n * @arg vector1: The other vector to compare.\n *\n * @returns: True if the vectors are identical.\n */\ninline bool vectorsAreEqual(const float3 &vector0, const float3 &vector1)\n\{\n    return vector0.x == vector1.x && vector0.y == vector1.y && vector0.z == vector1.z;\n\}\n\n\n/**\n * Check whether or not two vectors are identical.\n *\n * @arg vector0: The first vector to compare.\n * @arg vector1: The other vector to compare.\n *\n * @returns: True if the vectors are identical.\n */\ninline bool vectorsAreEqual(const float4 &vector0, const float4 &vector1)\n\{\n    return (\n        vector0.x == vector1.x\n        && vector0.y == vector1.y\n        && vector0.z == vector1.z\n        && vector0.w == vector1.w\n    );\n\}\n\n\n/**\n * Get a rotation matrix from radian angle values in ZYX order.\n *\n * @arg angles: The rotation angles in radians.\n * @arg out: The location to store the rotation matrix.\n */\ninline void rotationMatrix(const float3 &angles, float3x3 &out)\n\{\n    const float3 cosAngles = cos(angles);\n    const float3 sinAngles = sin(angles);\n\n    // Why tf can I not init a float3x3 normally??\n    out\[0]\[0] = cosAngles.y * cosAngles.z;\n    out\[0]\[1] = sinAngles.x * sinAngles.y * cosAngles.z - cosAngles.x * sinAngles.z;\n    out\[0]\[2] = cosAngles.x * sinAngles.y * cosAngles.z + sinAngles.x * sinAngles.z;\n    out\[1]\[0] = cosAngles.y * sinAngles.z;\n    out\[1]\[1] = sinAngles.x * sinAngles.y * sinAngles.z + cosAngles.x * cosAngles.z;\n    out\[1]\[2] = cosAngles.x * sinAngles.y * sinAngles.z - sinAngles.x * cosAngles.z;\n    out\[2]\[0] = -sinAngles.y;\n    out\[2]\[1] = sinAngles.x * cosAngles.y;\n    out\[2]\[2] = cosAngles.x * cosAngles.y;\n\}\n\n\n/**\n * Get a rotation matrix from radian angle values in XYZ order.\n *\n * @arg angles: The rotation angles in radians.\n * @arg out: The location to store the rotation matrix.\n */\ninline void reverseRotationMatrix(const float3 &angles, float3x3 &out)\n\{\n    const float3 cosAngles = cos(angles);\n    const float3 sinAngles = sin(angles);\n\n    // Why tf can I not init a float3x3 normally??\n    out\[0]\[0] = cosAngles.y * cosAngles.z;\n    out\[0]\[1] = -cosAngles.y * sinAngles.z;\n    out\[0]\[2] = sinAngles.y;\n    out\[1]\[0] = sinAngles.x * sinAngles.y * cosAngles.z + cosAngles.x * sinAngles.z;\n    out\[1]\[1] = cosAngles.x * cosAngles.z - sinAngles.x * sinAngles.y * sinAngles.z;\n    out\[1]\[2] = -sinAngles.x * cosAngles.y;\n    out\[2]\[0] = sinAngles.x * sinAngles.z - cosAngles.x * sinAngles.y * cosAngles.z;\n    out\[2]\[1] = cosAngles.x * sinAngles.y * sinAngles.z + sinAngles.x * cosAngles.z;\n    out\[2]\[2] = cosAngles.x * cosAngles.y;\n\}\n\n\n/**\n * Get a rotation matrix from an axis and an angle about that axis.\n *\n * @arg angles: The rotation angles in radians.\n * @arg out: The location to store the rotation matrix.\n */\ninline void axisAngleRotationMatrix(const float3 &axis, const float angle, float3x3 &out)\n\{\n    const float cosAngle = cos(angle);\n    const float oneMinusCosAngle = 1.0f - cosAngle;\n    const float sinAngle = sin(angle);\n\n    const float3 axisSquared = axis * axis;\n\n    const float axisXY = axis.x * axis.y * oneMinusCosAngle;\n    const float axisXZ = axis.x * axis.z * oneMinusCosAngle;\n    const float axisYZ = axis.y * axis.z * oneMinusCosAngle;\n\n    const float3 axisSinAngle = axis * sinAngle;\n\n    out\[0]\[0] = cosAngle + axisSquared.x * oneMinusCosAngle;\n    out\[0]\[1] = axisXY - axisSinAngle.z;\n    out\[0]\[2] = axisXZ + axisSinAngle.y;\n    out\[1]\[0] = axisXY + axisSinAngle.z;\n    out\[1]\[1] = cosAngle + axisSquared.y * oneMinusCosAngle;\n    out\[1]\[2] = axisYZ - axisSinAngle.x;\n    out\[2]\[0] = axisXZ - axisSinAngle.y;\n    out\[2]\[1] = axisYZ + axisSinAngle.x;\n    out\[2]\[2] = cosAngle + axisSquared.z * oneMinusCosAngle;\n\}\n\n\n/**\n * Multiply a 4d vector by a 4x4 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline void matmul(const float4x4 &m, const float4 &v, float4 &out)\n\{\n    for (int i=0; i < 4; i++)\n    \{\n        out\[i] = 0;\n\n        for (int j=0; j < 4; j++)\n        \{\n            out\[i] += m\[i]\[j] * v\[j];\n        \}\n    \}\n\}\n\n\n/**\n * Multiply a 3d vector by a 3x3 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline void matmul(const float3x3 &m, const float3 &v, float3 &out)\n\{\n    out = float3(\n        m\[0]\[0] * v.x + m\[0]\[1] * v.y + m\[0]\[2] * v.z,\n        m\[1]\[0] * v.x + m\[1]\[1] * v.y + m\[1]\[2] * v.z,\n        m\[2]\[0] * v.x + m\[2]\[1] * v.y + m\[2]\[2] * v.z\n    );\n\}\n\n\n/**\n * Multiply a 4d vector by a 4x4 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline float4 matmul(const float4x4 &m, const float4 &v)\n\{\n    float4 out;\n    for (int i=0; i < 4; i++)\n    \{\n        out\[i] = 0;\n\n        for (int j=0; j < 4; j++)\n        \{\n            out\[i] += m\[i]\[j] * v\[j];\n        \}\n    \}\n\n    return out;\n\}\n\n\n/**\n * Multiply a 3d vector by a 3x3 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline float3 matmul(const float3x3 &m, const float3 &v)\n\{\n    return float3(\n        m\[0]\[0] * v.x + m\[0]\[1] * v.y + m\[0]\[2] * v.z,\n        m\[1]\[0] * v.x + m\[1]\[1] * v.y + m\[1]\[2] * v.z,\n        m\[2]\[0] * v.x + m\[2]\[1] * v.y + m\[2]\[2] * v.z\n    );\n\}\n\n\n/**\n * Offset a point in a direction.\n *\n * @arg point: The point to offset.\n * @arg direction: The direction to offset in.\n * @arg offset: The distance to offset the point.\n *\n * @returns: The offset point.\n */\ninline float3 offsetPoint(\n        const float3 &point,\n        const float3 &direction,\n        const float offset)\n\{\n    return offset * direction + point;\n\}\n\n\n/**\n * The distance from a point to the y-axis.\n *\n * @arg position: The position to get the distance from.\n *\n * @returns: The distance to the y-axis.\n */\ninline float distanceToYAxis(const float3 &position)\n\{\n    return length(float2(position.x, position.z));\n\}\n\n\n/**\n * Compute the signed distance along a vector\n *\n * @arg vector: A vector from a point to the nearest surface of an\n *     object.\n *\n * @returns: The signed length of the vector.\n */\ninline float sdfLength(const float2 &vector)\n\{\n    return (\n        length(positivePart(vector))\n        - negativePart(maxComponent(vector))\n    );\n\}\n\n\n/**\n * Compute the signed distance along a vector\n *\n * @arg vector: A vector from a point to the nearest surface of an\n *     object.\n *\n * @returns: The signed length of the vector.\n */\ninline float sdfLength(const float3 &vector)\n\{\n    return (\n        length(positivePart(vector))\n        - negativePart(maxComponent(vector))\n    );\n\}\n\n\n/**\n * Get the length of the shorter of two vectors.\n *\n * @arg vector0: The first vector to get the length of if it is the\n *     shortest option\n * @arg vector1: The second vector to get the length of if it is the\n *     shortest option\n *\n * @returns: The shorter of the two lengths\n */\ninline float minLength(const float2 &vector0, const float2 &vector1)\n\{\n    return sqrt(min(dot2(vector0), dot2(vector1)));\n\}\n\n\n/**\n * Get the length of the shorter of two vectors.\n *\n * @arg vector0: The first vector to get the length of if it is the\n *     shortest option\n * @arg vector1: The second vector to get the length of if it is the\n *     shortest option\n *\n * @returns: The shorter of the two lengths\n */\ninline float minLength(const float3 &vector0, const float3 &vector1)\n\{\n    return sqrt(min(dot2(vector0), dot2(vector1)));\n\}\n\n\n/**\n * Convert a cartesion vector to cylindrical, without worrying about\n * the angle.\n *\n * @returns: Cylindrical coordinates without angle, (r, h)\n */\ninline float2 cartesianToCylindrical(const float3 &coordinates)\n\{\n    return float2(distanceToYAxis(coordinates), coordinates.y);\n\}\n\n\n/**\n * Convert a spherical unit vector (unit radius) to cartesion.\n *\n * @arg angles: The spherical angles in radians.\n *\n * @returns: The equivalent cartesion vector.\n */\ninline float3 sphericalUnitVectorToCartesion(const float2 &angles)\n\{\n    const float sinPhi = sin(angles.y);\n    return float3(\n        cos(angles.x) * sinPhi,\n        cos(angles.y),\n        sin(angles.x) * sinPhi\n    );\n\}\n\n\n/**\n * Get the equivalent theta and phi values that lie between \[0, 2 * PI),\n * and \[0, PI) respectively.\n *\n * @arg angles: The spherical angles in radians.\n *\n * @returns: The equivalent theta and phi.\n */\ninline float2 normalizeAngles(const float2 &angles)\n\{\n    float2 normalizedAngles = float2(\n        fmod(angles.x, 2.0f * PI),\n        fmod(angles.y, PI)\n    );\n    normalizedAngles.x += 2 * PI * (normalizedAngles.x < 0);\n    normalizedAngles.y += PI * (normalizedAngles.y < 0);\n\n    return normalizedAngles;\n\}\n\n\n/**\n * Get the x, y, and z angles between two vectors.\n *\n * @arg vector0: The first vector.\n * @arg vector1: The other vector.\n *\n * @returns: The Euler angles between the two vectors.\n */\ninline float3 anglesBetweenVectors(const float3 &vector0, const float3 &vector1)\n\{\n    return float3(\n        acos(dot(float2(vector0.y, vector0.z), float2(vector1.y, vector1.z))),\n        acos(dot(float2(vector0.x, vector0.z), float2(vector1.x, vector1.z))),\n        acos(dot(float2(vector0.x, vector0.y), float2(vector1.x, vector1.y)))\n    );\n\}\n\n\n/**\n * Get the angle and axis to use to rotate a vector onto another.\n *\n * @arg axis: The rotation angles in radians.\n * @arg out: The location to store the axis.\n *\n * @returns: The angle.\n */\ninline float getAngleAndAxisBetweenVectors(\n        const float3 &vector0,\n        const float3 &vector1,\n        float3 &axis)\n\{\n    const float3 perpendicularVector = cross(vector0, vector1);\n    if (length(perpendicularVector) > 0.0f)\n    \{\n        axis = normalize(perpendicularVector);\n    \}\n    else if (vector1.z != 0.0f || vector1.y != 0.0f)\n    \{\n        axis = normalize(cross(float3(1, 0, 0), vector1));\n    \}\n    else if (vector1.x != 0.0f || vector1.z != 0.0f)\n    \{\n        axis = normalize(cross(float3(0, 1, 0), vector1));\n    \}\n    else if (vector1.x != 0.0f || vector1.y != 0.0f)\n    \{\n        axis = normalize(cross(float3(0, 0, 1), vector1));\n    \}\n    else\n    \{\n        axis = vector0;\n    \}\n    return acos(dot(vector0, vector1));\n\}\n\n\n/**\n * Align a vector that has been defined relative to an axis with another\n * axis. For example if a vector has been chosen randomly in a\n * particular hemisphere, rotate that hemisphere to align with a new\n * axis.\n *\n * @arg unalignedAxis: The axis, about which, the vector was defined.\n * @arg alignDirection: The axis to align with.\n * @arg vectorToAlign: The vector that was defined relative to\n *     unalignedAxis.\n *\n * @returns: \n */\ninline float3 alignWithDirection(\n        const float3 &unalignedAxis,\n        const float3 &alignDirection,\n        const float3 &vectorToAlign)\n\{\n    float3 rotationAxis;\n    const float angle = getAngleAndAxisBetweenVectors(\n        unalignedAxis,\n        alignDirection,\n        rotationAxis\n    );\n\n    if (angle == 0.0f)\n    \{\n        return vectorToAlign;\n    \}\n\n    float3x3 rotationMatrix;\n    axisAngleRotationMatrix(rotationAxis, angle, rotationMatrix);\n\n    return matmul(rotationMatrix, vectorToAlign);\n\}\n\n\n/**\n * Convert a cartesion unit vector to spherical.\n *\n * @arg rayDirection: The cartesion unit vector.\n * @arg thetaOffset: Offset the theta angle by this amount.\n *\n * @returns: The spherical angles in radians.\n */\ninline float2 cartesionUnitVectorToSpherical(\n        const float3 &rayDirection,\n        const float thetaOffset)\n\{\n    return normalizeAngles(float2(\n        atan2(rayDirection.z, rayDirection.x) + thetaOffset,\n        acos(rayDirection.y)\n    ));\n\}\n\n\n/**\n * Convert a cartesion unit vector to spherical.\n *\n * @arg rayDirection: The cartesion unit vector.\n *\n * @returns: The spherical angles in radians.\n */\ninline float2 cartesionUnitVectorToSpherical(const float3 &rayDirection)\n\{\n    return normalizeAngles(float2(\n        atan2(rayDirection.z, rayDirection.x),\n        acos(rayDirection.y)\n    ));\n\}\n\n\n/**\n * Spherical unit vector dot product.\n *\n * @arg vector0: The first unit vector.\n * @arg vector1: The second unit vector.\n *\n * @returns: The spherical dot product.\n */\ninline float sphericalUnitDot(const float2 &vector0, const float2 &vector1)\n\{\n    return (\n        cos(vector0.x) * cos(vector1.x)\n        + cos(vector0.y - vector1.y) * sin(vector0.x) * sin(vector1.x)\n    );\n\}\n\n\n/**\n * Convert the uv position in a latlong image to angles.\n *\n * @arg uvPosition: The UV position.\n *\n * @returns: The equivalent angles in radians.\n */\ninline float2 uvPositionToAngles(const float2 &uvPosition)\n\{\n    return float2(\n        (uvPosition.x + 1.0f) * PI,\n        (1.0f - uvPosition.y) * PI / 2.0f\n    );\n\}\n\n\n/**\n * Convert location of a pixel in an image into UV.\n *\n * @arg pixelLocation: The x, and y positions of the pixel.\n * @arg format: The image width, and height.\n *\n * @returns: The UV position.\n */\ninline float2 pixelsToUV(const float2 &pixelLocation, const float2 &format)\n\{\n    return float2(\n        2.0f * pixelLocation.x / format.x - 1.0f,\n        2.0f * pixelLocation.y / format.y - 1.0f\n    );\n\}\n\n\n/**\n * Blend linearly between two values.\n *\n * @arg value0: The first value.\n * @arg value1: The second value.\n * @arg weight: The blend weight, 1 will return value0, and 0 will\n *     return value1.\n *\n * @returns: The blended value.\n */\ninline float blend(const float value0, const float value1, const float weight)\n\{\n    return value1 + weight * (value0 - value1);\n\}\n\n\n/**\n * Blend linearly between two values.\n *\n * @arg value0: The first value.\n * @arg value1: The second value.\n * @arg weight: The blend weight, 1 will return value0, and 0 will\n *     return value1.\n *\n * @returns: The blended value.\n */\ninline float3 blend(const float3 &value0, const float3 &value1, const float weight)\n\{\n    return value1 + weight * (value0 - value1);\n\}\n\n\n/**\n * Blend linearly between two values.\n *\n * @arg value0: The first value.\n * @arg value1: The second value.\n * @arg weight: The blend weight, 1 will return value0, and 0 will\n *     return value1.\n *\n * @returns: The blended value.\n */\ninline float4 blend(const float4 &value0, const float4 &value1, const float weight)\n\{\n    return value1 + weight * (value0 - value1);\n\}\n\n\n/**\n * Blend linearly between two values.\n *\n * @arg value0: The first value.\n * @arg value1: The second value.\n * @arg weight: The blend weight, 1 will return value0, and 0 will\n *     return value1.\n *\n * @returns: The blended value.\n */\ninline float mix(const float value0, const float value1, const float weight)\n\{\n    return (1.0f - weight) * value0 + weight * value1;\n\}\n\n\n/**\n * Blend linearly between two values.\n *\n * @arg value0: The first value.\n * @arg value1: The second value.\n * @arg weight: The blend weight, 1 will return value0, and 0 will\n *     return value1.\n *\n * @returns: The blended value.\n */\ninline float3 mix(const float3 &value0, const float3 &value1, const float weight)\n\{\n    return (1.0f - weight) * value0 + weight * value1;\n\}\n\n\n/**\n * Blend linearly between two values.\n *\n * @arg value0: The first value.\n * @arg value1: The second value.\n * @arg weight: The blend weight, 1 will return value0, and 0 will\n *     return value1.\n *\n * @returns: The blended value.\n */\ninline float4 mix(const float4 &value0, const float4 &value1, const float weight)\n\{\n    return (1.0f - weight) * value0 + weight * value1;\n\}\n\n\n\n/**\n * Get the position component of a world matrix.\n *\n * @arg worldMatrix: The world matrix.\n * @arg position: The location to store the position.\n */\ninline void positionFromWorldMatrix(const float4x4 &worldMatrix, float3 &position)\n\{\n    position = float3(\n        worldMatrix\[0]\[3],\n        worldMatrix\[1]\[3],\n        worldMatrix\[2]\[3]\n    );\n\}\n\n\n/**\n * Get the rotation component of a world matrix.\n *\n * @arg worldMatrix: The world matrix.\n * @arg rotation: The location to store the rotation.\n */\ninline void rotationFromWorldMatrix(const float4x4 &worldMatrix, float3x3 &rotationMatrix)\n\{\n    rotationMatrix\[0]\[0] = worldMatrix\[0]\[0];\n    rotationMatrix\[0]\[1] = worldMatrix\[0]\[1];\n    rotationMatrix\[0]\[2] = worldMatrix\[0]\[2];\n    rotationMatrix\[1]\[0] = worldMatrix\[1]\[0];\n    rotationMatrix\[1]\[1] = worldMatrix\[1]\[1];\n    rotationMatrix\[1]\[2] = worldMatrix\[1]\[2];\n    rotationMatrix\[2]\[0] = worldMatrix\[2]\[0];\n    rotationMatrix\[2]\[1] = worldMatrix\[2]\[1];\n    rotationMatrix\[2]\[2] = worldMatrix\[2]\[2];\n\}\n\n\n/**\n * Compute the number of samples we should use between a min and max.\n *\n * @arg minSamples: The minimum samples.\n * @arg maxSamples: The maximum samples.\n * @arg variance: The variance that weights the number of samples.\n *\n * @returns: The number of samples to take.\n */\ninline float adaptiveSamples(\n        const float minSamples,\n        const float maxSamples,\n        const float3 &variance)\n\{\n    return clamp(\n        round(maxSamples * length(variance)),\n        minSamples,\n        maxSamples\n    );\n\}\n\n\n/**\n * Combine two PDFs in an optimal manner.\n *\n * @arg pdf0: The first PDF.\n * @arg pdf1: The second PDF.\n *\n * @returns: The combined PDF.\n */\ninline float balanceHeuristic(const float pdf0, const float pdf1)\n\{\n    return pdf0 / (pdf0 + pdf1);\n\}\n\n\n//\n// Randomization functions\n//\n\n\n// Some random constants on the interval \[1, 2]\n#define RAND_CONST_0 1.571411510193971f\n#define RAND_CONST_1 1.268632820084931f\n#define RAND_CONST_2 1.7880365647937733f\n#define RAND_CONST_3 1.3546987471558234f\n#define RAND_CONST_4 1.4365958250848703f\n#define RAND_CONST_5 1.7045380669435368f\n#define RAND_CONST_6 1.2006950006793073f\n#define RAND_CONST_7 1.3877943854025474f\n#define RAND_CONST_8 1.2513180038618783f\n#define RAND_CONST_9 1.8584270278009565f\n#define RAND_CONST_10 1.1299747498069974f\n#define RAND_CONST_11 1.394137930742262f\n#define RAND_CONST_12 1.7779101864424334f\n#define RAND_CONST_13 1.8037481882044445f\n\n\n/**\n * Compute a Wang hash.\n *\n * @arg seed: The seed to hash.\n *\n * @returns: The hashed value.\n */\ninline uint wangHash(uint seed)\n\{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n\}\n\n\n/**\n * Compute a Wang hash.\n *\n * @arg seed: The seed to hash.\n *\n * @returns: The hashed value.\n */\ninline int wangHash(int seed)\n\{\n    seed = int(seed ^ 61) ^ int(seed >> 16);\n    seed *= 9;\n    seed = seed ^ (seed >> 4);\n    seed *= int(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n\}\n\n\n/**\n * Get a random value on the interval \[0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval \[0, 1].\n */\ninline float random(const float seed)\n\{\n    return fract(sin(seed * 91.3458f) * 47453.5453f);\n\}\n\n\n/**\n * Get a random value on the interval \[0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval \[0, 1].\n */\ninline float random(uint seed)\n\{\n    return float(wangHash(seed)) / 4294967296.0f;\n\}\n\n\n/**\n * Get a random value on the interval \[0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval \[0, 1].\n */\ninline float2 random(const float2 &seed)\n\{\n    return float2(\n        random(seed.x),\n        random(seed.y)\n    );\n\}\n\n\n/**\n * Get a random value on the interval \[0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval \[0, 1].\n */\ninline float3 random(const float3 &seed)\n\{\n    return float3(\n        random(seed.x),\n        random(seed.y),\n        random(seed.z)\n    );\n\}\n\n\n/**\n * Get a random value on the interval \[0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval \[0, 1].\n */\ninline float4 random(const float4 &seed)\n\{\n    return float4(\n        random(seed.x),\n        random(seed.y),\n        random(seed.z),\n        random(seed.w)\n    );\n\}\n\n\n/**\n * Create a random unit vector.\n *\n * @arg seed: The random seed.\n *\n * @returns: A random unit vector.\n */\nfloat3 randomUnitVector(const float3 &seed)\n\{\n    const float z = random(seed.x) * 2.0f - 1.0f;\n    const float a = random(seed.y) * 2.0f * PI;\n    const float r = sqrt(1.0f - z * z);\n    const float x = r * cos(a);\n    const float y = r * sin(a);\n    return normalize(float3(x, y, z));\n\}\n\n\n/**\n * Create a random unit vector in the hemisphere aligned along the\n * z-axis.\n *\n * @arg seed: The random seed.\n *\n * @returns: A random unit vector.\n */\nfloat3 uniformDirectionInZHemisphere(const float3 &seed)\n\{\n    const float uniform = random(seed.x);\n    const float r = sqrt(1.0f - uniform * uniform);\n    const float phi = 2 * PI * random(seed.y);\n \n    return float3(cos(phi) * r, sin(phi) * r, uniform);\n\}\n\n\n/**\n * Create a random unit vector in the hemisphere aligned along the\n * given axis.\n *\n * @arg axis: The axis to align the hemisphere with.\n * @arg seed: The random seed.\n *\n * @returns: A random unit vector.\n */\nfloat3 uniformDirectionInHemisphere(const float3 &axis, const float3 &seed)\n\{\n    return normalize(alignWithDirection(\n        float3(0, 0, 1),\n        axis,\n        uniformDirectionInZHemisphere(seed)\n    ));\n\}\n\n\n/**\n * Create a random point that lies within the unit circle.\n *\n * @arg seed: The random seed.\n *\n * @returns: A random point, (radius, angle) in the unit circle.\n */\ninline float2 uniformPointInUnitCircle(const float3 &seed)\n\{\n    return float2(sqrt(random(seed.x)), 2.0f * PI * random(seed.y));\n\}\n\n\n/**\n * Create a random unit vector in the hemisphere aligned along the\n * z-axis, with a distribution that is cosine weighted.\n *\n * @arg seed: The random seed.\n *\n * @returns: A random unit vector.\n */\nfloat3 cosineDirectionInZHemisphere(const float3 &seed)\n\{\n    const float uniform = random(seed.x);\n    const float r = sqrt(uniform);\n    const float angle = 2 * PI * random(seed.y);\n \n    const float x = r * cos(angle);\n    const float y = r * sin(angle);\n \n    return float3(x, y, sqrt(positivePart(1 - uniform)));\n\}\n\n\n/**\n * Create a random unit vector in the hemisphere aligned along the\n * given axis, with a distribution that is cosine weighted.\n *\n * @arg axis: The axis to align the hemisphere with.\n * @arg seed: The random seed.\n *\n * @returns: A random unit vector.\n */\nfloat3 cosineDirectionInHemisphere(const float3 &axis, const float3 &seed)\n\{\n    return normalize(alignWithDirection(\n        float3(0, 0, 1),\n        axis,\n        cosineDirectionInZHemisphere(seed)\n    ));\n\}\n\n\n/**\n * Get a random direction within a solid angle oriented along the\n * z-axis.\n *\n * https://math.stackexchange.com/questions/56784/generate-a-random-direction-within-a-cone\n *\n * @arg angle: The angle from the axis to the conical surface.\n * @arg seed: The random seed.\n *\n * @returns: A random unit vector.\n */\ninline float3 uniformDirectionInZSolidAngle(const float angle, const float3 &seed)\n\{\n    const float cosAngle = cos(angle);\n    const float z = random(seed.x) * (1.0f - cosAngle) + cosAngle;\n    const float phi = random(seed.y) * 2.0f * PI;\n\n    const float rootOneMinusZSquared = sqrt(1.0f - z * z);\n\n    return normalize(float3(\n        rootOneMinusZSquared * cos(phi),\n        rootOneMinusZSquared * sin(phi),\n        z\n    ));\n\}\n\n\n/**\n * Get a random direction within a solid angle.\n *\n * @arg axis: The direction the solid angle is aligned with.\n * @arg angle: The angle from the axis to the conical surface.\n * @arg seed: The random seed.\n *\n * @returns: A random unit vector.\n */\nfloat3 uniformDirectionInSolidAngle(\n        const float3 &axis,\n        const float angle,\n        const float3 &seed)\n\{\n    return normalize(alignWithDirection(\n        float3(0, 0, 1),\n        axis,\n        uniformDirectionInZSolidAngle(angle, seed)\n    ));\n\}\n\n\n// The MIT License (MIT)\n\n// Copyright (c) 2012-2018 Sebastien Rombauts (sebastien.rombauts@gmail.com)\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is furnished\n// to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR\n// IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n//\n// Noise functions adapted from: https://github.com/SRombauts\n//\n\n#define NOISE_ENABLED 1\n#define FBM_NOISE 2\n#define INVERT_NOISE 512\n#define SCATTERING_NOISE 1024\n#define EXTINCTION_NOISE 2048\n\n// Skewing/Unskewing factors for 2D\n#define F2 0.366025403f // F2 = (sqrt(3) - 1) / 2\n#define G2 0.211324865f // G2 = (3 - sqrt(3)) / 6   = F2 / (1 + 2 * K)\n\n// Skewing/Unskewing factors for 3D\n#define F3 1.0f / 3.0f\n#define G3 1.0f / 6.0f\n\n\n/**\n * Helper function to compute gradients-dot-residual vectors (1D)\n *\n * @note that these generate gradients of more than unit length. To make\n * a close match with the value range of classic Perlin noise, the final\n * noise values need to be rescaled to fit nicely within \[-1,1].\n * (The simplex noise functions as such also have different scaling.)\n * Note also that these noise functions are the most practical and useful\n * signed version of Perlin noise.\n *\n * @arg hash: Hash value.\n * @arg x: Distance to the corner.\n *\n * @returns: Gradient value.\n */\nfloat grad(const int hash, const float x)\n\{\n    const int h = hash & 0x0F;  // Convert low 4 bits of hash code\n    float grad = 1.0f + (h & 7);    // Gradient value 1.0, 2.0, ..., 8.0\n    if ((h & 8) != 0) grad = -grad; // Set a random sign for the gradient\n    return (grad * x);              // Multiply the gradient with the distance\n\}\n\n\n/**\n * Helper functions to compute gradients-dot-residual vectors (2D)\n *\n * @arg hash: Hash value.\n * @arg x: x coordinate of the distance to the corner.\n * @arg y: y coordinate of the distance to the corner.\n *\n * @returns: Gradient value.\n */\nfloat grad(const int hash, const float x, const float y)\n\{\n    const int h = hash & 0x3F;  // Convert low 3 bits of hash code\n    const float u = h < 4 ? x : y;  // into 8 simple gradient directions,\n    const float v = h < 4 ? y : x;\n    // and compute the dot product with (x,y).\n    return ((h & 1) ? -u : u) + ((h & 2) ? -2.0f * v : 2.0f * v);\n\}\n\n\n/**\n * Helper functions to compute gradients-dot-residual vectors (3D)\n *\n * @arg hash: Hash value.\n * @arg x: x coordinate of the distance to the corner.\n * @arg y: y coordinate of the distance to the corner.\n * @arg z: z coordinate of the distance to the corner.\n *\n * @returns: Gradient value\n */\nfloat grad(const int hash, const float x, const float y, const float z)\n\{\n    const int h = hash & 15;     // Convert low 4 bits of hash code into 12 simple\n    const float u = h < 8 ? x : y; // gradient directions, and compute dot product.\n    const float v = h < 4 ? y : h == 12 || h == 14 ? x : z; // Fix repeats at h = 12 to 15\n    return ((h & 1) ? -u : u) + ((h & 2) ? -v : v);\n\}\n\n\n/**\n * 1D Perlin simplex noise\n * Takes around 74ns on an AMD APU.\n *\n * @arg seed: The seed for the noise.\n *\n * @returns: Noise value in the range \[-1, 1], value of 0 on all integer\n *     coordinates.\n */\nfloat perlinSimplexNoise(const float seed)\n\{\n    float n0, n1; // Noise contributions from the two \"corners\"\n\n    // Corners coordinates (nearest integer values):\n    const int i0 = floor(seed);\n    const int i1 = i0 + 1;\n    // Distances to corners (between 0 and 1):\n    const float x0 = seed - i0;\n    const float x1 = x0 - 1.0f;\n\n    // Calculate the contribution from the first corner\n    float t0 = 1.0f - x0 * x0;\n    t0 *= t0;\n    n0 = t0 * t0 * grad(wangHash(i0), x0);\n\n    // Calculate the contribution from the second corner\n    float t1 = 1.0f - x1 * x1;\n    t1 *= t1;\n    n1 = t1 * t1 * grad(wangHash(i1), x1);\n\n    // The maximum value of this noise is 8*(3/4)^4 = 2.53125\n    // A factor of 0.395 scales to fit exactly within \[-1,1]\n    return 0.395f * (n0 + n1);\n\}\n\n\n/**\n * 2D Perlin simplex noise\n * Takes around 150ns on an AMD APU.\n *\n * @arg seed: The seed for the noise.\n *\n * @returns: Noise value in the range \[-1, 1], value of 0 on all integer\n *     coordinates.\n */\nfloat perlinSimplexNoise(const float2 &seed)\n\{\n    float n0, n1, n2;   // Noise contributions from the three corners\n\n    // Skew the input space to determine which simplex cell we're in\n    const float s = sumComponent(seed) * F2;  // Hairy factor for 2D\n    const float xs = seed.x + s;\n    const float ys = seed.y + s;\n    const int i = floor(xs);\n    const int j = floor(ys);\n\n    // Unskew the cell origin back to (x,y) space\n    const float t = float(i + j) * G2;\n    const float X0 = i - t;\n    const float Y0 = j - t;\n    const float x0 = seed.x - X0;  // The x,y distances from the cell origin\n    const float y0 = seed.y - Y0;\n\n    // For the 2D case, the simplex shape is an equilateral triangle.\n    // Determine which simplex we are in.\n    int i1, j1;  // Offsets for second (middle) corner of simplex in (i,j) coords\n    if (x0 > y0)\n    \{   \n        // lower triangle, XY order: (0,0)->(1,0)->(1,1)\n        i1 = 1;\n        j1 = 0;\n    \}\n    else\n    \{   \n        // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n        i1 = 0;\n        j1 = 1;\n    \}\n\n    // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n    // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n    // c = (3-sqrt(3))/6\n\n    // Offsets for middle corner in (x,y) unskewed coords\n    const float x1 = x0 - i1 + G2;\n    const float y1 = y0 - j1 + G2;\n    // Offsets for last corner in (x,y) unskewed coords\n    const float x2 = x0 - 1.0f + 2.0f * G2;\n    const float y2 = y0 - 1.0f + 2.0f * G2;\n\n    // Work out the hashed gradient indices of the three simplex corners\n    const int gi0 = wangHash(i + wangHash(j));\n    const int gi1 = wangHash(i + i1 + wangHash(j + j1));\n    const int gi2 = wangHash(i + 1 + wangHash(j + 1));\n\n    // Calculate the contribution from the first corner\n    float t0 = 0.5f - x0 * x0 - y0 * y0;\n    if (t0 < 0.0f)\n    \{\n        n0 = 0.0f;\n    \}\n    else\n    \{\n        t0 *= t0;\n        n0 = t0 * t0 * grad(gi0, x0, y0);\n    \}\n\n    // Calculate the contribution from the second corner\n    float t1 = 0.5f - x1 * x1 - y1 * y1;\n    if (t1 < 0.0f)\n    \{\n        n1 = 0.0f;\n    \}\n    else\n    \{\n        t1 *= t1;\n        n1 = t1 * t1 * grad(gi1, x1, y1);\n    \}\n\n    // Calculate the contribution from the third corner\n    float t2 = 0.5f - x2 * x2 - y2 * y2;\n    if (t2 < 0.0f)\n    \{\n        n2 = 0.0f;\n    \}\n    else\n    \{\n        t2 *= t2;\n        n2 = t2 * t2 * grad(gi2, x2, y2);\n    \}\n\n    // Add contributions from each corner to get the final noise value.\n    // The result is scaled to return values in the interval \[-1,1].\n    return 45.23065f * (n0 + n1 + n2);\n\}\n\n\n/**\n * 3D Perlin simplex noise\n *\n * @arg seed: The seed for the noise.\n *\n * @returns: Noise value in the range \[-1, 1], value of 0 on all integer\n *     coordinates.\n */\nfloat perlinSimplexNoise(const float3 &seed)\n\{\n    float n0, n1, n2, n3; // Noise contributions from the four corners\n\n    // Skew the input space to determine which simplex cell we're in\n    const float s = sumComponent(seed) * F3; // Very nice and simple skew factor for 3D\n    const int i = floor(seed.x + s);\n    const int j = floor(seed.y + s);\n    const int k = floor(seed.z + s);\n    const float t = (i + j + k) * G3;\n    const float X0 = i - t; // Unskew the cell origin back to (x,y,z) space\n    const float Y0 = j - t;\n    const float Z0 = k - t;\n    const float x0 = seed.x - X0; // The x,y,z distances from the cell origin\n    const float y0 = seed.y - Y0;\n    const float z0 = seed.z - Z0;\n\n    // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n    // Determine which simplex we are in.\n    int i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords\n    int i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords\n    if (x0 >= y0)\n    \{\n        if (y0 >= z0)\n        \{\n            i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0; // X Y Z order\n        \}\n        else if (x0 >= z0)\n        \{\n            i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1; // X Z Y order\n        \}\n        else\n        \{\n            i1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1; // Z X Y order\n        \}\n    \}\n    else\n    \{ // x0<y0\n        if (y0 < z0)\n        \{\n            i1 = 0; j1 = 0; k1 = 1; i2 = 0; j2 = 1; k2 = 1; // Z Y X order\n        \}\n        else if (x0 < z0)\n        \{\n            i1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1; // Y Z X order\n        \}\n        else\n        \{\n            i1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0; // Y X Z order\n        \}\n    \}\n\n    // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),\n    // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and\n    // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where\n    // c = 1/6.\n    const float x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords\n    const float y1 = y0 - j1 + G3;\n    const float z1 = z0 - k1 + G3;\n    const float x2 = x0 - i2 + 2.0f * G3; // Offsets for third corner in (x,y,z) coords\n    const float y2 = y0 - j2 + 2.0f * G3;\n    const float z2 = z0 - k2 + 2.0f * G3;\n    const float x3 = x0 - 1.0f + 3.0f * G3; // Offsets for last corner in (x,y,z) coords\n    const float y3 = y0 - 1.0f + 3.0f * G3;\n    const float z3 = z0 - 1.0f + 3.0f * G3;\n\n    // Work out the hashed gradient indices of the four simplex corners\n    const int gi0 = wangHash(i + wangHash(j + wangHash(k)));\n    const int gi1 = wangHash(i + i1 + wangHash(j + j1 + wangHash(k + k1)));\n    const int gi2 = wangHash(i + i2 + wangHash(j + j2 + wangHash(k + k2)));\n    const int gi3 = wangHash(i + 1 + wangHash(j + 1 + wangHash(k + 1)));\n\n    // Calculate the contribution from the four corners\n    float t0 = 0.6f - x0 * x0 - y0 * y0 - z0 * z0;\n    if (t0 < 0)\n    \{\n        n0 = 0.0;\n    \}\n    else\n    \{\n        t0 *= t0;\n        n0 = t0 * t0 * grad(gi0, x0, y0, z0);\n    \}\n    float t1 = 0.6f - x1 * x1 - y1 * y1 - z1 * z1;\n    if (t1 < 0)\n    \{\n        n1 = 0.0;\n    \}\n    else\n    \{\n        t1 *= t1;\n        n1 = t1 * t1 * grad(gi1, x1, y1, z1);\n    \}\n    float t2 = 0.6f - x2 * x2 - y2 * y2 - z2 * z2;\n    if (t2 < 0)\n    \{\n        n2 = 0.0;\n    \}\n    else\n    \{\n        t2 *= t2;\n        n2 = t2 * t2 * grad(gi2, x2, y2, z2);\n    \}\n    float t3 = 0.6f - x3 * x3 - y3 * y3 - z3 * z3;\n    if (t3 < 0)\n    \{\n        n3 = 0.0;\n    \}\n    else\n    \{\n        t3 *= t3;\n        n3 = t3 * t3 * grad(gi3, x3, y3, z3);\n    \}\n    // Add contributions from each corner to get the final noise value.\n    // The result is scaled to stay just inside \[-1,1]\n    return 32.0f * (n0 + n1 + n2 + n3);\n\}\n\n\n/**\n * 4D Perlin simplex noise\n *\n * @arg seed: The seed for the noise.\n * @arg simplex: The simplex LUT.\n * @arg perm: The perm LUT.\n * @arg grad4: The grad4 LUT.\n *\n * @returns: Noise value in the range \[-1, 1], value of 0 on all integer\n *     coordinates.\n */\ninline float perlinSimplexNoise(\n        const float4 &seed,\n        const int simplex\[64]\[4],\n        const int perm\[512],\n        const int grad4\[32]\[4])\n\{\n    const float F4 = (sqrt(5.0f) - 1.0f) / 4.0f;\n    const float G4 = (5.0f - sqrt(5.0f)) / 20.0f;\n\n    const float x = seed.x;\n    const float y = seed.y;\n    const float z = seed.z;\n    const float w = seed.w;\n\n    const float s = (x + y + z + w) * F4;\n    const int i = floor(x + s);\n    const int j = floor(y + s);\n    const int k = floor(z + s);\n    const int l = floor(w + s);\n    const float t = (i + j + k + l) * G4;\n    const float X0 = i - t;\n    const float Y0 = j - t;\n    const float Z0 = k - t;\n    const float W0 = l - t;\n\n    const float x0 = x - X0;\n    const float y0 = y - Y0;\n    const float z0 = z - Z0;\n    const float w0 = w - W0;\n    const int c1 = (x0 > y0) ? 32 : 0;\n    const int c2 = (x0 > z0) ? 16 : 0;\n    const int c3 = (y0 > z0) ? 8 : 0;\n    const int c4 = (x0 > w0) ? 4 : 0;\n    const int c5 = (y0 > w0) ? 2 : 0;\n    const int c6 = (z0 > w0) ? 1 : 0;\n    const int c = c1 + c2 + c3 + c4 + c5 + c6;\n\n    const int i1 = simplex\[c]\[0]>=3 ? 1 : 0;\n    const int j1 = simplex\[c]\[1]>=3 ? 1 : 0;\n    const int k1 = simplex\[c]\[2]>=3 ? 1 : 0;\n    const int l1 = simplex\[c]\[3]>=3 ? 1 : 0;\n    const int i2 = simplex\[c]\[0]>=2 ? 1 : 0;\n    const int j2 = simplex\[c]\[1]>=2 ? 1 : 0;\n    const int k2 = simplex\[c]\[2]>=2 ? 1 : 0;\n    const int l2 = simplex\[c]\[3]>=2 ? 1 : 0;\n    const int i3 = simplex\[c]\[0]>=1 ? 1 : 0;\n    const int j3 = simplex\[c]\[1]>=1 ? 1 : 0;\n    const int k3 = simplex\[c]\[2]>=1 ? 1 : 0;\n    const int l3 = simplex\[c]\[3]>=1 ? 1 : 0;\n\n    const float x1 = x0 - i1 + G4;\n    const float y1 = y0 - j1 + G4;\n    const float z1 = z0 - k1 + G4;\n    const float w1 = w0 - l1 + G4;\n    const float x2 = x0 - i2 + 2.0 * G4;\n    const float y2 = y0 - j2 + 2.0 * G4;\n    const float z2 = z0 - k2 + 2.0 * G4;\n    const float w2 = w0 - l2 + 2.0 * G4;\n    const float x3 = x0 - i3 + 3.0 * G4;\n    const float y3 = y0 - j3 + 3.0 * G4;\n    const float z3 = z0 - k3 + 3.0 * G4;\n    const float w3 = w0 - l3 + 3.0 * G4;\n    const float x4 = x0 - 1.0 + 4.0 * G4;\n    const float y4 = y0 - 1.0 + 4.0 * G4;\n    const float z4 = z0 - 1.0 + 4.0 * G4;\n    const float w4 = w0 - 1.0 + 4.0 * G4;\n\n    const int ii = i & 255;\n    const int jj = j & 255;\n    const int kk = k & 255;\n    const int ll = l & 255;\n\n    const int gi0 = perm\[ii + perm\[jj + perm\[kk + perm\[ll]]]] % 32;\n    const int gi1 = perm\[ii + i1 + perm\[jj + j1 + perm\[kk + k1 + perm\[ll + l1]]]] % 32;\n    const int gi2 = perm\[ii + i2 + perm\[jj +j2 + perm\[kk + k2 + perm\[ll + l2]]]] % 32;\n    const int gi3 = perm\[ii + i3 + perm\[jj +j3 + perm\[kk + k3 + perm\[ll + l3]]]] % 32;\n    const int gi4 = perm\[ii + 1 + perm\[jj +1 + perm\[kk + 1 + perm\[ll + 1]]]] % 32;\n\n    float n0, n1, n2, n3, n4;\n    float t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;\n    if (t0 < 0)\n    \{\n        n0 = 0.0;\n    \}\n    else\n    \{\n        t0 *= t0;\n        n0 = t0 * t0 * dot(\n            float4(grad4\[gi0]\[0], grad4\[gi0]\[2], grad4\[gi0]\[3], grad4\[gi0]\[3]),\n            float4(x0, y0, z0, w0)\n        );\n    \}\n\n    float t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;\n    if (t1 < 0)\n    \{\n        n1 = 0.0;\n    \}\n    else\n    \{\n        t1 *= t1;\n        n1 = t1 * t1 * dot(\n            float4(grad4\[gi1]\[0], grad4\[gi1]\[2], grad4\[gi1]\[3], grad4\[gi1]\[3]),\n            float4(x1, y1, z1, w1)\n        );\n    \}\n\n    float t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;\n    if (t2 < 0)\n    \{\n        n2 = 0.0;\n    \}\n    else\n    \{\n        t2 *= t2;\n        n2 = t2 * t2 * dot(\n            float4(grad4\[gi2]\[0], grad4\[gi2]\[2], grad4\[gi2]\[3], grad4\[gi2]\[3]),\n            float4(x2, y2, z2, w2)\n        );\n    \}\n\n    float t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;\n    if (t3 < 0)\n    \{\n        n3 = 0.0;\n    \}\n    else\n    \{\n        t3 *= t3;\n        n3 = t3 * t3 * dot(\n            float4(grad4\[gi3]\[0], grad4\[gi3]\[2], grad4\[gi3]\[3], grad4\[gi3]\[3]),\n            float4(x3, y3, z3, w3)\n        );\n    \}\n\n    float t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;\n    if (t4 < 0)\n    \{\n        n4 = 0.0;\n    \}\n    else \{\n        t4 *= t4;\n        n4 = t4 * t4 * dot(\n            float4(grad4\[gi4]\[0], grad4\[gi4]\[2], grad4\[gi4]\[3], grad4\[gi4]\[3]),\n            float4(x4, y4, z4, w4)\n        );\n    \}\n\n    return 27.0 * (n0 + n1 + n2 + n3 + n4);\n\}\n\n\n// Copyright 2022 by Owen Bulka.\n// All rights reserved.\n// This file is released under the \"MIT License Agreement\".\n// Please see the LICENSE.md file that should have been included as part\n// of this package.\n\n//\n// Use the perlin simplex noise\n//\n\n\n/**\n * fBM noise.\n *\n * @arg octaves: The number of different frequencies to use.\n * @arg lacunarity: The per octave frequency multiplier.\n * @arg size: The size of the noise.\n * @arg gain: The per octave amplitude multiplier.\n * @arg gamma: The result will be raised to 1 over this power.\n * @arg position: The position to seed the noise.\n *\n * @returns: The noise value in the range \[-1, 1].\n */\nfloat fractalBrownianMotionNoise(\n        const int octaves,\n        const float lacunarity,\n        const float size,\n        const float gain,\n        const float gamma,\n        const float position)\n\{\n    float output = 0.0f;\n    float denom = 0.0f;\n    float frequency = lacunarity;\n    float amplitude = gain;\n\n    for (int octave = 0; octave < octaves; octave++)\n    \{\n        output += amplitude * perlinSimplexNoise(position * frequency / size);\n        denom += amplitude;\n\n        frequency *= lacunarity;\n        amplitude *= gain;\n    \}\n\n    if (denom == 0.0f || gamma == 0.0f)\n    \{\n        return 1.0f;\n    \}\n    return pow(output / denom, 1.0f / gamma);\n\}\n\n\n/**\n * fBM noise.\n *\n * @arg octaves: The number of different frequencies to use.\n * @arg lacunarity: The per octave frequency multiplier.\n * @arg size: The size of the noise.\n * @arg gain: The per octave amplitude multiplier.\n * @arg gamma: The result will be raised to 1 over this power.\n * @arg position: The position to seed the noise.\n *\n * @returns: The noise value in the range \[-1, 1].\n */\nfloat fractalBrownianMotionNoise(\n        const int octaves,\n        const float lacunarity,\n        const float size,\n        const float gain,\n        const float gamma,\n        const float2 &position)\n\{\n    float output = 0.0f;\n    float denom = 0.0f;\n    float frequency = lacunarity;\n    float amplitude = gain;\n\n    for (int octave = 0; octave < octaves; octave++)\n    \{\n        output += amplitude * perlinSimplexNoise(position * frequency / size);\n        denom += amplitude;\n\n        frequency *= lacunarity;\n        amplitude *= gain;\n    \}\n\n    if (denom == 0.0f || gamma == 0.0f)\n    \{\n        return 1.0f;\n    \}\n    return pow(output / denom, 1.0f / gamma);\n\}\n\n\n/**\n * fBM noise.\n *\n * @arg octaves: The number of different frequencies to use.\n * @arg lacunarity: The per octave frequency multiplier.\n * @arg size: The size of the noise.\n * @arg gain: The per octave amplitude multiplier.\n * @arg gamma: The result will be raised to 1 over this power.\n * @arg position: The position to seed the noise.\n *\n * @returns: The noise value in the range \[-1, 1].\n */\nfloat fractalBrownianMotionNoise(\n        const int octaves,\n        const float lacunarity,\n        const float size,\n        const float gain,\n        const float gamma,\n        const float3 &position)\n\{\n    float output = 0.0f;\n    float denom = 0.0f;\n    float frequency = lacunarity;\n    float amplitude = gain;\n\n    for (int octave = 0; octave < octaves; octave++)\n    \{\n        output += amplitude * perlinSimplexNoise(position * frequency / size);\n        denom += amplitude;\n\n        frequency *= lacunarity;\n        amplitude *= gain;\n    \}\n\n    if (denom == 0.0f || gamma == 0.0f)\n    \{\n        return 1.0f;\n    \}\n    return pow(output / denom, 1.0f / gamma);\n\}\n\n\n/**\n * fBM noise.\n *\n * @arg octaves: The number of different frequencies to use.\n * @arg lacunarity: The per octave frequency multiplier.\n * @arg size: The size of the noise.\n * @arg gain: The per octave amplitude multiplier.\n * @arg gamma: The result will be raised to 1 over this power.\n * @arg position: The position to seed the noise.\n * @arg lowFrequencyScale: The amount to scale the lower frequencies by.\n * @arg highFrequencyScale: The amount to scale the higher frequencies by.\n * @arg lowFrequencyTranslation: The translation of the lower frequencies.\n * @arg highFrequencyTranslation: The translation of the higher frequencies.\n * @arg simplex: The simplex LUT.\n * @arg perm: The perm LUT.\n * @arg grad4: The grad4 LUT.\n *\n * @returns: The noise value in the range \[-1, 1].\n */\nfloat fractalBrownianMotionNoise(\n        const float octaves,\n        const float lacunarity,\n        const float size,\n        const float gain,\n        const float gamma,\n        const float4 &position,\n        const float4 &lowFrequencyScale,\n        const float4 &highFrequencyScale,\n        const float4 &lowFrequencyTranslation,\n        const float4 &highFrequencyTranslation,\n        const int simplex\[64]\[4],\n        const int perm\[512],\n        const int grad4\[32]\[4])\n\{\n    float output = 0.0f;\n    float frequency = lacunarity;\n    float amplitude = 1.0f;\n    float denom = 0.0f;\n    float4 translation;\n    float4 scale;\n\n    for (int octave=0; octave < octaves; octave++)\n    \{\n        const float octaveFraction = octave / octaves;\n        scale = (\n            (highFrequencyScale * octaveFraction)\n            + (lowFrequencyScale * (1 - octaveFraction))\n        );       \n        translation = (\n            (highFrequencyTranslation * octaveFraction)\n            + (lowFrequencyTranslation * (1 - octaveFraction))\n        );\n\n        output += amplitude * perlinSimplexNoise(\n            (position * scale + translation) * frequency / size,\n            simplex,\n            perm,\n            grad4\n        );\n\n        frequency *= lacunarity;\n        denom += amplitude;\n        amplitude *= gain;\n    \}\n\n    if (denom == 0.0f || gamma == 0.0f)\n    \{\n        return 1.0f;\n    \}\n    return pow(output / denom, 1.0f / gamma);\n\}\n\n\n/**\n * Turbulence noise.\n *\n * @arg octaves: The number of different frequencies to use.\n * @arg lacunarity: The per octave frequency multiplier.\n * @arg size: The size of the noise.\n * @arg gain: The per octave amplitude multiplier.\n * @arg gamma: The result will be raised to 1 over this power.\n * @arg position: The position to seed the noise.\n *\n * @returns: The noise value in the range \[0, 1].\n */\nfloat turbulenceNoise(\n        const int octaves,\n        const float lacunarity,\n        const float size,\n        const float gain,\n        const float gamma,\n        const float position)\n\{\n    float output = 0.0f;\n    float denom = 0.0f;\n    float frequency = lacunarity;\n    float amplitude = gain;\n\n    for (int octave = 0; octave < octaves; octave++)\n    \{\n        output += fabs(amplitude * perlinSimplexNoise(position * frequency / size));\n        denom += amplitude;\n\n        frequency *= lacunarity;\n        amplitude *= gain;\n    \}\n\n    if (denom == 0.0f || gamma == 0.0f)\n    \{\n        return 1.0f;\n    \}\n    return pow(output / denom, 1.0f / gamma);\n\}\n\n\n/**\n * Turbulence noise.\n *\n * @arg octaves: The number of different frequencies to use.\n * @arg lacunarity: The per octave frequency multiplier.\n * @arg size: The size of the noise.\n * @arg gain: The per octave amplitude multiplier.\n * @arg gamma: The result will be raised to 1 over this power.\n * @arg position: The position to seed the noise.\n *\n * @returns: The noise value in the range \[0, 1].\n */\nfloat turbulenceNoise(\n        const int octaves,\n        const float lacunarity,\n        const float size,\n        const float gain,\n        const float gamma,\n        const float2 &position)\n\{\n    float output = 0.0f;\n    float denom = 0.0f;\n    float frequency = lacunarity;\n    float amplitude = gain;\n\n    for (int octave = 0; octave < octaves; octave++)\n    \{\n        output += fabs(amplitude * perlinSimplexNoise(position * frequency / size));\n        denom += amplitude;\n\n        frequency *= lacunarity;\n        amplitude *= gain;\n    \}\n\n    if (denom == 0.0f || gamma == 0.0f)\n    \{\n        return 1.0f;\n    \}\n    return pow(output / denom, 1.0f / gamma);\n\}\n\n\n/**\n * Turbulence noise.\n *\n * @arg octaves: The number of different frequencies to use.\n * @arg lacunarity: The per octave frequency multiplier.\n * @arg size: The size of the noise.\n * @arg gain: The per octave amplitude multiplier.\n * @arg gamma: The result will be raised to 1 over this power.\n * @arg position: The position to seed the noise.\n *\n * @returns: The noise value in the range \[0, 1].\n */\nfloat turbulenceNoise(\n        const int octaves,\n        const float lacunarity,\n        const float size,\n        const float gain,\n        const float gamma,\n        const float3 &position)\n\{\n    float output = 0.0f;\n    float denom = 0.0f;\n    float frequency = lacunarity;\n    float amplitude = gain;\n\n    for (int octave = 0; octave < octaves; octave++)\n    \{\n        output += fabs(amplitude * perlinSimplexNoise(position * frequency / size));\n        denom += amplitude;\n\n        frequency *= lacunarity;\n        amplitude *= gain;\n    \}\n\n    if (denom == 0.0f || gamma == 0.0f)\n    \{\n        return 1.0f;\n    \}\n    return pow(output / denom, 1.0f / gamma);\n\}\n\n\n/**\n * Turbulence noise.\n *\n * @arg octaves: The number of different frequencies to use.\n * @arg lacunarity: The per octave frequency multiplier.\n * @arg size: The size of the noise.\n * @arg gain: The per octave amplitude multiplier.\n * @arg gamma: The result will be raised to 1 over this power.\n * @arg position: The position to seed the noise.\n * @arg lowFrequencyScale: The amount to scale the lower frequencies by.\n * @arg highFrequencyScale: The amount to scale the higher frequencies by.\n * @arg lowFrequencyTranslation: The translation of the lower frequencies.\n * @arg highFrequencyTranslation: The translation of the higher frequencies.\n * @arg simplex: The simplex LUT.\n * @arg perm: The perm LUT.\n * @arg grad4: The grad4 LUT.\n *\n * @returns: The noise value in the range \[0, 1].\n */\nfloat turbulenceNoise(\n        const float octaves,\n        const float lacunarity,\n        const float size,\n        const float gain,\n        const float gamma,\n        const float4 &position,\n        const float4 &lowFrequencyScale,\n        const float4 &highFrequencyScale,\n        const float4 &lowFrequencyTranslation,\n        const float4 &highFrequencyTranslation,\n        const int simplex\[64]\[4],\n        const int perm\[512],\n        const int grad4\[32]\[4])\n\{\n    float output = 0.0f;\n    float frequency = lacunarity;\n    float amplitude = 1.0f;\n    float denom = 0.0f;\n    float4 translation;\n    float4 scale;\n\n    for (int octave=0; octave < octaves; octave++)\n    \{\n        const float octaveFraction = octave / octaves;\n        scale = (\n            (highFrequencyScale * octaveFraction)\n            + (lowFrequencyScale * (1 - octaveFraction))\n        );       \n        translation = (\n            (highFrequencyTranslation * octaveFraction)\n            + (lowFrequencyTranslation * (1 - octaveFraction))\n        );\n\n        output += fabs(\n            amplitude * perlinSimplexNoise(\n                (position * scale + translation) * frequency / size,\n                simplex,\n                perm,\n                grad4\n            )\n        );\n\n        frequency *= lacunarity;\n        denom += amplitude;\n        amplitude *= gain;\n    \}\n\n    if (denom == 0.0f || gamma == 0.0f)\n    \{\n        return 1.0f;\n    \}\n    return pow(output / denom, 1.0f / gamma);\n\}\n\n\n//\n// Handle Various Lights\n//\n\n#define AMBIENT_LIGHT 0\n#define AMBIENT_OCCLUSION 1\n#define DIRECTIONAL_LIGHT 2\n#define POINT_LIGHT 3\n\n\n/**\n * Perform multiple importance sampling by combining probability\n * distribution functions.\n *\n * @arg emittance: The emissive values of the surface.\n * @arg throughput: The throughput of the ray.\n * @arg pdf0: The first PDF.\n * @arg pdf1: The second PDF.\n *\n * @returns: The multiple importance sampled colour.\n */\ninline float4 multipleImportanceSample(\n        const float4 &emittance,\n        const float4 &throughput,\n        const float pdf0,\n        const float pdf1)\n\{\n    return emittance * throughput * balanceHeuristic(pdf0, pdf1);\n\}\n\n\n/**\n * Get the probability distribution function for equi-angular sampling.\n *\n * @arg uniform: A uniform step distance along the ray.\n * @arg maxRayDistance: The maximum distance the ray can travel.\n * @arg rayOrigin: The origin of the ray.\n * @arg rayDirection: The direction of the ray.\n * @arg lightPosition: The position of the light.\n * @arg distance: The equi-angular distance.\n *\n * @returns: The probability distribution function.\n */\nfloat sampleEquiangularPDF(\n        const float uniform,\n        const float maxRayDistance,\n        const float3 &rayOrigin,\n        const float3 &rayDirection,\n        const float3 &lightPosition,\n        float &distance)\n\{\n    // Get the coordinate of the closest point to the light along an\n    // infinite ray\n    const float delta = dot(lightPosition - rayOrigin, rayDirection);\n\n    // Get distance this point is from light\n    const float D = length(rayOrigin + delta * rayDirection - lightPosition);\n\n    if (D == 0.0f)\n    \{\n        distance = 0.0f;\n        return 1.0f;\n    \}\n\n    // Get the angle of the endpoints\n    const float thetaA = atan2(-delta, D);\n    const float thetaB = atan2(maxRayDistance - delta, D);\n\n    // Take a sample\n    const float t = D * tan(mix(thetaA, thetaB, uniform));\n\n    distance = delta + t;\n\n    if (thetaA != thetaB)\n    \{\n        return D / ((thetaB - thetaA) * (D * D + t * t));\n    \}\n\n    return 1.0f;\n\}\n\n\n/**\n * Get the direction, and distance of a spherical light.\n *\n * @arg seed: The seed to use in randomization.\n * @arg surfaceNormal: The normal to the surface at the position we\n *     are sampling the illumination of.\n * @arg lightDirection: Will store the direction to the light.\n * @arg distanceToLight: Will store the distance to the light.\n */\ninline void hdriLightData(\n        const float3 &seed,\n        const float3 &surfaceNormal,\n        float3 &lightDirection,\n        float &distanceToLight)\n\{\n    lightDirection = cosineDirectionInHemisphere(surfaceNormal, seed);\n    distanceToLight = 1.0f;\n\}\n\n\n/**\n * Get the direction, and distance of a spherical light.\n *\n * @arg seed: The seed to use in randomization.\n * @arg pointOnSurface: The point on the surface to compute the\n *     light intensity at.\n * @arg lightPosition: The position of the light.\n * @arg radius: The radius of the sphere.\n * @arg lightDirection: Will store the direction to the light.\n * @arg distanceToLight: Will store the distance to the light.\n * @arg visibleSurfaceArea: The surface area that is visible to the\n *     position we are sampling from.\n */\ninline void sphericalLightData(\n        const float3 &seed,\n        const float3 &pointOnSurface,\n        const float3 &lightPosition,\n        const float radius,\n        float3 &lightDirection,\n        float &distanceToLight,\n        float &visibleSurfaceArea)\n\{\n    visibleSurfaceArea = 2.0f * PI * radius * radius;\n    float3 lightNormal = uniformDirectionInHemisphere(\n        normalize(pointOnSurface - lightPosition),\n        seed\n    );\n    lightDirection = lightPosition + lightNormal * radius - pointOnSurface;\n    distanceToLight = length(lightDirection);\n    lightDirection = normalize(lightDirection);\n\}\n\n\n\n/**\n * Get the direction, and distance of a directional light.\n *\n * @arg direction: The direction the light is travelling.\n * @arg maxRayDistance: The maximum distance the ray can travel.\n * @arg lightDirection: Will store the direction to the light.\n * @arg distanceToLight: Will store the distance to the light.\n * @arg visibleSurfaceArea: The surface area that is visible to the\n *     position we are sampling from.\n */\ninline void directionalLightData(\n        const float3 &direction,\n        float3 &lightDirection,\n        float &distanceToLight,\n        float &visibleSurfaceArea)\n\{\n    visibleSurfaceArea = 2.0f * PI;\n    distanceToLight = 1.0f;\n    lightDirection = normalize(-direction);\n\}\n\n\n/**\n * Get the direction, and distance of a point light.\n *\n * @arg pointOnSurface: The point on the surface to compute the\n *     light intensity at.\n * @arg position: The position of the light.\n * @arg lightDirection: Will store the direction to the light.\n * @arg distanceToLight: Will store the distance to the light.\n * @arg visibleSurfaceArea: The surface area that is visible to the\n *     position we are sampling from.\n */\ninline void pointLightData(\n        const float3 &pointOnSurface,\n        const float3 &position,\n        float3 &lightDirection,\n        float &distanceToLight,\n        float &visibleSurfaceArea)\n\{\n    visibleSurfaceArea = 0.0f;\n    lightDirection = position - pointOnSurface;\n    distanceToLight = length(lightDirection);\n    lightDirection = normalize(lightDirection);\n\}\n\n\n/**\n * Get the probability distribution function for the lights in the\n * scene.\n *\n * @arg numLights: The number of lights in the scene.\n * @arg visibleSurfaceArea: The surface area that is visible to the\n *     position we are sampling from.\n *\n * @returns: The probability distribution function.\n */\ninline float sampleLightsPDF(const float numLights, const float visibleSurfaceArea)\n\{\n    if (visibleSurfaceArea == 0.0f)\n    \{\n        return 1.0f / numLights;\n    \}\n    else\n    \{\n        return 1.0f / numLights / visibleSurfaceArea;\n    \}\n\}\n\n\n/**\n * Get the direction, distance, and intensity of a light.\n *\n * @arg intensity: The light intensity.\n * @arg falloff: The power of the falloff of the light.\n * @arg distanceToLight: The distance to the light.\n *\n * @returns: The light intensity.\n */\ninline float lightIntensity(\n        const float intensity,\n        const float falloff,\n        const float distanceToLight)\n\{\n    return intensity / pow(distanceToLight, falloff);\n\}\n\n\n/**\n * Get the direction, distance, and intensity of a light.\n *\n * @arg pointOnSurface: The point on the surface to compute the\n *     light intensity at.\n * @arg light: The light properties which depend on the light type.\n * @arg lightType: The type of light to compute the intensity for.\n *     0: directional\n *     1: point\n *     2: ambient\n *     3: ambient occlusion\n * @arg maxRayDistance: The maximum distance a ray can travel.\n * @arg distanceToLight: Will store the distance to the light.\n * @arg visibleSurfaceArea: The surface area that is visible to the\n *     position we are sampling from.\n * @arg lightDirection: Will store the direction to the light.\n */\ninline void getLightData(\n        const float3 &pointOnSurface,\n        const float3 &light,\n        const int lightType,\n        float &distanceToLight,\n        float &visibleSurfaceArea,\n        float3 &lightDirection)\n\{\n    if (lightType == DIRECTIONAL_LIGHT)\n    \{\n        // directional\n        directionalLightData(\n            light,\n            lightDirection,\n            distanceToLight,\n            visibleSurfaceArea\n        );\n    \}\n    else if (lightType == POINT_LIGHT)\n    \{\n        // point\n        pointLightData(\n            pointOnSurface,\n            light,\n            lightDirection,\n            distanceToLight,\n            visibleSurfaceArea\n        );\n    \}\n\}\n\n\n\n//\n// Camera Utilities\n//\n\n\n/**\n * Compute the field of view from focal length.\n *\n * @arg focalLength: The focal length.\n *\n * @returns: The equivalent field of view.\n */\ninline float fieldOfView(const float focalLength)\n\{\n    return 2 * atan(1 / focalLength);\n\}\n\n\n/**\n * Compute the aspect ratio from image format.\n *\n * @arg height_: The height of the image.\n * @arg width_: The width of the image.\n *\n * @returns: The aspect ratio.\n */\ninline float aspectRatio(const float height_, const float width_)\n\{\n    return height_ / width_;\n\}\n\n\n/**\n *\n */\ninline float fStopToAperture(const float fStop, const float focalLength)\n\{\n    return focalLength / fStop / 1000.0f;\n\}\n\n\n/**\n * Create a projection matrix for a camera.\n *\n * @arg focalLength: The focal length of the camera.\n * @arg horizontalAperture: The horizontal aperture of the camera.\n * @arg aspect: The aspect ratio of the camera.\n * @arg nearPlane: The distance to the near plane of the camera.\n * @arg farPlane: The distance to the far plane of the camera.\n *\n * @returns: The camera's projection matrix.\n */\nfloat4x4 projectionMatrix(\n        const float focalLength,\n        const float horizontalAperture,\n        const float aspect,\n        const float nearPlane,\n        const float farPlane)\n\{\n    float farMinusNear = farPlane - nearPlane;\n    return float4x4(\n        2 * focalLength / horizontalAperture, 0, 0, 0,\n        0, 2 * focalLength / horizontalAperture / aspect, 0, 0,\n        0, 0, -(farPlane + nearPlane) / farMinusNear, -2 * (farPlane * nearPlane) / farMinusNear,\n        0, 0, -1, 0\n    );\n\}\n\n\n/**\n * Generate a ray out of a camera.\n *\n * @arg cameraWorldMatrix: The camera matrix.\n * @arg inverseProjectionMatrix: The inverse of the projection matrix.\n * @arg uvPosition: The UV position in the resulting image.\n * @arg rayOrigin: Will store the origin of the ray.\n * @arg rayDirection: Will store the direction of the ray.\n */\nvoid createCameraRay(\n        const float4x4 &cameraWorldMatrix,\n        const float4x4 &inverseProjectionMatrix,\n        const float2 &uvPosition,\n        float3 &rayOrigin,\n        float3 &rayDirection)\n\{\n    positionFromWorldMatrix(cameraWorldMatrix, rayOrigin);\n    float4 direction = matmul(\n        inverseProjectionMatrix,\n        float4(uvPosition.x, uvPosition.y, 0, 1)\n    );\n    matmul(\n        cameraWorldMatrix,\n        float4(direction.x, direction.y, direction.z, 0),\n        direction\n    );\n    rayDirection = normalize(float3(direction.x, direction.y, direction.z));\n\}\n\n\n/**\n * Generate a ray out of a camera.\n *\n * @arg cameraWorldMatrix: The camera matrix.\n * @arg inverseProjectionMatrix: The inverse of the projection matrix.\n * @arg uvPosition: The UV position in the resulting image.\n * @arg rayOrigin: Will store the origin of the ray.\n * @arg rayDirection: Will store the direction of the ray.\n */\nvoid createCameraRay(\n        const float4x4 &cameraWorldMatrix,\n        const float4x4 &inverseProjectionMatrix,\n        const float2 &uvPosition,\n        const float aperture,\n        const float focalDistance,\n        const float3 &seed,\n        float3 &rayOrigin,\n        float3 &rayDirection)\n\{\n    createCameraRay(\n        cameraWorldMatrix,\n        inverseProjectionMatrix,\n        uvPosition,\n        rayOrigin,\n        rayDirection\n    );\n\n    const float4 cameraForward4 = matmul(\n        cameraWorldMatrix,\n        float4(0, 0, -1, 0)\n    );\n    const float3 cameraForward = float3(\n        cameraForward4.x,\n        cameraForward4.y,\n        cameraForward4.z\n    );\n    const float4 cameraRight4 = matmul(\n        cameraWorldMatrix,\n        float4(1, 0, 0, 0)\n    );\n    const float3 cameraRight = float3(\n        cameraRight4.x,\n        cameraRight4.y,\n        cameraRight4.z\n    );\n    const float4 cameraUp4 = matmul(\n        cameraWorldMatrix,\n        float4(0, 1, 0, 0)\n    );\n    const float3 cameraUp = float3(\n        cameraUp4.x,\n        cameraUp4.y,\n        cameraUp4.z\n    );\n\n    const float3 focalPlanePoint = rayOrigin + cameraForward * focalDistance;\n    const float3 focalPlaneNormal = -cameraForward;\n\n    const float focalPointDistance = (\n        (dot(focalPlaneNormal, focalPlanePoint) - dot(rayOrigin, focalPlaneNormal))\n        / dot(rayDirection, focalPlaneNormal)\n    );\n    const float3 focalPoint = rayOrigin + focalPointDistance * rayDirection;\n\n    const float2 pointInUnitCircle = uniformPointInUnitCircle(seed);\n    const float2 offset = pointInUnitCircle.x * aperture * float2(\n        cos(pointInUnitCircle.y),\n        sin(pointInUnitCircle.y)\n    );\n\n    rayOrigin += cameraRight * offset.x + cameraUp * offset.y;\n    rayDirection = normalize(focalPoint - rayOrigin);\n\}\n\n\n/**\n * Generate a LatLong ray out of a camera.\n *\n * @arg cameraWorldMatrix: The camera matrix.\n * @arg uvPosition: The UV position in the resulting image.\n * @arg rayOrigin: Will store the origin of the ray.\n * @arg rayDirection: Will store the direction of the ray.\n */\nvoid createLatLongCameraRay(\n        const float4x4 &cameraWorldMatrix,\n        const float2 &uvPosition,\n        float3 &rayOrigin,\n        float3 &rayDirection)\n\{\n    positionFromWorldMatrix(cameraWorldMatrix, rayOrigin);\n    rayDirection = sphericalUnitVectorToCartesion(uvPositionToAngles(uvPosition));\n\n    float3x3 cameraRotation;\n    rotationFromWorldMatrix(cameraWorldMatrix, cameraRotation);\n    rayDirection = matmul(cameraRotation, rayDirection);\n\}\n\n\n\nkernel FogKernel : ImageComputationKernel<ePixelWise>\n\{\n    // the input which specifies the format, process is called once per pixel\n    // in this image, which also provides random seeds\n    Image<eRead, eAccessPoint, eEdgeNone> noise;\n    Image<eRead, eAccessPoint, eEdgeNone> depth;\n\n    // the hdri in latlong format\n    Image<eRead, eAccessRandom, eEdgeNone> hdri;\n\n    // noise options.x translation.yzw\n    Image<eRead, eAccessRandom, eEdgeNone> noiseParams0;\n\n    // octaves.x, lacunarity.y, gain.z, gamma.w\n    Image<eRead, eAccessRandom, eEdgeNone> noiseParams1;\n    // size.x\n    Image<eRead, eAccessRandom, eEdgeNone> noiseParams2;\n    Image<eRead, eAccessRandom, eEdgeNone> noiseParams3;\n    Image<eRead, eAccessRandom, eEdgeNone> noiseParams4;\n    Image<eRead, eAccessRandom, eEdgeNone> noiseParams5;\n    Image<eRead, eAccessRandom, eEdgeNone> noiseParams6;\n\n    // the input lights direction/position.xyz intensity.w\n    Image<eRead, eAccessRandom, eEdgeNone> lights;\n\n    // colour.xyz, type.w\n    // w in \[0, 1) = directional, \[1, inf) = point\n    Image<eRead, eAccessRandom, eEdgeNone> lightProperties;\n\n    // shadow hardness.x\n    Image<eRead, eAccessRandom, eEdgeNone> lightProperties1;\n\n    // the precomputed irradiance of the hdri\n    Image<eRead, eAccessRandom, eEdgeClamped> irradiance;\n\n\n    // the output image\n    Image<eWrite> dst;\n\n\n    param:\n        // These parameters are made available to the user.\n\n        // Camera params\n        float _focalLength;\n        float _horizontalAperture;\n        float _nearPlane;\n        float _farPlane;\n        float4x4 _cameraWorldMatrix;\n        float _focalDistance;\n        float _fStop;\n        bool _depthOfFieldEnabled;\n\n        // Image params\n        float _formatWidth;\n        float _formatHeight;\n\n        float _hdriOffsetAngle;\n        bool _usePrecomputedIrradiance;\n\n        // Ray params\n        int _pathsPerPixel;\n        bool _sampleHDRI;\n        float _hitTolerance;\n        float _maxBrightness;\n\n        // Scene params\n        float4 _scatteringCoefficient;\n        float4 _extinctionCoefficient;\n        int _equiangularSamples;\n\n        // Shape Textures\n        int _lightTextureWidth;\n\n        bool _latLong;\n\n\n    local:\n        // These local variables are not exposed to the user.\n\n        float4x4 __inverseCameraProjectionMatrix;\n        float __aperture;\n\n        float2 __hdriPixelSize;\n        float2 __irradiancePixelSize;\n        float __hdriOffsetRadians;\n\n        float3 __offset0;\n        float3 __offset1;\n        float3 __offset2;\n        float3 __offset3;\n\n        int __simplex\[64]\[4];\n        int __perm\[512];\n        int __grad4\[32]\[4];\n\n    /**\n     * Give the parameters labels and default values.\n     */\n    void define()\n    \{\n        // Camera params\n        defineParam(_focalLength, \"Focal Length\", 50.0f);\n        defineParam(_horizontalAperture, \"Horizontal Aperture\", 24.576f);\n        defineParam(_nearPlane, \"Near Plane\", 0.1f);\n        defineParam(_farPlane, \"Far Plane\", 10000.0f);\n        defineParam(\n            _cameraWorldMatrix,\n            \"Camera World Matrix\",\n            float4x4(\n                1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1\n            )\n        );\n        defineParam(_focalDistance, \"Focal Distance\", 4.0f);\n        defineParam(_fStop, \"fstop\", 16.0f);\n        defineParam(_depthOfFieldEnabled, \"Enable Depth Of Field\", true);\n\n        // Image params\n        defineParam(_formatHeight, \"Screen Height\", 2160.0f);\n        defineParam(_formatWidth, \"Screen Width\", 3840.0f);\n        defineParam(_hdriOffsetAngle, \"HDRI Offset Angle\", 0.0f);\n        defineParam(_usePrecomputedIrradiance, \"Use Precomputed Irradiance\", true);\n\n        // Ray params\n        defineParam(_pathsPerPixel, \"Paths Per Pixel\", 1);\n        defineParam(_sampleHDRI, \"Sample HDRI\", true);\n        defineParam(_hitTolerance, \"Hit Tolerance\", 0.001f);\n        defineParam(_maxBrightness, \"Maximum Brightness\", 999999.9f);\n\n        // Scene params\n        defineParam(_scatteringCoefficient, \"Scattering Coefficient\", float4(0));\n        defineParam(_extinctionCoefficient, \"Extinction Coefficient\", float4(1));\n        defineParam(_equiangularSamples, \"Equi-Angular Samples\", 5);\n\n        // Shape Counts\n        defineParam(_lightTextureWidth, \"Light Texture Width\", 0);\n\n        defineParam(_latLong, \"Output LatLong\", false);\n    \}\n\n\n    /**\n     * Initialize the local variables.\n     */\n    void init()\n    \{\n        const float aspect = aspectRatio(_formatHeight, _formatWidth);\n        float4x4 cameraProjectionMatrix = projectionMatrix(\n            _focalLength,\n            _horizontalAperture,\n            aspect,\n            _nearPlane,\n            _farPlane\n        );\n        __inverseCameraProjectionMatrix = cameraProjectionMatrix.invert();\n\n        __aperture = fStopToAperture(_fStop, _focalLength);\n\n        __hdriPixelSize = float2(\n            hdri.bounds.width() / (2 * PI),\n            hdri.bounds.height() / PI\n        );\n        __irradiancePixelSize = float2(\n            irradiance.bounds.width() / (2 * PI),\n            irradiance.bounds.height() / PI\n        );\n        __hdriOffsetRadians = degreesToRadians(_hdriOffsetAngle);\n\n        __offset0 = 0.5773f * float3(1, -1, -1);\n        __offset1 = 0.5773f * float3(-1, -1, 1);\n        __offset2 = 0.5773f * float3(-1, 1, -1);\n        __offset3 = 0.5773f * float3(1, 1, 1);\n\n        const int simplexInit\[64]\[4] = \{\n            \{0, 1, 2, 3\}, \{0, 1, 3, 2\}, \{0, 0, 0, 0\}, \{0, 2, 3, 1\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{1, 2, 3, 0\},\n            \{0, 2, 1, 3\}, \{0, 0, 0, 0\}, \{0, 3, 1, 2\}, \{0, 3, 2, 1\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{1, 3, 2, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{1, 2, 0, 3\}, \{0, 0, 0, 0\}, \{1, 3, 0, 2\}, \{0, 0, 0, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{2, 3, 0, 1\}, \{2, 3, 1, 0\},\n            \{1, 0, 2, 3\}, \{1, 0, 3, 2\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{0, 0, 0, 0\}, \{2, 0, 3, 1\}, \{0, 0, 0, 0\}, \{2, 1, 3, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{2, 0, 1, 3\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{3, 0, 1, 2\}, \{3, 0, 2, 1\}, \{0, 0, 0, 0\}, \{3, 1, 2, 0\},\n            \{2, 1, 0, 3\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{3, 1, 0, 2\}, \{0, 0, 0, 0\}, \{3, 2, 0, 1\}, \{3, 2, 1, 0\}\n        \};\n\n        for (int i = 0; i < 64; i++)\n        \{\n            for (int j = 0; j < 4; j++)\n            \{\n                __simplex\[i]\[j] = simplexInit\[i]\[j];\n            \}\n        \}\n\n        const int permInit\[256] = \{\n            151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233,\n            7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23,\n            190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219,\n            203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174,\n            20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48,\n            27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133,\n            230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65,\n            25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18,\n            169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198,\n            173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147,\n            118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17,\n            182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44,\n            154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22,\n            39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112,\n            104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12,\n            191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49,\n            192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121,\n            50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29,\n            24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180\n        \};\n\n        for (int i = 0; i < 512; i++)\n        \{\n            __perm\[i] = permInit\[i % 256];\n        \}\n\n        const int grad4Init\[32]\[4]= \{\n            \{0, 1, 1, 1\},  \{0, 1, 1, -1\},  \{0, 1, -1, 1\},  \{0, 1, -1, -1\},\n            \{0, -1, 1, 1\}, \{0, -1, 1, -1\}, \{0, -1, -1, 1\}, \{0, -1, -1, -1\},\n            \{1, 0, 1, 1\},  \{1, 0, 1, -1\},  \{1, 0, -1, 1\},  \{1, 0, -1, -1\},\n            \{-1, 0, 1, 1\}, \{-1, 0, 1, -1\}, \{-1, 0, -1, 1\}, \{-1, 0, -1, -1\},\n            \{1, 1, 0, 1\},  \{1, 1, 0, -1\},  \{1, -1, 0, 1\},  \{1, -1, 0, -1\},\n            \{-1, 1, 0, 1\}, \{-1, 1, 0, -1\}, \{-1, -1, 0, 1\}, \{-1, -1, 0, -1\},\n            \{1, 1, 1, 0\},  \{1, 1, -1, 0\},  \{1, -1, 1, 0\},  \{1, -1, -1, 0\},\n            \{-1, 1, 1, 0\}, \{-1, 1, -1, 0\}, \{-1, -1, 1, 0\}, \{-1, -1, -1, 0\}\n        \};\n\n        for (int i = 0; i < 32; i++)\n        \{\n            for (int j = 0; j < 4; j++)\n            \{\n                __grad4\[i]\[j] = grad4Init\[i]\[j];\n            \}\n        \}\n    \}\n\n\n    /**\n     * Get the noise value at a position.\n     *\n     * @arg index: The index of the noise.\n     * @arg position: The position at which we want the noise.\n     * @arg noiseOptions: The noise modifier options.\n     *\n     * @returns: The noise value.\n     */\n    float getNoiseValue(const float3 &position, int &noiseOptions)\n    \{\n        // Make sure there is a noise node plugged into the object.\n        noiseOptions = (int) noiseParams0(0, 0, 0);\n        const float size = noiseParams2(0, 0, 0);\n        if ((noiseOptions & NOISE_ENABLED) == 0 || size == 0.0f)\n        \{\n            return -1.0f;\n        \}\n        // TODO make all these knobs on main node\n        // Read the noise parameters\n        const float3 translation = float3(\n            noiseParams0(0, 0, 1),\n            noiseParams0(0, 0, 2),\n            noiseParams0(0, 0, 3)\n        );\n        const int octaves = noiseParams1(0, 0, 0);\n        const float lacunarity = noiseParams1(0, 0, 1);\n        const float gain = noiseParams1(0, 0, 2);\n        const float gamma = noiseParams1(0, 0, 3);\n        const float4 lowFrequency = noiseParams3(0, 0);\n        const float4 highFrequency = noiseParams4(0, 0);\n        const float4 lowFrequencyEvolution = noiseParams5(0, 0);\n        const float4 highFrequencyEvolution = noiseParams6(0, 0);\n\n        // Translate the noise, and convert the position to the local\n        // coordinate system\n        float3 noisePosition = position + translation;\n\n        // Get the noise value based on which type of noise we are using\n        const float4 noisePosition4d = float4(\n            noisePosition.x,\n            noisePosition.y,\n            noisePosition.z,\n            0.0f\n        );\n        float noiseValue;\n        if (noiseOptions & FBM_NOISE)\n        \{\n            noiseValue = fractalBrownianMotionNoise(\n                octaves,\n                lacunarity,\n                size,\n                gain,\n                gamma,\n                noisePosition4d,\n                lowFrequency,\n                highFrequency,\n                lowFrequencyEvolution,\n                highFrequencyEvolution,\n                __simplex,\n                __perm,\n                __grad4\n            );\n        \}\n        else\n        \{\n            noiseValue = turbulenceNoise(\n                octaves,\n                lacunarity,\n                size,\n                gain,\n                gamma,\n                noisePosition4d,\n                lowFrequency,\n                highFrequency,\n                lowFrequencyEvolution,\n                highFrequencyEvolution,\n                __simplex,\n                __perm,\n                __grad4\n            );\n        \}\n\n        // TODO and these\n        // Modify the noise using the grade parameters\n        const float whitePoint = noiseParams2(0, 0, 1);\n        const float blackPoint = noiseParams2(0, 0, 2);\n        const float lift = noiseParams2(0, 0, 3);\n\n        if (whitePoint != blackPoint)\n        \{\n            noiseValue = saturate((noiseValue - blackPoint) / (whitePoint - blackPoint));\n        \}\n\n        noiseValue = saturate(noiseValue * (1.0f - lift) + lift);\n\n        if (noiseOptions & INVERT_NOISE)\n        \{\n            noiseValue = 1.0f - noiseValue;\n        \}\n\n        return noiseValue;\n    \}\n\n\n    /**\n     * Get the value of hdri the ray would hit at infinite distance\n     *\n     * @arg rayDirection: The direction of the ray.\n     *\n     * @returns: The colour of the pixel in the direction of the ray.\n     */\n    float4 readHDRIValue(float3 rayDirection)\n    \{\n        const float2 angles = cartesionUnitVectorToSpherical(rayDirection, __hdriOffsetRadians);\n\n        // Should be able to say image access is eEdgeClamped and not do this\n        // but I see nan pixels sooo... :(\n        const float2 indices = clamp(\n            float2(\n                __hdriPixelSize.x * angles.x,\n                hdri.bounds.height() - (__hdriPixelSize.y * angles.y)\n            ),\n            float2(0),\n            float2(hdri.bounds.width(), hdri.bounds.height()) - 1.0f\n        );\n\n        return bilinear(hdri, indices.x, indices.y);\n    \}\n\n\n    /**\n     * Get the value of irradiance the hdri would provide in a direction\n     *\n     * @arg rayDirection: The direction of the ray.\n     *\n     * @returns: The colour of the pixel in the direction of the ray.\n     */\n    inline float4 readIrradianceValue(float3 rayDirection)\n    \{\n        const float2 angles = cartesionUnitVectorToSpherical(rayDirection, __hdriOffsetRadians);\n\n        // Should be able to say image access is eEdgeClamped and not do this\n        // but I see nan pixels sooo... :(\n        const float2 indices = clamp(\n            float2(\n                __irradiancePixelSize.x * angles.x,\n                irradiance.bounds.height() - (__irradiancePixelSize.y * angles.y)\n            ),\n            float2(0),\n            float2(irradiance.bounds.width(), irradiance.bounds.height()) - 1.0f\n        );\n\n        return bilinear(irradiance, indices.x, indices.y);\n    \}\n\n\n    /**\n     * Estimate the surface normal at the closest point on the closest\n     * object to a point\n     *\n     * @arg point: The point near which to get the surface normal\n     * @arg pixelFootprint: A value proportional to the amount of world\n     *     space that fills a pixel, like the distance from camera.\n     *\n     * @returns: The normalized surface normal.\n     */\n    float3 estimateSurfaceNormal(const float3 &point)\n    \{\n        int noiseOptions;\n        return normalize(\n            __offset0 * getNoiseValue(\n                point + __offset0 * _hitTolerance,\n                noiseOptions\n            )\n            + __offset1 * getNoiseValue(\n                point + __offset1 * _hitTolerance,\n                noiseOptions\n            )\n            + __offset2 * getNoiseValue(\n                point + __offset2 * _hitTolerance,\n                noiseOptions\n            )\n            + __offset3 * getNoiseValue(\n                point + __offset3 * _hitTolerance,\n                noiseOptions\n            )\n        );\n    \}\n\n\n    /**\n     * Sample the data of a particular artificial light in the scene.\n     * Artificial lights are any that are passed into the 'lights'\n     * input.\n     *\n     * @arg position: The position on the surface to sample the data of.\n     * @arg lightIndex: The index of the chosen light in the lights\n     *     texture.\n     * @arg numLights: The number of lights in the scene.\n     * @arg lightDirection: The direction from the surface to the light.\n     * @arg distanceToLight: The distance to the light's surface.\n     *\n     * @returns: The PDF of the light.\n     */\n    float sampleArtificialLightData(\n            const float3 &position,\n            const int lightIndex,\n            const int numLights,\n            float3 &lightDirection,\n            float &distanceToLight)\n    \{\n        float visibleSurfaceArea = 1.0f;\n\n        // Selected a 'fake' light eg. point, directional, ambient\n        SampleType(lights) light = lights(lightIndex, 0);\n        const int lightType = abs((int) lightProperties(lightIndex, 0, 3));\n\n        if (lightType > 1)\n        \{\n            getLightData(\n                position,\n                float3(light.x, light.y, light.z),\n                lightType,\n                distanceToLight,\n                visibleSurfaceArea,\n                lightDirection\n            );\n        \}\n\n        return sampleLightsPDF(max(1, numLights), visibleSurfaceArea);\n    \}\n\n\n    /**\n     * Perform direct illumination light sampling on a chosen artificial\n     * light in the scene.\n     *\n     * @arg pointOnSurface: The point on the surface to compute the\n     *     light intensity at.\n     * @arg surfaceNormal: The normal to the surface at the position we\n     *     are sampling the illumination of.\n     * @arg lightDirection: The direction from the surface to the light.\n     * @arg distanceToLight: The distance to the light's surface.\n     * @arg selectedLight: The index of the chosen light to sample.\n     *\n     * @returns: The colour of the sampled light.\n     */\n    inline float4 sampleArtificialLight(\n            const float3 &pointOnSurface,\n            const float3 &surfaceNormal,\n            const float3 &lightDirection,\n            const float distanceToLight,\n            const int selectedLight)\n    \{\n        // Read the light properties\n        SampleType(lights) light = lights(selectedLight, 0);\n        SampleType(lightProperties) lightProperty = lightProperties(selectedLight, 0);\n        SampleType(lightProperties1) lightProperty1 = lightProperties1(selectedLight, 0);\n\n        float intensity;\n\n        int lightType = (int) lightProperty.w;\n        int absLightType = abs(lightType);\n\n        if (absLightType == AMBIENT_LIGHT)\n        \{\n            // Ambient light, simply return the intensity.\n            intensity = light.w;\n        \}\n        else\n        \{\n            intensity = lightIntensity(\n                light.w,\n                lightProperty1.y,\n                distanceToLight\n            );\n        \}\n\n        return intensity * float4(\n            lightProperty.x,\n            lightProperty.y,\n            lightProperty.z,\n            0\n        );\n    \}\n\n\n    /**\n     * Perform equi-angular sampling for participating media.\n     *\n     * @arg seed: The seed to use in randomization.\n     * @arg intersectionPosition: The position at which the ray\n     *     intersects the geometry.\n     * @arg rayOrigin: The ray origin.\n     * @arg rayDirection: The incoming ray direction.\n     * @arg distance: The distance travelled since the\n     *     last bounce.\n     * @arg emissiveIndices: The indices of the emissive objects in the\n     *     scene.\n     * @arg nestedDielectrics: The stack of dielectrics that we have\n     *     entered without exiting.\n     * @arg numNestedDielectrics: The number of dielectrics in the\n     *     stack.\n     * @arg throughput: The throughput of the ray.\n     *\n     * @returns: The colour of the ray.\n     */\n    float4 sampleEquiangular(\n            const float3 &seed,\n            const float3 &intersectionPosition,\n            const float3 &rayOrigin,\n            const float3 &rayDirection,\n            const float distance,\n            float4 &throughput)\n    \{\n        float4 scatteredColour = float4(0);\n\n        if (\n            length(_scatteringCoefficient) <= 0.0f\n            && length(_extinctionCoefficient) <= 0.0f\n        ) \{\n            throughput *= exp(-_extinctionCoefficient * distance);\n            return scatteredColour;\n        \}\n\n        for (int lightIndex=0; lightIndex < _lightTextureWidth; lightIndex++)\n        \{\n            float3 lightDirection = float3(0.0f, 1.0f, 0.0f);\n            float distanceToLight = 0.0f;\n            int selectedLight;\n            const float lightPDF = sampleArtificialLightData(\n                intersectionPosition,\n                lightIndex,\n                _lightTextureWidth,\n                lightDirection,\n                distanceToLight\n            );\n\n            const float3 lightPosition = intersectionPosition + lightDirection * distanceToLight;\n\n            const float offset = random(random(seed.z) + random(seed.y + random(seed.x)));\n\n            float extinctionNoiseSum = 0.0f;\n\n            for (int step=1; step <= _equiangularSamples; step++)\n            \{\n                const float uniform = (step + offset - 1) / (float) _equiangularSamples;\n\n                float equiangularDistance;\n                float equiangularPDF = _equiangularSamples * sampleEquiangularPDF(\n                    uniform,\n                    distance,\n                    rayOrigin,\n                    rayDirection,\n                    lightPosition,\n                    equiangularDistance\n                );\n\n                const float3 particlePosition = rayOrigin + equiangularDistance * rayDirection;\n                const float3 surfaceNormal = randomUnitVector(particlePosition);\n                const float geometryFactor = saturate(dot(lightDirection, surfaceNormal));\n                const float3 particleToLight = lightPosition - particlePosition;\n                distanceToLight = length(particleToLight);\n\n                if (distanceToLight > 0.0f)\n                \{\n                    lightDirection = normalize(particleToLight);\n                \}\n\n                int noiseOptions;\n                float noiseValue = getNoiseValue(particlePosition, noiseOptions);\n                float scatteringNoise = noiseValue;\n                float extinctionNoise = noiseValue;\n                if (noiseValue < 0.0f || !(noiseOptions & SCATTERING_NOISE))\n                \{\n                    scatteringNoise = 1.0f;\n                \}\n                if (noiseValue < 0.0f || !(noiseOptions & EXTINCTION_NOISE))\n                \{\n                    extinctionNoise = 1.0f;\n                \}\n\n                extinctionNoiseSum += extinctionNoise;\n\n                const float4 lightBRDF = exp(\n                    -_extinctionCoefficient\n                    * extinctionNoise\n                    * (distanceToLight + equiangularDistance)\n                );\n\n                scatteredColour += (\n                    _scatteringCoefficient\n                    * scatteringNoise\n                    * throughput\n                    * lightBRDF\n                    * geometryFactor\n                    * sampleArtificialLight(\n                        particlePosition,\n                        surfaceNormal,\n                        lightDirection,\n                        distanceToLight,\n                        lightIndex\n                    ) / lightPDF\n                );\n            \}\n\n            throughput *= exp(\n                -_extinctionCoefficient\n                * extinctionNoiseSum\n                * distance\n                / (float) _equiangularSamples\n            ) / lightPDF;\n        \}\n\n        return scatteredColour;\n    \}\n\n\n    /**\n     * Perform equi-angular sampling for participating media.\n     *\n     * @arg seed: The seed to use in randomization.\n     * @arg intersectionPosition: The position at which the ray\n     *     intersects the geometry.\n     * @arg rayOrigin: The ray origin.\n     * @arg rayDirection: The incoming ray direction.\n     * @arg distance: The distance travelled since the\n     *     last bounce.\n     * @arg emissiveIndices: The indices of the emissive objects in the\n     *     scene.\n     * @arg nestedDielectrics: The stack of dielectrics that we have\n     *     entered without exiting.\n     * @arg numNestedDielectrics: The number of dielectrics in the\n     *     stack.\n     * @arg throughput: The throughput of the ray.\n     *\n     * @returns: The colour of the ray.\n     */\n    float4 sampleNoise(\n            const float3 &seed,\n            const float3 &rayOrigin,\n            const float3 &rayDirection,\n            const float distance,\n            float4 &throughput)\n    \{\n        float noiseSum = 0.0f;\n        float invertedLastSample = 1.0f;\n        for (int step=1; step <= _equiangularSamples; step++)\n        \{\n            const float uniform = distance * (float) step / (float) _equiangularSamples;\n            const float3 particlePosition = rayOrigin + uniform * rayDirection;\n\n            int noiseOptions;\n            float noiseValue = getNoiseValue(particlePosition, noiseOptions) * _hitTolerance;\n            noiseSum += noiseValue * invertedLastSample;\n\n            invertedLastSample *= 1.0f - noiseValue;\n        \}\n\n        return float4(noiseSum, noiseSum, noiseSum, noiseSum);\n    \}\n\n\n    /**\n     * Create a ray out of the camera. It will be either a standard ray,\n     * a latlong ray, or a ray that will result in depth of field.\n     *\n     * @arg seed: The seed to use in randomization.\n     * @arg pixelLocation: The x, and y locations of the pixel.\n     * @arg rayOrigin: The location to store the origin of the new ray.\n     * @arg rayDirection: The location to store the direction of the new\n     *     ray.\n     */\n    void getCameraRay(\n            const float3 &seed,\n            const float2 &pixelLocation,\n            float3 &rayOrigin,\n            float3 &rayDirection)\n    \{\n        const float2 uvCoordinates = pixelsToUV(\n            pixelLocation + random(float2(seed.x, seed.y)),\n            float2(_formatWidth, _formatHeight)\n        );\n        if (_latLong)\n        \{\n            createLatLongCameraRay(\n                _cameraWorldMatrix,\n                uvCoordinates,\n                rayOrigin,\n                rayDirection\n            );\n        \}\n        else if (_depthOfFieldEnabled)\n        \{\n            createCameraRay(\n                _cameraWorldMatrix,\n                __inverseCameraProjectionMatrix,\n                uvCoordinates,\n                __aperture,\n                _focalDistance,\n                seed,\n                rayOrigin,\n                rayDirection\n            );\n        \}\n        else\n        \{\n            createCameraRay(\n                _cameraWorldMatrix,\n                __inverseCameraProjectionMatrix,\n                uvCoordinates,\n                rayOrigin,\n                rayDirection\n            );\n        \}\n    \}\n\n\n    /**\n     * Compute a raymarched pixel value.\n     *\n     * @arg pos: The x, and y location we are currently processing.\n     */\n    void process(int2 pos)\n    \{\n        SampleType(noise) noisePixel = noise();\n        float3 seed = random(float3(noisePixel.x, noisePixel.y, noisePixel.z));\n\n        float4 resultPixel = float4(0.0f);\n\n        float2 pixelLocation = float2(pos.x, pos.y);\n\n        const float ray_depth = depth(0);\n\n        for (int path=1; path <= _pathsPerPixel; path++)\n        \{\n            // Generate a ray from the camera\n            float3 rayOrigin;\n            float3 rayDirection;\n            getCameraRay(\n                seed,\n                pixelLocation,\n                rayOrigin,\n                rayDirection\n            );\n\n            float4 throughput = float4(1);\n\n            // Perform Equi-Angular Sampling\n            resultPixel += sampleNoise(\n                seed,\n                rayOrigin + ray_depth * rayDirection,\n                rayDirection,\n                ray_depth,\n                throughput\n            );\n\n            // Read the hdri value in the direction the ray was last travelling\n            resultPixel += throughput * readHDRIValue(rayDirection);\n\n            seed = RAND_CONST_10 * random(seed * path * RAND_CONST_11);\n        \}\n\n        dst() = resultPixel / float(_pathsPerPixel);\n    \}\n\};\n"
  rebuild ""
  "FogKernel_Focal Length" {{parent.DummyCam.focal}}
  "FogKernel_Horizontal Aperture" {{parent.DummyCam.haperture}}
  "FogKernel_Near Plane" {{parent.DummyCam.near}}
  "FogKernel_Far Plane" {{parent.DummyCam.far}}
  "FogKernel_Camera World Matrix" {
      {{parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix}}
      {{parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix}}
      {{parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix}}
      {{parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix}}
    }
  "FogKernel_Focal Distance" {{parent.DummyCam.focal_point}}
  FogKernel_fstop {{parent.DummyCam.fstop}}
  "FogKernel_Enable Depth Of Field" {{parent.enable_dof}}
  "FogKernel_Screen Width" {{input0.width}}
  "FogKernel_Screen Height" {{input0.height}}
  "FogKernel_HDRI Offset Angle" {{parent.hdri_offset_angle}}
  "FogKernel_Use Precomputed Irradiance" {{parent.use_precomputed_irradiance}}
  "FogKernel_Paths Per Pixel" {{parent.paths_per_pixel}}
  "FogKernel_Sample HDRI" {{parent.sample_hdri_equiangular}}
  "FogKernel_Hit Tolerance" {{parent.hit_tolerance}}
  "FogKernel_Maximum Brightness" {{parent.max_brightness}}
  "FogKernel_Scattering Coefficient" {{"parent.scattering_colour * parent.scattering_coefficient"}}
  "FogKernel_Extinction Coefficient" {{"parent.extinction_colour * parent.extinction_coefficient"}}
  "FogKernel_Equi-Angular Samples" {{parent.equiangular_samples}}
  "FogKernel_Light Texture Width" {{"parent.light_input_protection.disable ? parent.light_dot.width : parent.lights.width == 1 ? 1 : 0"}}
  "FogKernel_Output LatLong" {{parent.latlong}}
  rebuild_finalise ""
  name BlinkScript1
  selected true
  xpos 1610
  ypos -469
 }
 Reformat {
  format {{{parent.format_.format}}}
  name Reformat1
  xpos 1610
  ypos -431
 }
 Expression {
  expr0 "isnan(r) ? 0 : (isinf(r) ? parent.max_brightness : clamp(r, -parent.max_brightness, parent.max_brightness))"
  expr1 "isnan(g) ? 0 : (isinf(g) ? parent.max_brightness : clamp(g, -parent.max_brightness, parent.max_brightness))"
  expr2 "isnan(b) ? 0 : (isinf(b) ? parent.max_brightness : clamp(b, -parent.max_brightness, parent.max_brightness))"
  name Expression1
  xpos 1610
  ypos -405
 }
 Output {
  name Output1
  xpos 1610
  ypos -340
 }
 Input {
  inputs 0
  name camera
  xpos 1390
  ypos -1591
  number 3
 }
 Camera {
  projection_mode {{"\[expression \[value the_cam]projection_mode(\[value the_frame])]"}}
  focal {{"\[expression \[value the_cam]focal(\[value the_frame])]"}}
  haperture {{"\[expression \[value the_cam]haperture(\[value the_frame])]"}}
  vaperture {{"\[expression \[value the_cam]vaperture(\[value the_frame])]"}}
  near {{"\[expression \[value the_cam]near(\[value the_frame])]"}}
  far {{"\[expression \[value the_cam]far(\[value the_frame])]"}}
  win_translate {{"\[expression \[value the_cam]win_translate.u(\[value the_frame])]"} {"\[expression \[value the_cam]win_translate.v(\[value the_frame])]"}}
  win_scale {{"\[expression \[value the_cam]win_scale.u(\[value the_frame])]"} {"\[expression \[value the_cam]win_scale.v(\[value the_frame])]"}}
  winroll {{"\[expression \[value the_cam]winroll(\[value the_frame])]"}}
  focal_point {{"\[expression \[value the_cam]focal_point(\[value the_frame])]"}}
  fstop {{"\[expression \[value the_cam]fstop(\[value the_frame])]"}}
  name DummyCam
  help "DummyCam by Adrian Pueyo\n\nCamera that apart from the matrices also grabs all the \"Projection\" values from the upstream camera that it's connected to. Turns into a default Camera if no Camera connected. Can also be used inside of groups and gizmos, as many levels deep as you want :D All using live and super fast TCL.\n\nUpdated v1.1: Now grabs the correct frame too (thanks Erwan Leroy for the idea).\n\nUpdated v1.3: Now accepts Nuke13's Camera3\n\nadrianpueyo.com, 2019-2021"
  onCreate "n = nuke.thisNode()\nfor k in \[\"projection_mode\",\"focal\",\"haperture\",\"vaperture\",\"near\",\"far\",\"win_translate\",\"win_scale\",\"winroll\",\"focal_point\",\"fstop\"]:\n    n\[k].setFlag(0x0000000010000000)"
  xpos 1400
  ypos -1471
  addUserKnob {20 DummyCam l Defaults}
  addUserKnob {43 the_cam +INVISIBLE}
  the_cam "\[\n#DummyCam v1.3 - Updated 5 May 2021.\nset starting_point \"this.input0\"\nset default \"this.d_\"\n\n# If cam has no inputs, return the default.\nif \{\[exists \$starting_point]\} \{\n    set x \[node \$starting_point]\n\} \{ \n    return \$default\n\}\n\nset finished 0\nwhile \{\$finished != 1\} \{\n\n    # First look for a Cam or Input or topnode.\n    while \{\[class \$x] != \"Camera3\" && \[class \$x] != \"Camera2\" && \[class \$x] != \"Camera\" && \[class \$x] != \"Input\" && \$x != \[topnode \$x]\} \{\n        set x \[node \$x.input0]\n    \}\n\n    # Then, check if node is a cam (and return), and otherwise, if it's an input, see if the parent exists and move to it.\n    if \{\[class \$x]==\"Camera3\"||\[class \$x]==\"Camera2\"||\[class \$x]==\"Camera\"\} \{\n        set x \[append x \".\"]\n        return \$x\n    \} \{ \n        if \{ \[class \$x]==\"Input\" \} \{ \n            set inp \"\$x.parent.input\"\n            set inputNum \[value \$x.number]\n            set inp \[append inp \$inputNum]\n            if \{ \[exists \$inp] \} \{\n                set x \[node \$inp]\n            \} \{ \n                set finished 1\n            \}\n        \} \{ \n            set finished 1\n        \}\n    \}\n\}\nreturn \$default\n]"
  addUserKnob {43 the_frame +INVISIBLE}
  the_frame "\[\nset the_camera \[string trimright \[value the_cam] .]\nif \{\[exists \$the_camera]\} \{\n    return \[value \$the_camera.frame]\n\} \{ \n    return \[frame]\n\}\n]"
  addUserKnob {4 d_projection_mode l projection M {perspective orthographic uv spherical ""}}
  addUserKnob {7 d_focal l "focal length" R 0 100}
  d_focal 50
  addUserKnob {7 d_haperture l "horiz aperture" R 0 50}
  d_haperture 24.576
  addUserKnob {7 d_vaperture l "vert aperture" R 0 50}
  d_vaperture 18.672
  addUserKnob {7 d_near l near R 0 10}
  d_near 0.1
  addUserKnob {7 d_far l far R 0 10000}
  d_far 10000
  addUserKnob {30 d_win_translate l "window translate"}
  addUserKnob {30 d_win_scale l "window scale"}
  d_win_scale {1 1}
  addUserKnob {7 d_winroll l "window roll" R 0 45}
  addUserKnob {7 d_focal_point l "focal distance" R 0 10}
  d_focal_point 2
  addUserKnob {7 d_fstop l fstop R 0 30}
  d_fstop 16
  addUserKnob {26 version l " " t "Updated 5 May 2021" T "<span style=\"color:#666\"><br/><b>DummyCam v1.3</b> - <a href=\"http://www.adrianpueyo.com\" style=\"color:#666;text-decoration: none;\">adrianpueyo.com</a>, 2019-2021</span>"}
 }
end_group
Viewer {
 frame 14
 frame_range 1-100
 colour_sample_bbox {-0.2138671875 0.1162109375 -0.212890625 0.1171875}
 samplepoints {{0.205078125 -0.095703125}
   }
 viewerProcess "Rec.709 (ACES)"
 name Viewer1
 xpos 545
 ypos 170
}
