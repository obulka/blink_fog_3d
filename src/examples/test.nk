define_window_layout_xml {<?xml version="1.0" encoding="UTF-8"?>
<layout version="1.0">
    <window x="1957" y="19" w="2523" h="1397" screen="0">
        <splitter orientation="1">
            <split size="92"/>
            <dock id="" hideTitles="1" activePageId="Toolbar.1">
                <page id="Toolbar.1"/>
            </dock>
            <split size="1808" stretch="1"/>
            <splitter orientation="2">
                <split size="795"/>
                <dock id="" activePageId="Viewer.1">
                    <page id="Viewer.1"/>
                    <page id="Viewer.2"/>
                </dock>
                <split size="559"/>
                <dock id="" activePageId="DAG.1" focus="true">
                    <page id="DAG.1"/>
                    <page id="Curve Editor.1"/>
                    <page id="DopeSheet.1"/>
                    <page id="DAG.2"/>
                </dock>
            </splitter>
            <split size="615"/>
            <dock id="" activePageId="Properties.1">
                <page id="Properties.1"/>
                <page id="uk.co.thefoundry.backgroundrenderview.1"/>
            </dock>
        </splitter>
    </window>
</layout>
}
Root {
 inputs 0
 name /home/ob1/software/nuke/dev/fog/src/examples/test.nk
 frame 3
 last_frame 48
 lock_range true
 format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
 proxy_type scale
 proxy_format "1024 778 0 0 1024 778 1 1K_Super_35(full-ap)"
 colorManagement OCIO
 OCIO_config aces_1.2
 defaultViewerLUT "OCIO LUTs"
 workingSpaceLUT scene_linear
 monitorLut ACES/sRGB
 monitorOutLUT "sRGB (ACES)"
 int8Lut matte_paint
 int16Lut texture_paint
 logLut compositing_log
 floatLut scene_linear
}
Axis3 {
 inputs 0
 rotate {20 {frame*5} 0}
 name Axis3
 xpos 805
 ypos -302
}
Camera3 {
 translate {0 0 10}
 focal_point 10
 fstop 0.16
 name Camera4
 xpos 805
 ypos -181
}
Dot {
 name Dot5
 xpos 915
 ypos -157
}
set Ncd5ddf0 [stack 0]
CheckerBoard2 {
 inputs 0
 name CheckerBoard2
 xpos 934
 ypos -419
}
Dot {
 name Dot4
 xpos 968
 ypos -306
}
set N80841a0 [stack 0]
Sphere {
 name Sphere1
 xpos 1049
 ypos -310
}
Scene {
 name Scene1
 xpos 1059
 ypos -268
}
push $N80841a0
ScanlineRender {
 inputs 3
 conservative_shader_sampling false
 motion_vectors_type distance
 output_shader_vectors true
 name ScanlineRender1
 xpos 1049
 ypos -161
}
Dot {
 name Dot1
 xpos 1083
 ypos -117
}
set Na5d77a0 [stack 0]
push $Ncd5ddf0
Group {
 inputs 2
 name blink_fog_3d
 tile_color 0x3b004cff
 xpos 1049
 ypos -66
 addUserKnob {20 User l BlinkFog3D}
 addUserKnob {26 sampling_settings l "<b>sampling settings"}
 addUserKnob {3 rays_per_pixel l "rays per pixel" t "The number of rays per pixel to sample noise on. This enables antialiasing as well as cleaning up the noise from sampling depth of field."}
 rays_per_pixel 4
 addUserKnob {3 samples_per_ray l "samples per ray" t "The number of noise samples to compute per ray. Increase this to reduce flickering. I recommend setting this low, around 5-10, until you have noise that looks about like you want, then increase this number to something like 100 for the final render."}
 samples_per_ray 200
 addUserKnob {7 density t "A multiplier that increases fog density." R 0 10}
 density 0.3
 addUserKnob {6 depth_of_field l "depth of field" t "Enable depth of field. This will be determined by the focal distance and fstop of the input camera. Increase the rays per pixel to clean up the noise when using this." +STARTLINE}
 addUserKnob {6 latlong t "Render a latlong." -STARTLINE}
 addUserKnob {26 depth_settings l "<b>depth settings"}
 addUserKnob {20 depth_ramp_1 l "Depth Ramp" n 1}
 addUserKnob {41 range l "depth ramp" t "The fog will only start being sampled at the depth specified in the first value, it will be scaled up to full density at the second value, maintain that density until the depth of the third value, and then ramp back down to the depth of the final value." T Keyer1.range}
 addUserKnob {20 endGroup n -1}
 addUserKnob {26 noise_settings l "<b>noise settings"}
 addUserKnob {7 size t "The size of the noise." R 1 300}
 size 10
 addUserKnob {4 type t "The noise type." M {turbulence fBm "" ""}}
 type fBm
 addUserKnob {13 translation t "Translate the noise by this amount."}
 addUserKnob {3 octaves t "The number of different frequencies to use."}
 octaves 4
 addUserKnob {7 lacunarity t "The per octave frequency multiplier." R 1 10}
 lacunarity 4
 addUserKnob {7 gain t "The per octave amplitude multiplier."}
 gain 0.5
 addUserKnob {7 gamma t "The result will be raised to 1 over this power."}
 gamma 0.5
 addUserKnob {19 low_frequency_scale l "low frequency scale" t "Scale the low frequencies by this amount separately from the high frequencies."}
 low_frequency_scale {1 1 1 1}
 addUserKnob {19 high_frequency_scale l "high frequency scale" t "Scale the high frequencies by this amount separately from the low frequencies."}
 high_frequency_scale {1 1 1 1}
 addUserKnob {19 low_frequency_translation l "low frequency translation" t "Translate the low frequencies by this amount separately from the high frequencies."}
 low_frequency_translation {0 0 0 0}
 addUserKnob {19 high_frequency_translation l "high frequency translation" t "Translate the high frequencies by this amount separately from the low frequencies."}
 high_frequency_translation {0 0 0 0}
 addUserKnob {26 "" +STARTLINE}
 addUserKnob {41 in l "depth channel" T shuffle.in}
 addUserKnob {6 invert_depth l "invert depth" t "Check this box to do 1/z, otherwise assumes true depth." -STARTLINE}
 invert_depth true
 addUserKnob {41 format T format_.format}
 addUserKnob {26 div0 l "" +STARTLINE}
 addUserKnob {26 info l "" +STARTLINE T "v1.0.0 - (c) Owen Bulka & Riley Gray - 2024"}
}
 Input {
  inputs 0
  name camera
  xpos 1598
  ypos 900
 }
 Camera {
  projection_mode {{"\[expression \[value the_cam]projection_mode(\[value the_frame])]"}}
  focal {{"\[expression \[value the_cam]focal(\[value the_frame])]"}}
  haperture {{"\[expression \[value the_cam]haperture(\[value the_frame])]"}}
  vaperture {{"\[expression \[value the_cam]vaperture(\[value the_frame])]"}}
  near {{"\[expression \[value the_cam]near(\[value the_frame])]"}}
  far {{"\[expression \[value the_cam]far(\[value the_frame])]"}}
  win_translate {{"\[expression \[value the_cam]win_translate.u(\[value the_frame])]"} {"\[expression \[value the_cam]win_translate.v(\[value the_frame])]"}}
  win_scale {{"\[expression \[value the_cam]win_scale.u(\[value the_frame])]"} {"\[expression \[value the_cam]win_scale.v(\[value the_frame])]"}}
  winroll {{"\[expression \[value the_cam]winroll(\[value the_frame])]"}}
  focal_point {{"\[expression \[value the_cam]focal_point(\[value the_frame])]"}}
  fstop {{"\[expression \[value the_cam]fstop(\[value the_frame])]"}}
  name DummyCam
  help "DummyCam by Adrian Pueyo\n\nCamera that apart from the matrices also grabs all the \"Projection\" values from the upstream camera that it's connected to. Turns into a default Camera if no Camera connected. Can also be used inside of groups and gizmos, as many levels deep as you want :D All using live and super fast TCL.\n\nUpdated v1.1: Now grabs the correct frame too (thanks Erwan Leroy for the idea).\n\nUpdated v1.3: Now accepts Nuke13's Camera3\n\nadrianpueyo.com, 2019-2021"
  onCreate "n = nuke.thisNode()\nfor k in \[\"projection_mode\",\"focal\",\"haperture\",\"vaperture\",\"near\",\"far\",\"win_translate\",\"win_scale\",\"winroll\",\"focal_point\",\"fstop\"]:\n    n\[k].setFlag(0x0000000010000000)"
  xpos 1608
  ypos 1000
  addUserKnob {20 DummyCam l Defaults}
  addUserKnob {43 the_cam +INVISIBLE}
  the_cam "\[\n#DummyCam v1.3 - Updated 5 May 2021.\nset starting_point \"this.input0\"\nset default \"this.d_\"\n\n# If cam has no inputs, return the default.\nif \{\[exists \$starting_point]\} \{\n    set x \[node \$starting_point]\n\} \{ \n    return \$default\n\}\n\nset finished 0\nwhile \{\$finished != 1\} \{\n\n    # First look for a Cam or Input or topnode.\n    while \{\[class \$x] != \"Camera3\" && \[class \$x] != \"Camera2\" && \[class \$x] != \"Camera\" && \[class \$x] != \"Input\" && \$x != \[topnode \$x]\} \{\n        set x \[node \$x.input0]\n    \}\n\n    # Then, check if node is a cam (and return), and otherwise, if it's an input, see if the parent exists and move to it.\n    if \{\[class \$x]==\"Camera3\"||\[class \$x]==\"Camera2\"||\[class \$x]==\"Camera\"\} \{\n        set x \[append x \".\"]\n        return \$x\n    \} \{ \n        if \{ \[class \$x]==\"Input\" \} \{ \n            set inp \"\$x.parent.input\"\n            set inputNum \[value \$x.number]\n            set inp \[append inp \$inputNum]\n            if \{ \[exists \$inp] \} \{\n                set x \[node \$inp]\n            \} \{ \n                set finished 1\n            \}\n        \} \{ \n            set finished 1\n        \}\n    \}\n\}\nreturn \$default\n]"
  addUserKnob {43 the_frame +INVISIBLE}
  the_frame "\[\nset the_camera \[string trimright \[value the_cam] .]\nif \{\[exists \$the_camera]\} \{\n    return \[value \$the_camera.frame]\n\} \{ \n    return \[frame]\n\}\n]"
  addUserKnob {4 d_projection_mode l projection M {perspective orthographic uv spherical ""}}
  addUserKnob {7 d_focal l "focal length" R 0 100}
  d_focal 50
  addUserKnob {7 d_haperture l "horiz aperture" R 0 50}
  d_haperture 24.576
  addUserKnob {7 d_vaperture l "vert aperture" R 0 50}
  d_vaperture 18.672
  addUserKnob {7 d_near l near R 0 10}
  d_near 0.1
  addUserKnob {7 d_far l far R 0 10000}
  d_far 10000
  addUserKnob {30 d_win_translate l "window translate"}
  addUserKnob {30 d_win_scale l "window scale"}
  d_win_scale {1 1}
  addUserKnob {7 d_winroll l "window roll" R 0 45}
  addUserKnob {7 d_focal_point l "focal distance" R 0 10}
  d_focal_point 2
  addUserKnob {7 d_fstop l fstop R 0 30}
  d_fstop 16
  addUserKnob {26 version l " " t "Updated 5 May 2021" T "<span style=\"color:#666\"><br/><b>DummyCam v1.3</b> - <a href=\"http://www.adrianpueyo.com\" style=\"color:#666;text-decoration: none;\">adrianpueyo.com</a>, 2019-2021</span>"}
 }
 Constant {
  inputs 0
  channels rgb
  format {{{parent.format_.format}}}
  name Constant2
  xpos 1244
  ypos 940
 }
 Input {
  inputs 0
  name depth
  xpos 1419
  ypos 899
  number 1
 }
 Merge2 {
  inputs 2
  name Merge1
  xpos 1419
  ypos 963
 }
 Shuffle {
  in depth
  name shuffle
  xpos 1419
  ypos 1012
 }
 Reformat {
  format {{{parent.format_.format}}}
  name Reformat1
  xpos 1419
  ypos 1046
 }
 Dot {
  name Dot1
  xpos 1453
  ypos 1158
 }
 Constant {
  inputs 0
  channels {rgba.red rgba.green rgba.blue -rgba.alpha}
  name format_
  xpos 1755
  ypos 897
 }
 Noise {
  output {rgba.red -rgba.green -rgba.blue -rgba.alpha}
  type turbulence
  size 1
  zoffset 1.72
  lacunarity 1.6
  center {512 389}
  name Noise1
  xpos 1755
  ypos 968
 }
 Noise {
  output {-rgba.red rgba.green -rgba.blue -rgba.alpha}
  type turbulence
  size 1
  zoffset 1.82
  center {512 389}
  name Noise2
  xpos 1755
  ypos 992
 }
 Noise {
  output {-rgba.red -rgba.green rgba.blue -rgba.alpha}
  type turbulence
  size 1
  zoffset 4.12
  lacunarity 2.14
  center {512 389}
  name Noise3
  xpos 1755
  ypos 1016
 }
 Noise {
  output {-rgba.red -rgba.green -rgba.blue rgba.alpha}
  type turbulence
  size 1
  zoffset 0.14
  lacunarity 2.14
  center {512 389}
  name Noise4
  xpos 1755
  ypos 1042
 }
 BlinkScript {
  kernelSourceFile /home/ob1/software/nuke/dev/fog/src/blink/kernels/random.cpp
  recompileCount 17
  ProgramGroup 1
  KernelDescription "2 \"Random\" iterate pixelWise 83d854fc4140a8394df2a57f56300e5490ae783e47e494182e2e8e1538bf9da5 2 \"seed\" Read Point \"dst\" Write Point 1 \"Inclusive Range\" Float 2 AAAAAAAAgD8= 1 \"_inclusiveRange\" 2 1 1 \"__rangeLength\" Float 1 1 AAAAAA=="
  kernelSource "// Copyright 2022 by Owen Bulka.\n// All rights reserved.\n// This file is released under the \"MIT License Agreement\".\n// Please see the LICENSE.md file that should have been included as part\n// of this package.\n\n\n/**\n * Compute the fractional portion of the value. Ex. 3.5 returns 0.5\n *\n * @arg value: The value to get the fractional portion of.\n *\n * @returns: The fractional portion of the value.\n */\ninline float fract(const float value)\n\{\n    return value - floor(value);\n\}\n\n\n/**\n * Get a random value on the interval \[0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval \[0, 1].\n */\ninline float4 random(const float4 &seed)\n\{\n    return float4(\n        fract(sin(75.19f * seed.x + 71.743f) * 7513.471f),\n        fract(sin(15.73f * seed.y + 113.591f) * 47453.553f),\n        fract(sin(7.37f * seed.z + 147.781f) * 8769.132f),\n        fract(sin(13.157f * seed.w + 71.743f) * 7513.471f)\n    );\n\}\n\n\nkernel Random : ImageComputationKernel<ePixelWise>\n\{\n    Image<eRead, eAccessPoint, eEdgeNone> seed; // the input image\n    Image<eWrite> dst; // the output image\n\n\n    param:\n        float2 _inclusiveRange;\n\n    local:\n        float __rangeLength;\n\n\n    /**\n     * Give the parameters labels and default values.\n     */\n    void define()\n    \{\n        defineParam(_inclusiveRange, \"Inclusive Range\", float2(0, 1));\n    \}\n\n\n    /**\n     * Initialize the local variables.\n     */\n    void init()\n    \{\n        __rangeLength = _inclusiveRange.y - _inclusiveRange.x;\n    \}\n\n\n    /**\n     * Compute a random pixel value.\n     */\n    void process(int2 pos)\n    \{\n        dst() = _inclusiveRange.x + __rangeLength * random(\n            seed() + float4(pos.x, pos.y, pos.x, pos.y)\n        );\n    \}\n\};\n"
  rebuild ""
  rebuild_finalise ""
  name BlinkScript7
  xpos 1755
  ypos 1080
 }
 BlinkScript {
  inputs 2
  kernelSourceFile /home/ob1/software/nuke/dev/fog/src/blink/kernels/blink_fog_3d.cpp
  recompileCount 129
  ProgramGroup 1
  KernelDescription "2 \"FogKernel\" iterate pixelWise 26e074011eb36077d1a1cfa09aec90fb9d1005908c14da0cd3516e22eb5b5d51 3 \"noise\" Read Point \"depthAOV\" Read Point \"dst\" Write Point 27 \"Focal Length\" Float 1 AABIQg== \"Horizontal Aperture\" Float 1 ppvEQQ== \"Near Plane\" Float 1 zczMPQ== \"Far Plane\" Float 1 AEAcRg== \"Camera World Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"Focal Distance\" Float 1 AACAQA== \"fstop\" Float 1 AACAQQ== \"Enable Depth Of Field\" Bool 1 AQ== \"Output LatLong\" Bool 1 AA== \"Screen Width\" Float 1 AABwRQ== \"Screen Height\" Float 1 AAAHRQ== \"Rays Per Pixel\" Int 1 AQAAAA== \"Density\" Float 1 AACAPw== \"Samples Per Ray\" Int 1 BQAAAA== \"Sample Depth Ramp\" Float 4 AACgQAAAIEEAAHBBAACgQQ== \"Size\" Float 1 AACgQQ== \"Noise Type\" Int 1 AAAAAA== \"Translation\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"Octaves\" Float 1 AAAAQQ== \"Lacunarity\" Float 1 AABAQA== \"Gain\" Float 1 AAAAPw== \"Gamma\" Float 1 AAAAPw== \"Low Frequency Scale\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"High Frequency Scale\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"Low Frequency Translation\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"High Frequency Translation\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"Invert Depth\" Bool 1 AA== 27 \"_focalLength\" 1 1 \"_horizontalAperture\" 1 1 \"_nearPlane\" 1 1 \"_farPlane\" 1 1 \"_cameraWorldMatrix\" 16 1 \"_focalDistance\" 1 1 \"_fStop\" 1 1 \"_depthOfFieldEnabled\" 1 1 \"_latLong\" 1 1 \"_formatWidth\" 1 1 \"_formatHeight\" 1 1 \"_raysPerPixel\" 1 1 \"_density\" 1 1 \"_samplesPerRay\" 1 1 \"_depthRamp\" 4 1 \"_size\" 1 1 \"_noiseType\" 1 1 \"_translation\" 3 1 \"_octaves\" 1 1 \"_lacunarity\" 1 1 \"_gain\" 1 1 \"_gamma\" 1 1 \"_lowFrequencyScale\" 4 1 \"_highFrequencyScale\" 4 1 \"_lowFrequencyTranslation\" 4 1 \"_highFrequencyTranslation\" 4 1 \"_invertDepth\" 1 1 5 \"__inverseCameraProjectionMatrix\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"__aperture\" Float 1 1 AAAAAA== \"__simplex\" Int 1 256 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"__perm\" Int 1 512 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"__grad4\" Int 1 128 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
  kernelSource "// Copyright 2024 by Owen Bulka.\n// All rights reserved.\n// This file is released under the \"MIT License Agreement\".\n// Please see the LICENSE.md file that should have been included as part\n// of this package.\n\n\n//\n// Math operations\n//\n\n\n/**\n * Compute the fractional portion of the value. Ex. 3.5 returns 0.5\n *\n * @arg value: The value to get the fractional portion of.\n *\n * @returns: The fractional portion of the value.\n */\ninline float fract(const float value)\n\{\n    return value - floor(value);\n\}\n\n\n/**\n * Multiply a 4d vector by a 4x4 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline void matmul(const float4x4 &m, const float4 &v, float4 &out)\n\{\n    for (int i=0; i < 4; i++)\n    \{\n        out\[i] = 0;\n\n        for (int j=0; j < 4; j++)\n        \{\n            out\[i] += m\[i]\[j] * v\[j];\n        \}\n    \}\n\}\n\n\n/**\n * Multiply a 4d vector by a 4x4 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline float4 matmul(const float4x4 &m, const float4 &v)\n\{\n    float4 out;\n    for (int i=0; i < 4; i++)\n    \{\n        out\[i] = 0;\n\n        for (int j=0; j < 4; j++)\n        \{\n            out\[i] += m\[i]\[j] * v\[j];\n        \}\n    \}\n\n    return out;\n\}\n\n\n/**\n * Multiply a 3d vector by a 3x3 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline float3 matmul(const float3x3 &m, const float3 &v)\n\{\n    return float3(\n        m\[0]\[0] * v.x + m\[0]\[1] * v.y + m\[0]\[2] * v.z,\n        m\[1]\[0] * v.x + m\[1]\[1] * v.y + m\[1]\[2] * v.z,\n        m\[2]\[0] * v.x + m\[2]\[1] * v.y + m\[2]\[2] * v.z\n    );\n\}\n\n\n/**\n * Convert the uv position in a latlong image to angles.\n *\n * @arg uvPosition: The UV position.\n *\n * @returns: The equivalent angles in radians.\n */\ninline float2 uvPositionToAngles(const float2 &uvPosition)\n\{\n    return float2(\n        (uvPosition.x + 1.0f) * PI,\n        (1.0f - uvPosition.y) * PI / 2.0f\n    );\n\}\n\n\n/**\n * Convert location of a pixel in an image into UV.\n *\n * @arg pixelLocation: The x, and y positions of the pixel.\n * @arg format: The image width, and height.\n *\n * @returns: The UV position.\n */\ninline float2 pixelsToUV(const float2 &pixelLocation, const float2 &format)\n\{\n    return float2(\n        2.0f * pixelLocation.x / format.x - 1.0f,\n        2.0f * pixelLocation.y / format.y - 1.0f\n    );\n\}\n\n\n/**\n * Convert a spherical unit vector (unit radius) to cartesion.\n *\n * @arg angles: The spherical angles in radians.\n *\n * @returns: The equivalent cartesion vector.\n */\ninline float3 sphericalUnitVectorToCartesion(const float2 &angles)\n\{\n    const float sinPhi = sin(angles.y);\n    return float3(\n        cos(angles.x) * sinPhi,\n        cos(angles.y),\n        sin(angles.x) * sinPhi\n    );\n\}\n\n\n/**\n * Get the position component of a world matrix.\n *\n * @arg worldMatrix: The world matrix.\n * @arg position: The location to store the position.\n */\ninline void positionFromWorldMatrix(const float4x4 &worldMatrix, float3 &position)\n\{\n    position = float3(\n        worldMatrix\[0]\[3],\n        worldMatrix\[1]\[3],\n        worldMatrix\[2]\[3]\n    );\n\}\n\n\n/**\n * Get the rotation component of a world matrix.\n *\n * @arg worldMatrix: The world matrix.\n * @arg rotation: The location to store the rotation.\n */\ninline void rotationFromWorldMatrix(const float4x4 &worldMatrix, float3x3 &rotationMatrix)\n\{\n    rotationMatrix\[0]\[0] = worldMatrix\[0]\[0];\n    rotationMatrix\[0]\[1] = worldMatrix\[0]\[1];\n    rotationMatrix\[0]\[2] = worldMatrix\[0]\[2];\n    rotationMatrix\[1]\[0] = worldMatrix\[1]\[0];\n    rotationMatrix\[1]\[1] = worldMatrix\[1]\[1];\n    rotationMatrix\[1]\[2] = worldMatrix\[1]\[2];\n    rotationMatrix\[2]\[0] = worldMatrix\[2]\[0];\n    rotationMatrix\[2]\[1] = worldMatrix\[2]\[1];\n    rotationMatrix\[2]\[2] = worldMatrix\[2]\[2];\n\}\n\n\n//\n// Randomization functions\n//\n\n\n// Some random constants on the interval \[1, 2]\n#define RAND_CONST_0 1.571411510193971f\n#define RAND_CONST_1 1.268632820084931f\n#define RAND_CONST_2 1.7880365647937733f\n#define RAND_CONST_3 1.3546987471558234f\n#define RAND_CONST_4 1.4365958250848703f\n#define RAND_CONST_5 1.7045380669435368f\n\n\n/**\n * Get a random value on the interval \[0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval \[0, 1].\n */\ninline float random(const float seed)\n\{\n    return fract(sin(73.1f * seed + 91.3458f) * 47453.5453f);\n\}\n\n\n/**\n * Get a random value on the interval \[0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval \[0, 1].\n */\ninline float2 random(const float2 &seed)\n\{\n    return float2(\n        fract(sin(13.157f * seed.x + 71.743f) * 7513.471f),\n        fract(sin(97.519f * seed.y + 113.591f) * 47453.5453f)\n    );\n\}\n\n\n/**\n * Create a random point that lies within the unit circle.\n *\n * @arg seed: The random seed.\n *\n * @returns: A random point, (radius, angle) in the unit circle.\n */\ninline float2 uniformPointInUnitCircle(const float2 &seed)\n\{\n    return float2(sqrt(random(seed.x)), 2.0f * PI * random(seed.y));\n\}\n\n\n/**\n * Sum the elements of a vector.\n *\n * @arg vector: The vector to sum the elements of.\n *\n * @returns: The sum of the vector elements.\n */\ninline float element_sum(const float4 &vector) \{\n    return vector.x + vector.y + vector.z + vector.w;\n\}\n\n\n#define FBM_NOISE 1\n\n\n//\n// Camera Utilities\n//\n\n\n/**\n * Compute the field of view from focal length.\n *\n * @arg focalLength: The focal length.\n *\n * @returns: The equivalent field of view.\n */\ninline float fieldOfView(const float focalLength)\n\{\n    return 2 * atan(1 / focalLength);\n\}\n\n\n/**\n * Compute the aspect ratio from image format.\n *\n * @arg height_: The height of the image.\n * @arg width_: The width of the image.\n *\n * @returns: The aspect ratio.\n */\ninline float aspectRatio(const float height_, const float width_)\n\{\n    return height_ / width_;\n\}\n\n\n/**\n *\n */\ninline float fStopToAperture(const float fStop, const float focalLength)\n\{\n    return focalLength / fStop / 1000.0f;\n\}\n\n\n/**\n * Create a projection matrix for a camera.\n *\n * @arg focalLength: The focal length of the camera.\n * @arg horizontalAperture: The horizontal aperture of the camera.\n * @arg aspect: The aspect ratio of the camera.\n * @arg nearPlane: The distance to the near plane of the camera.\n * @arg farPlane: The distance to the far plane of the camera.\n *\n * @returns: The camera's projection matrix.\n */\nfloat4x4 projectionMatrix(\n        const float focalLength,\n        const float horizontalAperture,\n        const float aspect,\n        const float nearPlane,\n        const float farPlane)\n\{\n    float farMinusNear = farPlane - nearPlane;\n    return float4x4(\n        2 * focalLength / horizontalAperture, 0, 0, 0,\n        0, 2 * focalLength / horizontalAperture / aspect, 0, 0,\n        0, 0, -(farPlane + nearPlane) / farMinusNear, -2 * (farPlane * nearPlane) / farMinusNear,\n        0, 0, -1, 0\n    );\n\}\n\n\n/**\n * Generate a ray out of a camera.\n *\n * @arg cameraWorldMatrix: The camera matrix.\n * @arg inverseProjectionMatrix: The inverse of the projection matrix.\n * @arg uvPosition: The UV position in the resulting image.\n * @arg rayOrigin: Will store the origin of the ray.\n * @arg rayDirection: Will store the direction of the ray.\n */\nvoid createCameraRay(\n        const float4x4 &cameraWorldMatrix,\n        const float4x4 &inverseProjectionMatrix,\n        const float2 &uvPosition,\n        float3 &rayOrigin,\n        float3 &rayDirection)\n\{\n    positionFromWorldMatrix(cameraWorldMatrix, rayOrigin);\n    float4 direction = matmul(\n        inverseProjectionMatrix,\n        float4(uvPosition.x, uvPosition.y, 0, 1)\n    );\n    matmul(\n        cameraWorldMatrix,\n        float4(direction.x, direction.y, direction.z, 0),\n        direction\n    );\n    rayDirection = normalize(float3(direction.x, direction.y, direction.z));\n\}\n\n\n/**\n * Generate a ray out of a camera.\n *\n * @arg cameraWorldMatrix: The camera matrix.\n * @arg inverseProjectionMatrix: The inverse of the projection matrix.\n * @arg uvPosition: The UV position in the resulting image.\n * @arg rayOrigin: Will store the origin of the ray.\n * @arg rayDirection: Will store the direction of the ray.\n */\nvoid createCameraRay(\n        const float4x4 &cameraWorldMatrix,\n        const float4x4 &inverseProjectionMatrix,\n        const float2 &uvPosition,\n        const float aperture,\n        const float focalDistance,\n        const float2 &seed,\n        float3 &rayOrigin,\n        float3 &rayDirection)\n\{\n    createCameraRay(\n        cameraWorldMatrix,\n        inverseProjectionMatrix,\n        uvPosition,\n        rayOrigin,\n        rayDirection\n    );\n\n    const float4 cameraForward4 = matmul(\n        cameraWorldMatrix,\n        float4(0, 0, -1, 0)\n    );\n    const float3 cameraForward = float3(\n        cameraForward4.x,\n        cameraForward4.y,\n        cameraForward4.z\n    );\n    const float4 cameraRight4 = matmul(\n        cameraWorldMatrix,\n        float4(1, 0, 0, 0)\n    );\n    const float3 cameraRight = float3(\n        cameraRight4.x,\n        cameraRight4.y,\n        cameraRight4.z\n    );\n    const float4 cameraUp4 = matmul(\n        cameraWorldMatrix,\n        float4(0, 1, 0, 0)\n    );\n    const float3 cameraUp = float3(\n        cameraUp4.x,\n        cameraUp4.y,\n        cameraUp4.z\n    );\n\n    const float3 focalPlanePoint = rayOrigin + cameraForward * focalDistance;\n    const float3 focalPlaneNormal = -cameraForward;\n\n    const float focalPointDistance = (\n        (dot(focalPlaneNormal, focalPlanePoint) - dot(rayOrigin, focalPlaneNormal))\n        / dot(rayDirection, focalPlaneNormal)\n    );\n    const float3 focalPoint = rayOrigin + focalPointDistance * rayDirection;\n\n    const float2 pointInUnitCircle = uniformPointInUnitCircle(seed);\n    const float2 offset = pointInUnitCircle.x * aperture * float2(\n        cos(pointInUnitCircle.y),\n        sin(pointInUnitCircle.y)\n    );\n\n    rayOrigin += cameraRight * offset.x + cameraUp * offset.y;\n    rayDirection = normalize(focalPoint - rayOrigin);\n\}\n\n\n/**\n * Generate a LatLong ray out of a camera.\n *\n * @arg cameraWorldMatrix: The camera matrix.\n * @arg uvPosition: The UV position in the resulting image.\n * @arg rayOrigin: Will store the origin of the ray.\n * @arg rayDirection: Will store the direction of the ray.\n */\nvoid createLatLongCameraRay(\n        const float4x4 &cameraWorldMatrix,\n        const float2 &uvPosition,\n        float3 &rayOrigin,\n        float3 &rayDirection)\n\{\n    positionFromWorldMatrix(cameraWorldMatrix, rayOrigin);\n    rayDirection = sphericalUnitVectorToCartesion(uvPositionToAngles(uvPosition));\n\n    float3x3 cameraRotation;\n    rotationFromWorldMatrix(cameraWorldMatrix, cameraRotation);\n    rayDirection = matmul(cameraRotation, rayDirection);\n\}\n\n\n\nkernel FogKernel : ImageComputationKernel<ePixelWise>\n\{\n    // the input which specifies the format, process is called once per pixel\n    // in this image, which also provides random seeds\n    Image<eRead, eAccessPoint, eEdgeNone> noise;\n    Image<eRead, eAccessPoint, eEdgeClamped> depthAOV;\n\n    // the output image\n    Image<eWrite> dst;\n\n\n    param:\n        // These parameters are made available to the user.\n\n        // Camera params\n        float _focalLength;\n        float _horizontalAperture;\n        float _nearPlane;\n        float _farPlane;\n        float4x4 _cameraWorldMatrix;\n        float _focalDistance;\n        float _fStop;\n        bool _depthOfFieldEnabled;\n        bool _latLong;\n\n        // Image params\n        float _formatWidth;\n        float _formatHeight;\n        int _raysPerPixel;\n        float _density;\n        int _samplesPerRay;\n        float4 _depthRamp;\n\n        // Noise Parameters\n        float _size;\n        int _noiseType;\n        float3 _translation;\n        float _octaves;\n        float _lacunarity;\n        float _gain;\n        float _gamma;\n        float4 _lowFrequencyScale;\n        float4 _highFrequencyScale;\n        float4 _lowFrequencyTranslation;\n        float4 _highFrequencyTranslation;\n\n        bool _invertDepth;\n\n    local:\n        // These local variables are not exposed to the user.\n        float4x4 __inverseCameraProjectionMatrix;\n        float __aperture;\n\n        int __simplex\[64]\[4];\n        int __perm\[512];\n        int __grad4\[32]\[4];\n\n    /**\n     * Give the parameters labels and default values.\n     */\n    void define()\n    \{\n        // Camera params\n        defineParam(_focalLength, \"Focal Length\", 50.0f);\n        defineParam(_horizontalAperture, \"Horizontal Aperture\", 24.576f);\n        defineParam(_nearPlane, \"Near Plane\", 0.1f);\n        defineParam(_farPlane, \"Far Plane\", 10000.0f);\n        defineParam(\n            _cameraWorldMatrix,\n            \"Camera World Matrix\",\n            float4x4(\n                1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1\n            )\n        );\n        defineParam(_focalDistance, \"Focal Distance\", 4.0f);\n        defineParam(_fStop, \"fstop\", 16.0f);\n        defineParam(_depthOfFieldEnabled, \"Enable Depth Of Field\", true);\n        defineParam(_latLong, \"Output LatLong\", false);\n\n        // Image params\n        defineParam(_formatHeight, \"Screen Height\", 2160.0f);\n        defineParam(_formatWidth, \"Screen Width\", 3840.0f);\n        defineParam(_density, \"Density\", 1.0f);\n        defineParam(_raysPerPixel, \"Rays Per Pixel\", 1);\n        defineParam(_samplesPerRay, \"Samples Per Ray\", 5);\n        defineParam(_depthRamp, \"Sample Depth Ramp\", float4(5.0f, 10.0f, 15.0f, 20.0f));\n\n        // Noise Parameters\n        defineParam(_size, \"Size\", 20.0f);\n        defineParam(_noiseType, \"Noise Type\", 0);\n        defineParam(_translation, \"Translation\", float3(0.0f, 0.0f, 0.0f));\n        defineParam(_octaves, \"Octaves\", 8.0f);\n        defineParam(_lacunarity, \"Lacunarity\", 3.0f);\n        defineParam(_gain, \"Gain\", 0.5f);\n        defineParam(_gamma, \"Gamma\", 0.5f);\n        defineParam(_lowFrequencyScale, \"Low Frequency Scale\", float4(0.0f, 0.0f, 0.0f, 0.0f));\n        defineParam(_highFrequencyScale, \"High Frequency Scale\", float4(0.0f, 0.0f, 0.0f, 0.0f));\n        defineParam(_lowFrequencyTranslation, \"Low Frequency Translation\", float4(0.0f, 0.0f, 0.0f, 0.0f));\n        defineParam(_highFrequencyTranslation, \"High Frequency Translation\", float4(0.0f, 0.0f, 0.0f, 0.0f));\n        defineParam(_invertDepth, \"Invert Depth\", false);\n    \}\n\n\n    /**\n     * Initialize the local variables.\n     */\n    void init()\n    \{\n        const float aspect = aspectRatio(_formatHeight, _formatWidth);\n        float4x4 cameraProjectionMatrix = projectionMatrix(\n            _focalLength,\n            _horizontalAperture,\n            aspect,\n            _nearPlane,\n            _farPlane\n        );\n        __inverseCameraProjectionMatrix = cameraProjectionMatrix.invert();\n\n        __aperture = fStopToAperture(_fStop, _focalLength);\n\n        const int simplexInit\[64]\[4] = \{\n            \{0, 1, 2, 3\}, \{0, 1, 3, 2\}, \{0, 0, 0, 0\}, \{0, 2, 3, 1\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{1, 2, 3, 0\},\n            \{0, 2, 1, 3\}, \{0, 0, 0, 0\}, \{0, 3, 1, 2\}, \{0, 3, 2, 1\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{1, 3, 2, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{1, 2, 0, 3\}, \{0, 0, 0, 0\}, \{1, 3, 0, 2\}, \{0, 0, 0, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{2, 3, 0, 1\}, \{2, 3, 1, 0\},\n            \{1, 0, 2, 3\}, \{1, 0, 3, 2\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{0, 0, 0, 0\}, \{2, 0, 3, 1\}, \{0, 0, 0, 0\}, \{2, 1, 3, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{2, 0, 1, 3\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{3, 0, 1, 2\}, \{3, 0, 2, 1\}, \{0, 0, 0, 0\}, \{3, 1, 2, 0\},\n            \{2, 1, 0, 3\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{3, 1, 0, 2\}, \{0, 0, 0, 0\}, \{3, 2, 0, 1\}, \{3, 2, 1, 0\}\n        \};\n\n        for (int i = 0; i < 64; i++)\n        \{\n            for (int j = 0; j < 4; j++)\n            \{\n                __simplex\[i]\[j] = simplexInit\[i]\[j];\n            \}\n        \}\n\n        const int permInit\[256] = \{\n            151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233,\n            7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23,\n            190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219,\n            203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174,\n            20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48,\n            27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133,\n            230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65,\n            25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18,\n            169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198,\n            173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147,\n            118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17,\n            182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44,\n            154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22,\n            39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112,\n            104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12,\n            191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49,\n            192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121,\n            50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29,\n            24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180\n        \};\n\n        for (int i = 0; i < 512; i++)\n        \{\n            __perm\[i] = permInit\[i % 256];\n        \}\n\n        const int grad4Init\[32]\[4]= \{\n            \{0, 1, 1, 1\},  \{0, 1, 1, -1\},  \{0, 1, -1, 1\},  \{0, 1, -1, -1\},\n            \{0, -1, 1, 1\}, \{0, -1, 1, -1\}, \{0, -1, -1, 1\}, \{0, -1, -1, -1\},\n            \{1, 0, 1, 1\},  \{1, 0, 1, -1\},  \{1, 0, -1, 1\},  \{1, 0, -1, -1\},\n            \{-1, 0, 1, 1\}, \{-1, 0, 1, -1\}, \{-1, 0, -1, 1\}, \{-1, 0, -1, -1\},\n            \{1, 1, 0, 1\},  \{1, 1, 0, -1\},  \{1, -1, 0, 1\},  \{1, -1, 0, -1\},\n            \{-1, 1, 0, 1\}, \{-1, 1, 0, -1\}, \{-1, -1, 0, 1\}, \{-1, -1, 0, -1\},\n            \{1, 1, 1, 0\},  \{1, 1, -1, 0\},  \{1, -1, 1, 0\},  \{1, -1, -1, 0\},\n            \{-1, 1, 1, 0\}, \{-1, 1, -1, 0\}, \{-1, -1, 1, 0\}, \{-1, -1, -1, 0\}\n        \};\n\n        for (int i = 0; i < 32; i++)\n        \{\n            for (int j = 0; j < 4; j++)\n            \{\n                __grad4\[i]\[j] = grad4Init\[i]\[j];\n            \}\n        \}\n    \}\n\n    /**\n     * 4D Perlin simplex noise\n     *\n     * Copyright (c) 2007-2012 Eliot Eshelman\n     *\n     * This program is free software: you can redistribute it and/or modify\n     * it under the terms of the GNU General Public License as published by\n     * the Free Software Foundation, either version 3 of the License, or\n     * (at your option) any later version.\n     *\n     * This program is distributed in the hope that it will be useful,\n     * but WITHOUT ANY WARRANTY; without even the implied warranty of\n     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n     * GNU General Public License for more details.\n     *\n     * You should have received a copy of the GNU General Public License\n     * along with this program. If not, see <http://www.gnu.org/licenses/>.\n     *\n     * @arg seed: The seed for the noise.\n     * @arg simplex: The simplex LUT.\n     * @arg perm: The perm LUT.\n     * @arg grad4: The grad4 LUT.\n     *\n     * @returns: Noise value in the range \[-1, 1], value of 0 on all integer\n     *     coordinates.\n     */\n    inline float perlinSimplexNoise(\n            const float4 &seed\n    )\n    \{\n        const float G4 = 0.138196601f;\n        const float4 i = floor(seed + element_sum(seed) * 0.309016994f);\n        const float4 x0 = seed - i + element_sum(i) * G4;\n\n        const int c = (\n            ((x0.x > x0.y) << 5)\n            | ((x0.x > x0.z) << 4)\n            | ((x0.y > x0.z) << 3)\n            | ((x0.x > x0.w) << 2)\n            | ((x0.y > x0.w) << 1)\n            | (x0.z > x0.w)\n        );\n        const int4 i1 = int4(\n            __simplex\[c]\[0] >= 3,\n            __simplex\[c]\[1] >= 3,\n            __simplex\[c]\[2] >= 3,\n            __simplex\[c]\[3] >= 3\n        );\n        const int4 i2 = int4(\n            __simplex\[c]\[0] >= 2,\n            __simplex\[c]\[1] >= 2,\n            __simplex\[c]\[2] >= 2,\n            __simplex\[c]\[3] >= 2\n        );\n        const int4 i3 = int4(\n            __simplex\[c]\[0] >= 1,\n            __simplex\[c]\[1] >= 1,\n            __simplex\[c]\[2] >= 1,\n            __simplex\[c]\[3] >= 1\n        );\n\n        const float4 x1 = x0 - float4(i1.x, i1.y, i1.z, i1.w) + G4;\n        const float4 x2 = x0 - float4(i2.x, i2.y, i2.z, i2.w) + 2.0f * G4;\n        const float4 x3 = x0 - float4(i3.x, i3.y, i3.z, i3.w) + 3.0f * G4;\n        const float4 x4 = x0 - 1.0f + 4.0f * G4;\n\n        const int ii = (int) i.x & 255;\n        const int jj = (int) i.y & 255;\n        const int kk = (int) i.z & 255;\n        const int ll = (int) i.w & 255;\n\n        const int gi0 = __perm\[\n            ii + __perm\[jj + __perm\[kk + __perm\[ll]]]\n        ] % 32;\n        const int gi1 = __perm\[\n            ii + i1.x + __perm\[jj + i1.y + __perm\[kk + i1.z + __perm\[ll + i1.w]]]\n        ] % 32;\n        const int gi2 = __perm\[\n            ii + i2.x + __perm\[jj + i2.y + __perm\[kk + i2.z + __perm\[ll + i2.w]]]\n        ] % 32;\n        const int gi3 = __perm\[\n            ii + i3.x + __perm\[jj + i3.y + __perm\[kk + i3.z + __perm\[ll + i3.w]]]\n        ] % 32;\n        const int gi4 = __perm\[\n            ii + 1 + __perm\[jj + 1 + __perm\[kk + 1 + __perm\[ll + 1]]]\n        ] % 32;\n\n        float n0, n1, n2, n3, n4;\n        float t0 = 0.6f - dot(x0, x0);\n        if (t0 < 0)\n        \{\n            n0 = 0.0f;\n        \}\n        else\n        \{\n            t0 *= t0;\n            n0 = t0 * t0 * dot(\n                float4(__grad4\[gi0]\[0], __grad4\[gi0]\[2], __grad4\[gi0]\[3], __grad4\[gi0]\[3]),\n                x0\n            );\n        \}\n\n        float t1 = 0.6f - dot(x1, x1);\n        if (t1 < 0)\n        \{\n            n1 = 0.0f;\n        \}\n        else\n        \{\n            t1 *= t1;\n            n1 = t1 * t1 * dot(\n                float4(__grad4\[gi1]\[0], __grad4\[gi1]\[2], __grad4\[gi1]\[3], __grad4\[gi1]\[3]),\n                x1\n            );\n        \}\n\n        float t2 = 0.6f - dot(x2, x2);\n        if (t2 < 0)\n        \{\n            n2 = 0.0f;\n        \}\n        else\n        \{\n            t2 *= t2;\n            n2 = t2 * t2 * dot(\n                float4(__grad4\[gi2]\[0], __grad4\[gi2]\[2], __grad4\[gi2]\[3], __grad4\[gi2]\[3]),\n                x2\n            );\n        \}\n\n        float t3 = 0.6f - dot(x3, x3);\n        if (t3 < 0)\n        \{\n            n3 = 0.0f;\n        \}\n        else\n        \{\n            t3 *= t3;\n            n3 = t3 * t3 * dot(\n                float4(__grad4\[gi3]\[0], __grad4\[gi3]\[2], __grad4\[gi3]\[3], __grad4\[gi3]\[3]),\n                x3\n            );\n        \}\n\n        float t4 = 0.6f - dot(x4, x4);\n        if (t4 < 0)\n        \{\n            n4 = 0.0f;\n        \}\n        else \{\n            t4 *= t4;\n            n4 = t4 * t4 * dot(\n                float4(__grad4\[gi4]\[0], __grad4\[gi4]\[2], __grad4\[gi4]\[3], __grad4\[gi4]\[3]),\n                x4\n            );\n        \}\n\n        return 27.0f * (n0 + n1 + n2 + n3 + n4);\n    \}\n\n\n    //\n    // Use the perlin simplex noise\n    //\n\n\n    /**\n     * fBM noise.\n     *\n     * @arg position: The position to seed the noise.\n     *\n     * @returns: The noise value in the range \[-1, 1].\n     */\n    float fractalBrownianMotionNoise(const float4 &position)\n    \{\n        float output = 0.0f;\n        float frequency = _lacunarity;\n        float amplitude = 1.0f;\n        float denom = 0.0f;\n        float4 translation;\n        float4 scale;\n\n        for (int octave=0; octave < _octaves; octave++)\n        \{\n            const float octaveFraction = octave / _octaves;\n            scale = (\n                (_highFrequencyScale * octaveFraction)\n                + (_lowFrequencyScale * (1.0f - octaveFraction))\n            );       \n            translation = (\n                (_highFrequencyTranslation * octaveFraction)\n                + (_lowFrequencyTranslation * (1.0f - octaveFraction))\n            );\n\n            output += amplitude * perlinSimplexNoise(\n                (position * scale + translation) * frequency / _size\n            );\n\n            frequency *= _lacunarity;\n            denom += amplitude;\n            amplitude *= _gain;\n        \}\n\n        return pow(fabs(output / denom), 1.0f / _gamma);\n    \}\n\n\n    /**\n     * Turbulence noise.\n     *\n     * @arg position: The position to seed the noise.\n     *\n     * @returns: The noise value in the range \[0, 1].\n     */\n    float turbulenceNoise(const float4 &position)\n    \{\n        float output = 0.0f;\n        float frequency = _lacunarity;\n        float amplitude = 1.0f;\n        float denom = 0.0f;\n        float4 translation;\n        float4 scale;\n\n        for (int octave=0; octave < _octaves; octave++)\n        \{\n            const float octaveFraction = octave / _octaves;\n            scale = (\n                (_highFrequencyScale * octaveFraction)\n                + (_lowFrequencyScale * (1.0f - octaveFraction))\n            );       \n            translation = (\n                (_highFrequencyTranslation * octaveFraction)\n                + (_lowFrequencyTranslation * (1.0f - octaveFraction))\n            );\n\n            output += fabs(\n                amplitude * perlinSimplexNoise(\n                    (position * scale + translation) * frequency / _size\n                )\n            );\n\n            frequency *= _lacunarity;\n            denom += amplitude;\n            amplitude *= _gain;\n        \}\n\n        return pow(output / denom, 1.0f / _gamma);\n    \}\n\n\n    /**\n     * Create a ray out of the camera. It will be either a standard ray,\n     * a latlong ray, or a ray that will result in depth of field.\n     *\n     * @arg seed: The seed to use in randomization.\n     * @arg pixelLocation: The x, and y locations of the pixel.\n     * @arg rayOrigin: The location to store the origin of the new ray.\n     * @arg rayDirection: The location to store the direction of the new\n     *     ray.\n     */\n    void getCameraRay(\n            const float2 &seed,\n            const float2 &pixelLocation,\n            float3 &rayOrigin,\n            float3 &rayDirection)\n    \{\n        const float2 uvCoordinates = pixelsToUV(\n            pixelLocation + random(seed),\n            float2(_formatWidth, _formatHeight)\n        );\n        if (_latLong)\n        \{\n            createLatLongCameraRay(\n                _cameraWorldMatrix,\n                uvCoordinates,\n                rayOrigin,\n                rayDirection\n            );\n        \}\n        else if (_depthOfFieldEnabled)\n        \{\n            createCameraRay(\n                _cameraWorldMatrix,\n                __inverseCameraProjectionMatrix,\n                uvCoordinates,\n                __aperture,\n                _focalDistance,\n                seed,\n                rayOrigin,\n                rayDirection\n            );\n        \}\n        else\n        \{\n            createCameraRay(\n                _cameraWorldMatrix,\n                __inverseCameraProjectionMatrix,\n                uvCoordinates,\n                rayOrigin,\n                rayDirection\n            );\n        \}\n    \}\n\n\n    /**\n     * Compute a raymarched pixel value.\n     *\n     * @arg pos: The x, and y location we are currently processing.\n     */\n    void process(int2 pos)\n    \{\n        float pixelDepth = depthAOV(0);\n        pixelDepth = (\n            pixelDepth > 0.0f ? (_invertDepth ? 1.0f / pixelDepth : pixelDepth) : _depthRamp.w\n        );\n\n        float2 pixelLocation = float2(pos.x, pos.y);\n        SampleType(noise) noisePixel = noise();\n        float2 seed0 = float2(noisePixel.x, noisePixel.y) + RAND_CONST_0 * pixelLocation;\n        float2 seed1 = float2(noisePixel.z, noisePixel.w) + RAND_CONST_1 * pixelLocation;\n\n        float4 resultPixel = float4(0.0f);\n\n        const float sampleStep = (_depthRamp.w - _depthRamp.x) / (float) _samplesPerRay;\n\n        for (int path=1; path <= _raysPerPixel; path++)\n        \{\n            // Generate a ray from the camera\n            float3 rayOrigin;\n            float3 rayDirection;\n            getCameraRay(\n                seed0,\n                pixelLocation,\n                rayOrigin,\n                rayDirection\n            );\n\n            float depth = _depthRamp.x;\n            rayOrigin += depth * rayDirection + _translation;\n\n            float invertedLastSample = 1.0f;\n            for (int step=0; step < _samplesPerRay; step++)\n            \{\n                depth += sampleStep;\n                if (depth > pixelDepth)\n                \{\n                    break;\n                \}\n                rayOrigin += rayDirection * sampleStep;\n\n                // Get the noise value based on which type of noise we are using\n                const float4 samplePosition4d = float4(\n                    rayOrigin.x,\n                    rayOrigin.y,\n                    rayOrigin.z,\n                    0.0f\n                );\n                float ramp;\n                if (depth < _depthRamp.y)\n                \{\n                    ramp = (depth - _depthRamp.y) / (_depthRamp.y - _depthRamp.x) + 1.0f;\n                \}\n                else if (depth >= _depthRamp.y && depth <= _depthRamp.z)\n                \{\n                    ramp = 1.0f;\n                \}\n                else\n                \{\n                    ramp = (_depthRamp.w - depth) / (_depthRamp.w - _depthRamp.z);\n                \}\n\n                float noiseValue = _density * ramp;\n                if (_noiseType == FBM_NOISE)\n                \{\n                    noiseValue *= fractalBrownianMotionNoise(samplePosition4d);\n                \}\n                else\n                \{\n                    noiseValue *= turbulenceNoise(samplePosition4d);\n                \}\n\n                resultPixel += noiseValue * invertedLastSample;\n                invertedLastSample *= 1.0f - noiseValue;\n            \}\n\n            const float2 lastSeed = seed0;\n            seed0 = RAND_CONST_2 * float2(seed1.y, seed1.x) + RAND_CONST_3 * path;\n            seed1 = RAND_CONST_4 * lastSeed + RAND_CONST_5 * path;\n        \}\n\n        dst() = resultPixel / float(_raysPerPixel);\n    \}\n\};\n"
  rebuild ""
  "FogKernel_Focal Length" {{parent.DummyCam.focal}}
  "FogKernel_Horizontal Aperture" {{parent.DummyCam.haperture}}
  "FogKernel_Near Plane" {{parent.DummyCam.near}}
  "FogKernel_Far Plane" {{parent.DummyCam.far}}
  "FogKernel_Camera World Matrix" {
      {{parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix}}
      {{parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix}}
      {{parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix}}
      {{parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix}}
    }
  "FogKernel_Focal Distance" {{parent.DummyCam.focal_point}}
  FogKernel_fstop {{parent.DummyCam.fstop}}
  "FogKernel_Enable Depth Of Field" {{parent.depth_of_field}}
  "FogKernel_Output LatLong" {{parent.latlong}}
  "FogKernel_Screen Width" {{input0.width}}
  "FogKernel_Screen Height" {{input0.height}}
  "FogKernel_Rays Per Pixel" {{parent.rays_per_pixel}}
  FogKernel_Density {{parent.density}}
  "FogKernel_Samples Per Ray" {{parent.samples_per_ray}}
  "FogKernel_Sample Depth Ramp" {{parent.Keyer1.range.A} {parent.Keyer1.range.B} {parent.Keyer1.range.C} {parent.Keyer1.range.D}}
  FogKernel_Size {{parent.size}}
  "FogKernel_Noise Type" {{parent.type}}
  FogKernel_Translation {{-parent.translation} {-parent.translation} {-parent.translation}}
  FogKernel_Octaves {{parent.octaves}}
  FogKernel_Lacunarity {{parent.lacunarity}}
  FogKernel_Gain {{parent.gain}}
  FogKernel_Gamma {{parent.gamma}}
  "FogKernel_Low Frequency Scale" {{parent.low_frequency_scale} {parent.low_frequency_scale} {parent.low_frequency_scale} {parent.low_frequency_scale}}
  "FogKernel_High Frequency Scale" {{parent.high_frequency_scale} {parent.high_frequency_scale} {parent.high_frequency_scale} {parent.high_frequency_scale}}
  "FogKernel_Low Frequency Translation" {{parent.low_frequency_translation} {parent.low_frequency_translation} {parent.low_frequency_translation} {parent.low_frequency_translation}}
  "FogKernel_High Frequency Translation" {{parent.high_frequency_translation} {parent.high_frequency_translation} {parent.high_frequency_translation} {parent.high_frequency_translation}}
  "FogKernel_Invert Depth" {{parent.invert_depth}}
  rebuild_finalise ""
  name BlinkScript1
  xpos 1755
  ypos 1148
 }
 Output {
  name Output1
  xpos 1755
  ypos 1314
 }
 Keyer {
  inputs 0
  operation "luminance key"
  range {7 8 12 13}
  name Keyer1
  xpos 1982
  ypos 979
 }
end_group
Dot {
 name Dot2
 xpos 1083
 ypos 5
}
push $Na5d77a0
Dot {
 name Dot3
 xpos 1197
 ypos -117
}
Merge2 {
 inputs 2
 name Merge1
 xpos 1163
 ypos 1
}
Viewer {
 inputs 0
 frame 3
 frame_range 1-48
 viewerProcess "sRGB (ACES)"
 name Viewer1
 xpos 1163
 ypos 164
}
Group {
 inputs 0
 name blink_fog_3d1
 tile_color 0x3b004cff
 xpos 1459
 ypos -188
 addUserKnob {20 User l BlinkFog3D}
 addUserKnob {26 sampling_settings l "<b>sampling settings"}
 addUserKnob {3 rays_per_pixel l "rays per pixel" t "The number of rays per pixel to sample noise on. This enables antialiasing as well as cleaning up the noise from sampling depth of field."}
 rays_per_pixel 4
 addUserKnob {3 samples_per_ray l "samples per ray" t "The number of noise samples to compute per ray. Increase this to reduce flickering. I recommend setting this low, around 5-10, until you have noise that looks about like you want, then increase this number to something like 100 for the final render."}
 samples_per_ray 100
 addUserKnob {7 density t "A multiplier that increases fog density." R 0 10}
 density 1
 addUserKnob {6 depth_of_field l "depth of field" t "Enable depth of field. This will be determined by the focal distance and fstop of the input camera. Increase the rays per pixel to clean up the noise when using this." +STARTLINE}
 addUserKnob {6 latlong t "Render a latlong." -STARTLINE}
 addUserKnob {26 depth_settings l "<b>depth settings"}
 addUserKnob {20 depth_ramp_1 l "Depth Ramp" n 1}
 addUserKnob {41 range l "depth ramp" t "The fog will only start being sampled at the depth specified in the first value, it will be scaled up to full density at the second value, maintain that density until the depth of the third value, and then ramp back down to the depth of the final value." T Keyer1.range}
 addUserKnob {20 endGroup n -1}
 addUserKnob {26 noise_settings l "<b>noise settings"}
 addUserKnob {7 size t "The size of the noise." R 1 300}
 size 10
 addUserKnob {4 type t "The noise type." M {turbulence fBm "" ""}}
 type fBm
 addUserKnob {13 translation t "Translate the noise by this amount."}
 addUserKnob {3 octaves t "The number of different frequencies to use."}
 octaves 4
 addUserKnob {7 lacunarity t "The per octave frequency multiplier." R 1 10}
 lacunarity 4
 addUserKnob {7 gain t "The per octave amplitude multiplier."}
 gain 0.5
 addUserKnob {7 gamma t "The result will be raised to 1 over this power."}
 gamma 0.5
 addUserKnob {19 low_frequency_scale l "low frequency scale" t "Scale the low frequencies by this amount separately from the high frequencies."}
 low_frequency_scale {1 1 1 1}
 addUserKnob {19 high_frequency_scale l "high frequency scale" t "Scale the high frequencies by this amount separately from the low frequencies."}
 high_frequency_scale {1 1 1 1}
 addUserKnob {19 low_frequency_translation l "low frequency translation" t "Translate the low frequencies by this amount separately from the high frequencies."}
 low_frequency_translation {0 0 0 0}
 addUserKnob {19 high_frequency_translation l "high frequency translation" t "Translate the high frequencies by this amount separately from the low frequencies."}
 high_frequency_translation {0 0 0 0}
 addUserKnob {26 ""}
 addUserKnob {41 in l "depth channel" T shuffle.in}
 addUserKnob {6 invert_depth l "invert depth" t "Check this box to do 1/z, otherwise assumes true depth." -STARTLINE}
 invert_depth true
 addUserKnob {41 format T format_.format}
 addUserKnob {26 div0 l "" +STARTLINE}
 addUserKnob {26 info l "" +STARTLINE T "v1.0.0 - (c) Owen Bulka & Riley Gray - 2024"}
}
 Input {
  inputs 0
  name camera
  xpos 1598
  ypos 900
 }
 Camera {
  projection_mode {{"\[expression \[value the_cam]projection_mode(\[value the_frame])]"}}
  focal {{"\[expression \[value the_cam]focal(\[value the_frame])]"}}
  haperture {{"\[expression \[value the_cam]haperture(\[value the_frame])]"}}
  vaperture {{"\[expression \[value the_cam]vaperture(\[value the_frame])]"}}
  near {{"\[expression \[value the_cam]near(\[value the_frame])]"}}
  far {{"\[expression \[value the_cam]far(\[value the_frame])]"}}
  win_translate {{"\[expression \[value the_cam]win_translate.u(\[value the_frame])]"} {"\[expression \[value the_cam]win_translate.v(\[value the_frame])]"}}
  win_scale {{"\[expression \[value the_cam]win_scale.u(\[value the_frame])]"} {"\[expression \[value the_cam]win_scale.v(\[value the_frame])]"}}
  winroll {{"\[expression \[value the_cam]winroll(\[value the_frame])]"}}
  focal_point {{"\[expression \[value the_cam]focal_point(\[value the_frame])]"}}
  fstop {{"\[expression \[value the_cam]fstop(\[value the_frame])]"}}
  name DummyCam
  help "DummyCam by Adrian Pueyo\n\nCamera that apart from the matrices also grabs all the \"Projection\" values from the upstream camera that it's connected to. Turns into a default Camera if no Camera connected. Can also be used inside of groups and gizmos, as many levels deep as you want :D All using live and super fast TCL.\n\nUpdated v1.1: Now grabs the correct frame too (thanks Erwan Leroy for the idea).\n\nUpdated v1.3: Now accepts Nuke13's Camera3\n\nadrianpueyo.com, 2019-2021"
  onCreate "n = nuke.thisNode()\nfor k in \[\"projection_mode\",\"focal\",\"haperture\",\"vaperture\",\"near\",\"far\",\"win_translate\",\"win_scale\",\"winroll\",\"focal_point\",\"fstop\"]:\n    n\[k].setFlag(0x0000000010000000)"
  xpos 1608
  ypos 1000
  addUserKnob {20 DummyCam l Defaults}
  addUserKnob {43 the_cam +INVISIBLE}
  the_cam "\[\n#DummyCam v1.3 - Updated 5 May 2021.\nset starting_point \"this.input0\"\nset default \"this.d_\"\n\n# If cam has no inputs, return the default.\nif \{\[exists \$starting_point]\} \{\n    set x \[node \$starting_point]\n\} \{ \n    return \$default\n\}\n\nset finished 0\nwhile \{\$finished != 1\} \{\n\n    # First look for a Cam or Input or topnode.\n    while \{\[class \$x] != \"Camera3\" && \[class \$x] != \"Camera2\" && \[class \$x] != \"Camera\" && \[class \$x] != \"Input\" && \$x != \[topnode \$x]\} \{\n        set x \[node \$x.input0]\n    \}\n\n    # Then, check if node is a cam (and return), and otherwise, if it's an input, see if the parent exists and move to it.\n    if \{\[class \$x]==\"Camera3\"||\[class \$x]==\"Camera2\"||\[class \$x]==\"Camera\"\} \{\n        set x \[append x \".\"]\n        return \$x\n    \} \{ \n        if \{ \[class \$x]==\"Input\" \} \{ \n            set inp \"\$x.parent.input\"\n            set inputNum \[value \$x.number]\n            set inp \[append inp \$inputNum]\n            if \{ \[exists \$inp] \} \{\n                set x \[node \$inp]\n            \} \{ \n                set finished 1\n            \}\n        \} \{ \n            set finished 1\n        \}\n    \}\n\}\nreturn \$default\n]"
  addUserKnob {43 the_frame +INVISIBLE}
  the_frame "\[\nset the_camera \[string trimright \[value the_cam] .]\nif \{\[exists \$the_camera]\} \{\n    return \[value \$the_camera.frame]\n\} \{ \n    return \[frame]\n\}\n]"
  addUserKnob {4 d_projection_mode l projection M {perspective orthographic uv spherical ""}}
  addUserKnob {7 d_focal l "focal length" R 0 100}
  d_focal 50
  addUserKnob {7 d_haperture l "horiz aperture" R 0 50}
  d_haperture 24.576
  addUserKnob {7 d_vaperture l "vert aperture" R 0 50}
  d_vaperture 18.672
  addUserKnob {7 d_near l near R 0 10}
  d_near 0.1
  addUserKnob {7 d_far l far R 0 10000}
  d_far 10000
  addUserKnob {30 d_win_translate l "window translate"}
  addUserKnob {30 d_win_scale l "window scale"}
  d_win_scale {1 1}
  addUserKnob {7 d_winroll l "window roll" R 0 45}
  addUserKnob {7 d_focal_point l "focal distance" R 0 10}
  d_focal_point 2
  addUserKnob {7 d_fstop l fstop R 0 30}
  d_fstop 16
  addUserKnob {26 version l " " t "Updated 5 May 2021" T "<span style=\"color:#666\"><br/><b>DummyCam v1.3</b> - <a href=\"http://www.adrianpueyo.com\" style=\"color:#666;text-decoration: none;\">adrianpueyo.com</a>, 2019-2021</span>"}
 }
 Constant {
  inputs 0
  channels rgb
  format {{{parent.format_.format}}}
  name Constant2
  xpos 1244
  ypos 940
 }
 Input {
  inputs 0
  name depth
  xpos 1419
  ypos 899
  number 1
 }
 Merge2 {
  inputs 2
  name Merge1
  xpos 1419
  ypos 963
 }
 Shuffle {
  in depth
  name shuffle
  xpos 1419
  ypos 1012
 }
 Reformat {
  format {{{parent.format_.format}}}
  name Reformat1
  xpos 1419
  ypos 1046
 }
 Dot {
  name Dot1
  xpos 1453
  ypos 1158
 }
 Constant {
  inputs 0
  channels {rgba.red rgba.green rgba.blue -rgba.alpha}
  name format_
  xpos 1755
  ypos 897
 }
 Noise {
  output {rgba.red -rgba.green -rgba.blue -rgba.alpha}
  type turbulence
  size 1
  zoffset 1.72
  lacunarity 1.6
  center {512 389}
  name Noise1
  xpos 1755
  ypos 968
 }
 Noise {
  output {-rgba.red rgba.green -rgba.blue -rgba.alpha}
  type turbulence
  size 1
  zoffset 1.82
  center {512 389}
  name Noise2
  xpos 1755
  ypos 992
 }
 Noise {
  output {-rgba.red -rgba.green rgba.blue -rgba.alpha}
  type turbulence
  size 1
  zoffset 4.12
  lacunarity 2.14
  center {512 389}
  name Noise3
  xpos 1755
  ypos 1016
 }
 Noise {
  output {-rgba.red -rgba.green -rgba.blue rgba.alpha}
  type turbulence
  size 1
  zoffset 0.14
  lacunarity 2.14
  center {512 389}
  name Noise4
  xpos 1755
  ypos 1042
 }
 BlinkScript {
  kernelSourceFile /home/ob1/software/nuke/dev/fog/src/blink/kernels/random.cpp
  recompileCount 17
  ProgramGroup 1
  KernelDescription "2 \"Random\" iterate pixelWise 83d854fc4140a8394df2a57f56300e5490ae783e47e494182e2e8e1538bf9da5 2 \"seed\" Read Point \"dst\" Write Point 1 \"Inclusive Range\" Float 2 AAAAAAAAgD8= 1 \"_inclusiveRange\" 2 1 1 \"__rangeLength\" Float 1 1 AAAAAA=="
  kernelSource "// Copyright 2022 by Owen Bulka.\n// All rights reserved.\n// This file is released under the \"MIT License Agreement\".\n// Please see the LICENSE.md file that should have been included as part\n// of this package.\n\n\n/**\n * Compute the fractional portion of the value. Ex. 3.5 returns 0.5\n *\n * @arg value: The value to get the fractional portion of.\n *\n * @returns: The fractional portion of the value.\n */\ninline float fract(const float value)\n\{\n    return value - floor(value);\n\}\n\n\n/**\n * Get a random value on the interval \[0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval \[0, 1].\n */\ninline float4 random(const float4 &seed)\n\{\n    return float4(\n        fract(sin(75.19f * seed.x + 71.743f) * 7513.471f),\n        fract(sin(15.73f * seed.y + 113.591f) * 47453.553f),\n        fract(sin(7.37f * seed.z + 147.781f) * 8769.132f),\n        fract(sin(13.157f * seed.w + 71.743f) * 7513.471f)\n    );\n\}\n\n\nkernel Random : ImageComputationKernel<ePixelWise>\n\{\n    Image<eRead, eAccessPoint, eEdgeNone> seed; // the input image\n    Image<eWrite> dst; // the output image\n\n\n    param:\n        float2 _inclusiveRange;\n\n    local:\n        float __rangeLength;\n\n\n    /**\n     * Give the parameters labels and default values.\n     */\n    void define()\n    \{\n        defineParam(_inclusiveRange, \"Inclusive Range\", float2(0, 1));\n    \}\n\n\n    /**\n     * Initialize the local variables.\n     */\n    void init()\n    \{\n        __rangeLength = _inclusiveRange.y - _inclusiveRange.x;\n    \}\n\n\n    /**\n     * Compute a random pixel value.\n     */\n    void process(int2 pos)\n    \{\n        dst() = _inclusiveRange.x + __rangeLength * random(\n            seed() + float4(pos.x, pos.y, pos.x, pos.y)\n        );\n    \}\n\};\n"
  rebuild ""
  rebuild_finalise ""
  name BlinkScript7
  xpos 1755
  ypos 1080
 }
 BlinkScript {
  inputs 2
  kernelSourceFile /home/ob1/software/nuke/dev/fog/src/blink/kernels/blink_fog_3d.cpp
  recompileCount 129
  ProgramGroup 1
  KernelDescription "2 \"FogKernel\" iterate pixelWise 26e074011eb36077d1a1cfa09aec90fb9d1005908c14da0cd3516e22eb5b5d51 3 \"noise\" Read Point \"depthAOV\" Read Point \"dst\" Write Point 27 \"Focal Length\" Float 1 AABIQg== \"Horizontal Aperture\" Float 1 ppvEQQ== \"Near Plane\" Float 1 zczMPQ== \"Far Plane\" Float 1 AEAcRg== \"Camera World Matrix\" Float 16 AACAPwAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAPw== \"Focal Distance\" Float 1 AACAQA== \"fstop\" Float 1 AACAQQ== \"Enable Depth Of Field\" Bool 1 AQ== \"Output LatLong\" Bool 1 AA== \"Screen Width\" Float 1 AABwRQ== \"Screen Height\" Float 1 AAAHRQ== \"Rays Per Pixel\" Int 1 AQAAAA== \"Density\" Float 1 AACAPw== \"Samples Per Ray\" Int 1 BQAAAA== \"Sample Depth Ramp\" Float 4 AACgQAAAIEEAAHBBAACgQQ== \"Size\" Float 1 AACgQQ== \"Noise Type\" Int 1 AAAAAA== \"Translation\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"Octaves\" Float 1 AAAAQQ== \"Lacunarity\" Float 1 AABAQA== \"Gain\" Float 1 AAAAPw== \"Gamma\" Float 1 AAAAPw== \"Low Frequency Scale\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"High Frequency Scale\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"Low Frequency Translation\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"High Frequency Translation\" Float 4 AAAAAAAAAAAAAAAAAAAAAA== \"Invert Depth\" Bool 1 AA== 27 \"_focalLength\" 1 1 \"_horizontalAperture\" 1 1 \"_nearPlane\" 1 1 \"_farPlane\" 1 1 \"_cameraWorldMatrix\" 16 1 \"_focalDistance\" 1 1 \"_fStop\" 1 1 \"_depthOfFieldEnabled\" 1 1 \"_latLong\" 1 1 \"_formatWidth\" 1 1 \"_formatHeight\" 1 1 \"_raysPerPixel\" 1 1 \"_density\" 1 1 \"_samplesPerRay\" 1 1 \"_depthRamp\" 4 1 \"_size\" 1 1 \"_noiseType\" 1 1 \"_translation\" 3 1 \"_octaves\" 1 1 \"_lacunarity\" 1 1 \"_gain\" 1 1 \"_gamma\" 1 1 \"_lowFrequencyScale\" 4 1 \"_highFrequencyScale\" 4 1 \"_lowFrequencyTranslation\" 4 1 \"_highFrequencyTranslation\" 4 1 \"_invertDepth\" 1 1 5 \"__inverseCameraProjectionMatrix\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"__aperture\" Float 1 1 AAAAAA== \"__simplex\" Int 1 256 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"__perm\" Int 1 512 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= \"__grad4\" Int 1 128 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
  kernelSource "// Copyright 2024 by Owen Bulka.\n// All rights reserved.\n// This file is released under the \"MIT License Agreement\".\n// Please see the LICENSE.md file that should have been included as part\n// of this package.\n\n\n//\n// Math operations\n//\n\n\n/**\n * Compute the fractional portion of the value. Ex. 3.5 returns 0.5\n *\n * @arg value: The value to get the fractional portion of.\n *\n * @returns: The fractional portion of the value.\n */\ninline float fract(const float value)\n\{\n    return value - floor(value);\n\}\n\n\n/**\n * Multiply a 4d vector by a 4x4 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline void matmul(const float4x4 &m, const float4 &v, float4 &out)\n\{\n    for (int i=0; i < 4; i++)\n    \{\n        out\[i] = 0;\n\n        for (int j=0; j < 4; j++)\n        \{\n            out\[i] += m\[i]\[j] * v\[j];\n        \}\n    \}\n\}\n\n\n/**\n * Multiply a 4d vector by a 4x4 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline float4 matmul(const float4x4 &m, const float4 &v)\n\{\n    float4 out;\n    for (int i=0; i < 4; i++)\n    \{\n        out\[i] = 0;\n\n        for (int j=0; j < 4; j++)\n        \{\n            out\[i] += m\[i]\[j] * v\[j];\n        \}\n    \}\n\n    return out;\n\}\n\n\n/**\n * Multiply a 3d vector by a 3x3 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline float3 matmul(const float3x3 &m, const float3 &v)\n\{\n    return float3(\n        m\[0]\[0] * v.x + m\[0]\[1] * v.y + m\[0]\[2] * v.z,\n        m\[1]\[0] * v.x + m\[1]\[1] * v.y + m\[1]\[2] * v.z,\n        m\[2]\[0] * v.x + m\[2]\[1] * v.y + m\[2]\[2] * v.z\n    );\n\}\n\n\n/**\n * Convert the uv position in a latlong image to angles.\n *\n * @arg uvPosition: The UV position.\n *\n * @returns: The equivalent angles in radians.\n */\ninline float2 uvPositionToAngles(const float2 &uvPosition)\n\{\n    return float2(\n        (uvPosition.x + 1.0f) * PI,\n        (1.0f - uvPosition.y) * PI / 2.0f\n    );\n\}\n\n\n/**\n * Convert location of a pixel in an image into UV.\n *\n * @arg pixelLocation: The x, and y positions of the pixel.\n * @arg format: The image width, and height.\n *\n * @returns: The UV position.\n */\ninline float2 pixelsToUV(const float2 &pixelLocation, const float2 &format)\n\{\n    return float2(\n        2.0f * pixelLocation.x / format.x - 1.0f,\n        2.0f * pixelLocation.y / format.y - 1.0f\n    );\n\}\n\n\n/**\n * Convert a spherical unit vector (unit radius) to cartesion.\n *\n * @arg angles: The spherical angles in radians.\n *\n * @returns: The equivalent cartesion vector.\n */\ninline float3 sphericalUnitVectorToCartesion(const float2 &angles)\n\{\n    const float sinPhi = sin(angles.y);\n    return float3(\n        cos(angles.x) * sinPhi,\n        cos(angles.y),\n        sin(angles.x) * sinPhi\n    );\n\}\n\n\n/**\n * Get the position component of a world matrix.\n *\n * @arg worldMatrix: The world matrix.\n * @arg position: The location to store the position.\n */\ninline void positionFromWorldMatrix(const float4x4 &worldMatrix, float3 &position)\n\{\n    position = float3(\n        worldMatrix\[0]\[3],\n        worldMatrix\[1]\[3],\n        worldMatrix\[2]\[3]\n    );\n\}\n\n\n/**\n * Get the rotation component of a world matrix.\n *\n * @arg worldMatrix: The world matrix.\n * @arg rotation: The location to store the rotation.\n */\ninline void rotationFromWorldMatrix(const float4x4 &worldMatrix, float3x3 &rotationMatrix)\n\{\n    rotationMatrix\[0]\[0] = worldMatrix\[0]\[0];\n    rotationMatrix\[0]\[1] = worldMatrix\[0]\[1];\n    rotationMatrix\[0]\[2] = worldMatrix\[0]\[2];\n    rotationMatrix\[1]\[0] = worldMatrix\[1]\[0];\n    rotationMatrix\[1]\[1] = worldMatrix\[1]\[1];\n    rotationMatrix\[1]\[2] = worldMatrix\[1]\[2];\n    rotationMatrix\[2]\[0] = worldMatrix\[2]\[0];\n    rotationMatrix\[2]\[1] = worldMatrix\[2]\[1];\n    rotationMatrix\[2]\[2] = worldMatrix\[2]\[2];\n\}\n\n\n//\n// Randomization functions\n//\n\n\n// Some random constants on the interval \[1, 2]\n#define RAND_CONST_0 1.571411510193971f\n#define RAND_CONST_1 1.268632820084931f\n#define RAND_CONST_2 1.7880365647937733f\n#define RAND_CONST_3 1.3546987471558234f\n#define RAND_CONST_4 1.4365958250848703f\n#define RAND_CONST_5 1.7045380669435368f\n\n\n/**\n * Get a random value on the interval \[0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval \[0, 1].\n */\ninline float random(const float seed)\n\{\n    return fract(sin(73.1f * seed + 91.3458f) * 47453.5453f);\n\}\n\n\n/**\n * Get a random value on the interval \[0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval \[0, 1].\n */\ninline float2 random(const float2 &seed)\n\{\n    return float2(\n        fract(sin(13.157f * seed.x + 71.743f) * 7513.471f),\n        fract(sin(97.519f * seed.y + 113.591f) * 47453.5453f)\n    );\n\}\n\n\n/**\n * Create a random point that lies within the unit circle.\n *\n * @arg seed: The random seed.\n *\n * @returns: A random point, (radius, angle) in the unit circle.\n */\ninline float2 uniformPointInUnitCircle(const float2 &seed)\n\{\n    return float2(sqrt(random(seed.x)), 2.0f * PI * random(seed.y));\n\}\n\n\n/**\n * Sum the elements of a vector.\n *\n * @arg vector: The vector to sum the elements of.\n *\n * @returns: The sum of the vector elements.\n */\ninline float element_sum(const float4 &vector) \{\n    return vector.x + vector.y + vector.z + vector.w;\n\}\n\n\n#define FBM_NOISE 1\n\n\n//\n// Camera Utilities\n//\n\n\n/**\n * Compute the field of view from focal length.\n *\n * @arg focalLength: The focal length.\n *\n * @returns: The equivalent field of view.\n */\ninline float fieldOfView(const float focalLength)\n\{\n    return 2 * atan(1 / focalLength);\n\}\n\n\n/**\n * Compute the aspect ratio from image format.\n *\n * @arg height_: The height of the image.\n * @arg width_: The width of the image.\n *\n * @returns: The aspect ratio.\n */\ninline float aspectRatio(const float height_, const float width_)\n\{\n    return height_ / width_;\n\}\n\n\n/**\n *\n */\ninline float fStopToAperture(const float fStop, const float focalLength)\n\{\n    return focalLength / fStop / 1000.0f;\n\}\n\n\n/**\n * Create a projection matrix for a camera.\n *\n * @arg focalLength: The focal length of the camera.\n * @arg horizontalAperture: The horizontal aperture of the camera.\n * @arg aspect: The aspect ratio of the camera.\n * @arg nearPlane: The distance to the near plane of the camera.\n * @arg farPlane: The distance to the far plane of the camera.\n *\n * @returns: The camera's projection matrix.\n */\nfloat4x4 projectionMatrix(\n        const float focalLength,\n        const float horizontalAperture,\n        const float aspect,\n        const float nearPlane,\n        const float farPlane)\n\{\n    float farMinusNear = farPlane - nearPlane;\n    return float4x4(\n        2 * focalLength / horizontalAperture, 0, 0, 0,\n        0, 2 * focalLength / horizontalAperture / aspect, 0, 0,\n        0, 0, -(farPlane + nearPlane) / farMinusNear, -2 * (farPlane * nearPlane) / farMinusNear,\n        0, 0, -1, 0\n    );\n\}\n\n\n/**\n * Generate a ray out of a camera.\n *\n * @arg cameraWorldMatrix: The camera matrix.\n * @arg inverseProjectionMatrix: The inverse of the projection matrix.\n * @arg uvPosition: The UV position in the resulting image.\n * @arg rayOrigin: Will store the origin of the ray.\n * @arg rayDirection: Will store the direction of the ray.\n */\nvoid createCameraRay(\n        const float4x4 &cameraWorldMatrix,\n        const float4x4 &inverseProjectionMatrix,\n        const float2 &uvPosition,\n        float3 &rayOrigin,\n        float3 &rayDirection)\n\{\n    positionFromWorldMatrix(cameraWorldMatrix, rayOrigin);\n    float4 direction = matmul(\n        inverseProjectionMatrix,\n        float4(uvPosition.x, uvPosition.y, 0, 1)\n    );\n    matmul(\n        cameraWorldMatrix,\n        float4(direction.x, direction.y, direction.z, 0),\n        direction\n    );\n    rayDirection = normalize(float3(direction.x, direction.y, direction.z));\n\}\n\n\n/**\n * Generate a ray out of a camera.\n *\n * @arg cameraWorldMatrix: The camera matrix.\n * @arg inverseProjectionMatrix: The inverse of the projection matrix.\n * @arg uvPosition: The UV position in the resulting image.\n * @arg rayOrigin: Will store the origin of the ray.\n * @arg rayDirection: Will store the direction of the ray.\n */\nvoid createCameraRay(\n        const float4x4 &cameraWorldMatrix,\n        const float4x4 &inverseProjectionMatrix,\n        const float2 &uvPosition,\n        const float aperture,\n        const float focalDistance,\n        const float2 &seed,\n        float3 &rayOrigin,\n        float3 &rayDirection)\n\{\n    createCameraRay(\n        cameraWorldMatrix,\n        inverseProjectionMatrix,\n        uvPosition,\n        rayOrigin,\n        rayDirection\n    );\n\n    const float4 cameraForward4 = matmul(\n        cameraWorldMatrix,\n        float4(0, 0, -1, 0)\n    );\n    const float3 cameraForward = float3(\n        cameraForward4.x,\n        cameraForward4.y,\n        cameraForward4.z\n    );\n    const float4 cameraRight4 = matmul(\n        cameraWorldMatrix,\n        float4(1, 0, 0, 0)\n    );\n    const float3 cameraRight = float3(\n        cameraRight4.x,\n        cameraRight4.y,\n        cameraRight4.z\n    );\n    const float4 cameraUp4 = matmul(\n        cameraWorldMatrix,\n        float4(0, 1, 0, 0)\n    );\n    const float3 cameraUp = float3(\n        cameraUp4.x,\n        cameraUp4.y,\n        cameraUp4.z\n    );\n\n    const float3 focalPlanePoint = rayOrigin + cameraForward * focalDistance;\n    const float3 focalPlaneNormal = -cameraForward;\n\n    const float focalPointDistance = (\n        (dot(focalPlaneNormal, focalPlanePoint) - dot(rayOrigin, focalPlaneNormal))\n        / dot(rayDirection, focalPlaneNormal)\n    );\n    const float3 focalPoint = rayOrigin + focalPointDistance * rayDirection;\n\n    const float2 pointInUnitCircle = uniformPointInUnitCircle(seed);\n    const float2 offset = pointInUnitCircle.x * aperture * float2(\n        cos(pointInUnitCircle.y),\n        sin(pointInUnitCircle.y)\n    );\n\n    rayOrigin += cameraRight * offset.x + cameraUp * offset.y;\n    rayDirection = normalize(focalPoint - rayOrigin);\n\}\n\n\n/**\n * Generate a LatLong ray out of a camera.\n *\n * @arg cameraWorldMatrix: The camera matrix.\n * @arg uvPosition: The UV position in the resulting image.\n * @arg rayOrigin: Will store the origin of the ray.\n * @arg rayDirection: Will store the direction of the ray.\n */\nvoid createLatLongCameraRay(\n        const float4x4 &cameraWorldMatrix,\n        const float2 &uvPosition,\n        float3 &rayOrigin,\n        float3 &rayDirection)\n\{\n    positionFromWorldMatrix(cameraWorldMatrix, rayOrigin);\n    rayDirection = sphericalUnitVectorToCartesion(uvPositionToAngles(uvPosition));\n\n    float3x3 cameraRotation;\n    rotationFromWorldMatrix(cameraWorldMatrix, cameraRotation);\n    rayDirection = matmul(cameraRotation, rayDirection);\n\}\n\n\n\nkernel FogKernel : ImageComputationKernel<ePixelWise>\n\{\n    // the input which specifies the format, process is called once per pixel\n    // in this image, which also provides random seeds\n    Image<eRead, eAccessPoint, eEdgeNone> noise;\n    Image<eRead, eAccessPoint, eEdgeClamped> depthAOV;\n\n    // the output image\n    Image<eWrite> dst;\n\n\n    param:\n        // These parameters are made available to the user.\n\n        // Camera params\n        float _focalLength;\n        float _horizontalAperture;\n        float _nearPlane;\n        float _farPlane;\n        float4x4 _cameraWorldMatrix;\n        float _focalDistance;\n        float _fStop;\n        bool _depthOfFieldEnabled;\n        bool _latLong;\n\n        // Image params\n        float _formatWidth;\n        float _formatHeight;\n        int _raysPerPixel;\n        float _density;\n        int _samplesPerRay;\n        float4 _depthRamp;\n\n        // Noise Parameters\n        float _size;\n        int _noiseType;\n        float3 _translation;\n        float _octaves;\n        float _lacunarity;\n        float _gain;\n        float _gamma;\n        float4 _lowFrequencyScale;\n        float4 _highFrequencyScale;\n        float4 _lowFrequencyTranslation;\n        float4 _highFrequencyTranslation;\n\n        bool _invertDepth;\n\n    local:\n        // These local variables are not exposed to the user.\n        float4x4 __inverseCameraProjectionMatrix;\n        float __aperture;\n\n        int __simplex\[64]\[4];\n        int __perm\[512];\n        int __grad4\[32]\[4];\n\n    /**\n     * Give the parameters labels and default values.\n     */\n    void define()\n    \{\n        // Camera params\n        defineParam(_focalLength, \"Focal Length\", 50.0f);\n        defineParam(_horizontalAperture, \"Horizontal Aperture\", 24.576f);\n        defineParam(_nearPlane, \"Near Plane\", 0.1f);\n        defineParam(_farPlane, \"Far Plane\", 10000.0f);\n        defineParam(\n            _cameraWorldMatrix,\n            \"Camera World Matrix\",\n            float4x4(\n                1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1\n            )\n        );\n        defineParam(_focalDistance, \"Focal Distance\", 4.0f);\n        defineParam(_fStop, \"fstop\", 16.0f);\n        defineParam(_depthOfFieldEnabled, \"Enable Depth Of Field\", true);\n        defineParam(_latLong, \"Output LatLong\", false);\n\n        // Image params\n        defineParam(_formatHeight, \"Screen Height\", 2160.0f);\n        defineParam(_formatWidth, \"Screen Width\", 3840.0f);\n        defineParam(_density, \"Density\", 1.0f);\n        defineParam(_raysPerPixel, \"Rays Per Pixel\", 1);\n        defineParam(_samplesPerRay, \"Samples Per Ray\", 5);\n        defineParam(_depthRamp, \"Sample Depth Ramp\", float4(5.0f, 10.0f, 15.0f, 20.0f));\n\n        // Noise Parameters\n        defineParam(_size, \"Size\", 20.0f);\n        defineParam(_noiseType, \"Noise Type\", 0);\n        defineParam(_translation, \"Translation\", float3(0.0f, 0.0f, 0.0f));\n        defineParam(_octaves, \"Octaves\", 8.0f);\n        defineParam(_lacunarity, \"Lacunarity\", 3.0f);\n        defineParam(_gain, \"Gain\", 0.5f);\n        defineParam(_gamma, \"Gamma\", 0.5f);\n        defineParam(_lowFrequencyScale, \"Low Frequency Scale\", float4(0.0f, 0.0f, 0.0f, 0.0f));\n        defineParam(_highFrequencyScale, \"High Frequency Scale\", float4(0.0f, 0.0f, 0.0f, 0.0f));\n        defineParam(_lowFrequencyTranslation, \"Low Frequency Translation\", float4(0.0f, 0.0f, 0.0f, 0.0f));\n        defineParam(_highFrequencyTranslation, \"High Frequency Translation\", float4(0.0f, 0.0f, 0.0f, 0.0f));\n        defineParam(_invertDepth, \"Invert Depth\", false);\n    \}\n\n\n    /**\n     * Initialize the local variables.\n     */\n    void init()\n    \{\n        const float aspect = aspectRatio(_formatHeight, _formatWidth);\n        float4x4 cameraProjectionMatrix = projectionMatrix(\n            _focalLength,\n            _horizontalAperture,\n            aspect,\n            _nearPlane,\n            _farPlane\n        );\n        __inverseCameraProjectionMatrix = cameraProjectionMatrix.invert();\n\n        __aperture = fStopToAperture(_fStop, _focalLength);\n\n        const int simplexInit\[64]\[4] = \{\n            \{0, 1, 2, 3\}, \{0, 1, 3, 2\}, \{0, 0, 0, 0\}, \{0, 2, 3, 1\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{1, 2, 3, 0\},\n            \{0, 2, 1, 3\}, \{0, 0, 0, 0\}, \{0, 3, 1, 2\}, \{0, 3, 2, 1\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{1, 3, 2, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{1, 2, 0, 3\}, \{0, 0, 0, 0\}, \{1, 3, 0, 2\}, \{0, 0, 0, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{2, 3, 0, 1\}, \{2, 3, 1, 0\},\n            \{1, 0, 2, 3\}, \{1, 0, 3, 2\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{0, 0, 0, 0\}, \{2, 0, 3, 1\}, \{0, 0, 0, 0\}, \{2, 1, 3, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{2, 0, 1, 3\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{3, 0, 1, 2\}, \{3, 0, 2, 1\}, \{0, 0, 0, 0\}, \{3, 1, 2, 0\},\n            \{2, 1, 0, 3\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\}, \{0, 0, 0, 0\},\n            \{3, 1, 0, 2\}, \{0, 0, 0, 0\}, \{3, 2, 0, 1\}, \{3, 2, 1, 0\}\n        \};\n\n        for (int i = 0; i < 64; i++)\n        \{\n            for (int j = 0; j < 4; j++)\n            \{\n                __simplex\[i]\[j] = simplexInit\[i]\[j];\n            \}\n        \}\n\n        const int permInit\[256] = \{\n            151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233,\n            7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23,\n            190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219,\n            203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174,\n            20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48,\n            27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133,\n            230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65,\n            25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18,\n            169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198,\n            173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147,\n            118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17,\n            182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44,\n            154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22,\n            39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112,\n            104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12,\n            191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49,\n            192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121,\n            50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29,\n            24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180\n        \};\n\n        for (int i = 0; i < 512; i++)\n        \{\n            __perm\[i] = permInit\[i % 256];\n        \}\n\n        const int grad4Init\[32]\[4]= \{\n            \{0, 1, 1, 1\},  \{0, 1, 1, -1\},  \{0, 1, -1, 1\},  \{0, 1, -1, -1\},\n            \{0, -1, 1, 1\}, \{0, -1, 1, -1\}, \{0, -1, -1, 1\}, \{0, -1, -1, -1\},\n            \{1, 0, 1, 1\},  \{1, 0, 1, -1\},  \{1, 0, -1, 1\},  \{1, 0, -1, -1\},\n            \{-1, 0, 1, 1\}, \{-1, 0, 1, -1\}, \{-1, 0, -1, 1\}, \{-1, 0, -1, -1\},\n            \{1, 1, 0, 1\},  \{1, 1, 0, -1\},  \{1, -1, 0, 1\},  \{1, -1, 0, -1\},\n            \{-1, 1, 0, 1\}, \{-1, 1, 0, -1\}, \{-1, -1, 0, 1\}, \{-1, -1, 0, -1\},\n            \{1, 1, 1, 0\},  \{1, 1, -1, 0\},  \{1, -1, 1, 0\},  \{1, -1, -1, 0\},\n            \{-1, 1, 1, 0\}, \{-1, 1, -1, 0\}, \{-1, -1, 1, 0\}, \{-1, -1, -1, 0\}\n        \};\n\n        for (int i = 0; i < 32; i++)\n        \{\n            for (int j = 0; j < 4; j++)\n            \{\n                __grad4\[i]\[j] = grad4Init\[i]\[j];\n            \}\n        \}\n    \}\n\n    /**\n     * 4D Perlin simplex noise\n     *\n     * Copyright (c) 2007-2012 Eliot Eshelman\n     *\n     * This program is free software: you can redistribute it and/or modify\n     * it under the terms of the GNU General Public License as published by\n     * the Free Software Foundation, either version 3 of the License, or\n     * (at your option) any later version.\n     *\n     * This program is distributed in the hope that it will be useful,\n     * but WITHOUT ANY WARRANTY; without even the implied warranty of\n     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n     * GNU General Public License for more details.\n     *\n     * You should have received a copy of the GNU General Public License\n     * along with this program. If not, see <http://www.gnu.org/licenses/>.\n     *\n     * @arg seed: The seed for the noise.\n     * @arg simplex: The simplex LUT.\n     * @arg perm: The perm LUT.\n     * @arg grad4: The grad4 LUT.\n     *\n     * @returns: Noise value in the range \[-1, 1], value of 0 on all integer\n     *     coordinates.\n     */\n    inline float perlinSimplexNoise(\n            const float4 &seed\n    )\n    \{\n        const float G4 = 0.138196601f;\n        const float4 i = floor(seed + element_sum(seed) * 0.309016994f);\n        const float4 x0 = seed - i + element_sum(i) * G4;\n\n        const int c = (\n            ((x0.x > x0.y) << 5)\n            | ((x0.x > x0.z) << 4)\n            | ((x0.y > x0.z) << 3)\n            | ((x0.x > x0.w) << 2)\n            | ((x0.y > x0.w) << 1)\n            | (x0.z > x0.w)\n        );\n        const int4 i1 = int4(\n            __simplex\[c]\[0] >= 3,\n            __simplex\[c]\[1] >= 3,\n            __simplex\[c]\[2] >= 3,\n            __simplex\[c]\[3] >= 3\n        );\n        const int4 i2 = int4(\n            __simplex\[c]\[0] >= 2,\n            __simplex\[c]\[1] >= 2,\n            __simplex\[c]\[2] >= 2,\n            __simplex\[c]\[3] >= 2\n        );\n        const int4 i3 = int4(\n            __simplex\[c]\[0] >= 1,\n            __simplex\[c]\[1] >= 1,\n            __simplex\[c]\[2] >= 1,\n            __simplex\[c]\[3] >= 1\n        );\n\n        const float4 x1 = x0 - float4(i1.x, i1.y, i1.z, i1.w) + G4;\n        const float4 x2 = x0 - float4(i2.x, i2.y, i2.z, i2.w) + 2.0f * G4;\n        const float4 x3 = x0 - float4(i3.x, i3.y, i3.z, i3.w) + 3.0f * G4;\n        const float4 x4 = x0 - 1.0f + 4.0f * G4;\n\n        const int ii = (int) i.x & 255;\n        const int jj = (int) i.y & 255;\n        const int kk = (int) i.z & 255;\n        const int ll = (int) i.w & 255;\n\n        const int gi0 = __perm\[\n            ii + __perm\[jj + __perm\[kk + __perm\[ll]]]\n        ] % 32;\n        const int gi1 = __perm\[\n            ii + i1.x + __perm\[jj + i1.y + __perm\[kk + i1.z + __perm\[ll + i1.w]]]\n        ] % 32;\n        const int gi2 = __perm\[\n            ii + i2.x + __perm\[jj + i2.y + __perm\[kk + i2.z + __perm\[ll + i2.w]]]\n        ] % 32;\n        const int gi3 = __perm\[\n            ii + i3.x + __perm\[jj + i3.y + __perm\[kk + i3.z + __perm\[ll + i3.w]]]\n        ] % 32;\n        const int gi4 = __perm\[\n            ii + 1 + __perm\[jj + 1 + __perm\[kk + 1 + __perm\[ll + 1]]]\n        ] % 32;\n\n        float n0, n1, n2, n3, n4;\n        float t0 = 0.6f - dot(x0, x0);\n        if (t0 < 0)\n        \{\n            n0 = 0.0f;\n        \}\n        else\n        \{\n            t0 *= t0;\n            n0 = t0 * t0 * dot(\n                float4(__grad4\[gi0]\[0], __grad4\[gi0]\[2], __grad4\[gi0]\[3], __grad4\[gi0]\[3]),\n                x0\n            );\n        \}\n\n        float t1 = 0.6f - dot(x1, x1);\n        if (t1 < 0)\n        \{\n            n1 = 0.0f;\n        \}\n        else\n        \{\n            t1 *= t1;\n            n1 = t1 * t1 * dot(\n                float4(__grad4\[gi1]\[0], __grad4\[gi1]\[2], __grad4\[gi1]\[3], __grad4\[gi1]\[3]),\n                x1\n            );\n        \}\n\n        float t2 = 0.6f - dot(x2, x2);\n        if (t2 < 0)\n        \{\n            n2 = 0.0f;\n        \}\n        else\n        \{\n            t2 *= t2;\n            n2 = t2 * t2 * dot(\n                float4(__grad4\[gi2]\[0], __grad4\[gi2]\[2], __grad4\[gi2]\[3], __grad4\[gi2]\[3]),\n                x2\n            );\n        \}\n\n        float t3 = 0.6f - dot(x3, x3);\n        if (t3 < 0)\n        \{\n            n3 = 0.0f;\n        \}\n        else\n        \{\n            t3 *= t3;\n            n3 = t3 * t3 * dot(\n                float4(__grad4\[gi3]\[0], __grad4\[gi3]\[2], __grad4\[gi3]\[3], __grad4\[gi3]\[3]),\n                x3\n            );\n        \}\n\n        float t4 = 0.6f - dot(x4, x4);\n        if (t4 < 0)\n        \{\n            n4 = 0.0f;\n        \}\n        else \{\n            t4 *= t4;\n            n4 = t4 * t4 * dot(\n                float4(__grad4\[gi4]\[0], __grad4\[gi4]\[2], __grad4\[gi4]\[3], __grad4\[gi4]\[3]),\n                x4\n            );\n        \}\n\n        return 27.0f * (n0 + n1 + n2 + n3 + n4);\n    \}\n\n\n    //\n    // Use the perlin simplex noise\n    //\n\n\n    /**\n     * fBM noise.\n     *\n     * @arg position: The position to seed the noise.\n     *\n     * @returns: The noise value in the range \[-1, 1].\n     */\n    float fractalBrownianMotionNoise(const float4 &position)\n    \{\n        float output = 0.0f;\n        float frequency = _lacunarity;\n        float amplitude = 1.0f;\n        float denom = 0.0f;\n        float4 translation;\n        float4 scale;\n\n        for (int octave=0; octave < _octaves; octave++)\n        \{\n            const float octaveFraction = octave / _octaves;\n            scale = (\n                (_highFrequencyScale * octaveFraction)\n                + (_lowFrequencyScale * (1.0f - octaveFraction))\n            );       \n            translation = (\n                (_highFrequencyTranslation * octaveFraction)\n                + (_lowFrequencyTranslation * (1.0f - octaveFraction))\n            );\n\n            output += amplitude * perlinSimplexNoise(\n                (position * scale + translation) * frequency / _size\n            );\n\n            frequency *= _lacunarity;\n            denom += amplitude;\n            amplitude *= _gain;\n        \}\n\n        return pow(fabs(output / denom), 1.0f / _gamma);\n    \}\n\n\n    /**\n     * Turbulence noise.\n     *\n     * @arg position: The position to seed the noise.\n     *\n     * @returns: The noise value in the range \[0, 1].\n     */\n    float turbulenceNoise(const float4 &position)\n    \{\n        float output = 0.0f;\n        float frequency = _lacunarity;\n        float amplitude = 1.0f;\n        float denom = 0.0f;\n        float4 translation;\n        float4 scale;\n\n        for (int octave=0; octave < _octaves; octave++)\n        \{\n            const float octaveFraction = octave / _octaves;\n            scale = (\n                (_highFrequencyScale * octaveFraction)\n                + (_lowFrequencyScale * (1.0f - octaveFraction))\n            );       \n            translation = (\n                (_highFrequencyTranslation * octaveFraction)\n                + (_lowFrequencyTranslation * (1.0f - octaveFraction))\n            );\n\n            output += fabs(\n                amplitude * perlinSimplexNoise(\n                    (position * scale + translation) * frequency / _size\n                )\n            );\n\n            frequency *= _lacunarity;\n            denom += amplitude;\n            amplitude *= _gain;\n        \}\n\n        return pow(output / denom, 1.0f / _gamma);\n    \}\n\n\n    /**\n     * Create a ray out of the camera. It will be either a standard ray,\n     * a latlong ray, or a ray that will result in depth of field.\n     *\n     * @arg seed: The seed to use in randomization.\n     * @arg pixelLocation: The x, and y locations of the pixel.\n     * @arg rayOrigin: The location to store the origin of the new ray.\n     * @arg rayDirection: The location to store the direction of the new\n     *     ray.\n     */\n    void getCameraRay(\n            const float2 &seed,\n            const float2 &pixelLocation,\n            float3 &rayOrigin,\n            float3 &rayDirection)\n    \{\n        const float2 uvCoordinates = pixelsToUV(\n            pixelLocation + random(seed),\n            float2(_formatWidth, _formatHeight)\n        );\n        if (_latLong)\n        \{\n            createLatLongCameraRay(\n                _cameraWorldMatrix,\n                uvCoordinates,\n                rayOrigin,\n                rayDirection\n            );\n        \}\n        else if (_depthOfFieldEnabled)\n        \{\n            createCameraRay(\n                _cameraWorldMatrix,\n                __inverseCameraProjectionMatrix,\n                uvCoordinates,\n                __aperture,\n                _focalDistance,\n                seed,\n                rayOrigin,\n                rayDirection\n            );\n        \}\n        else\n        \{\n            createCameraRay(\n                _cameraWorldMatrix,\n                __inverseCameraProjectionMatrix,\n                uvCoordinates,\n                rayOrigin,\n                rayDirection\n            );\n        \}\n    \}\n\n\n    /**\n     * Compute a raymarched pixel value.\n     *\n     * @arg pos: The x, and y location we are currently processing.\n     */\n    void process(int2 pos)\n    \{\n        float pixelDepth = depthAOV(0);\n        pixelDepth = (\n            pixelDepth > 0.0f ? (_invertDepth ? 1.0f / pixelDepth : pixelDepth) : _depthRamp.w\n        );\n\n        float2 pixelLocation = float2(pos.x, pos.y);\n        SampleType(noise) noisePixel = noise();\n        float2 seed0 = float2(noisePixel.x, noisePixel.y) + RAND_CONST_0 * pixelLocation;\n        float2 seed1 = float2(noisePixel.z, noisePixel.w) + RAND_CONST_1 * pixelLocation;\n\n        float4 resultPixel = float4(0.0f);\n\n        const float sampleStep = (_depthRamp.w - _depthRamp.x) / (float) _samplesPerRay;\n\n        for (int path=1; path <= _raysPerPixel; path++)\n        \{\n            // Generate a ray from the camera\n            float3 rayOrigin;\n            float3 rayDirection;\n            getCameraRay(\n                seed0,\n                pixelLocation,\n                rayOrigin,\n                rayDirection\n            );\n\n            float depth = _depthRamp.x;\n            rayOrigin += depth * rayDirection + _translation;\n\n            float invertedLastSample = 1.0f;\n            for (int step=0; step < _samplesPerRay; step++)\n            \{\n                depth += sampleStep;\n                if (depth > pixelDepth)\n                \{\n                    break;\n                \}\n                rayOrigin += rayDirection * sampleStep;\n\n                // Get the noise value based on which type of noise we are using\n                const float4 samplePosition4d = float4(\n                    rayOrigin.x,\n                    rayOrigin.y,\n                    rayOrigin.z,\n                    0.0f\n                );\n                float ramp;\n                if (depth < _depthRamp.y)\n                \{\n                    ramp = (depth - _depthRamp.y) / (_depthRamp.y - _depthRamp.x) + 1.0f;\n                \}\n                else if (depth >= _depthRamp.y && depth <= _depthRamp.z)\n                \{\n                    ramp = 1.0f;\n                \}\n                else\n                \{\n                    ramp = (_depthRamp.w - depth) / (_depthRamp.w - _depthRamp.z);\n                \}\n\n                float noiseValue = _density * ramp;\n                if (_noiseType == FBM_NOISE)\n                \{\n                    noiseValue *= fractalBrownianMotionNoise(samplePosition4d);\n                \}\n                else\n                \{\n                    noiseValue *= turbulenceNoise(samplePosition4d);\n                \}\n\n                resultPixel += noiseValue * invertedLastSample;\n                invertedLastSample *= 1.0f - noiseValue;\n            \}\n\n            const float2 lastSeed = seed0;\n            seed0 = RAND_CONST_2 * float2(seed1.y, seed1.x) + RAND_CONST_3 * path;\n            seed1 = RAND_CONST_4 * lastSeed + RAND_CONST_5 * path;\n        \}\n\n        dst() = resultPixel / float(_raysPerPixel);\n    \}\n\};\n"
  rebuild ""
  "FogKernel_Focal Length" {{parent.DummyCam.focal}}
  "FogKernel_Horizontal Aperture" {{parent.DummyCam.haperture}}
  "FogKernel_Near Plane" {{parent.DummyCam.near}}
  "FogKernel_Far Plane" {{parent.DummyCam.far}}
  "FogKernel_Camera World Matrix" {
      {{parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix}}
      {{parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix}}
      {{parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix}}
      {{parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix} {parent.DummyCam.world_matrix}}
    }
  "FogKernel_Focal Distance" {{parent.DummyCam.focal_point}}
  FogKernel_fstop {{parent.DummyCam.fstop}}
  "FogKernel_Enable Depth Of Field" {{parent.depth_of_field}}
  "FogKernel_Output LatLong" {{parent.latlong}}
  "FogKernel_Screen Width" {{input0.width}}
  "FogKernel_Screen Height" {{input0.height}}
  "FogKernel_Rays Per Pixel" {{parent.rays_per_pixel}}
  FogKernel_Density {{parent.density}}
  "FogKernel_Samples Per Ray" {{parent.samples_per_ray}}
  "FogKernel_Sample Depth Ramp" {{parent.Keyer1.range.A} {parent.Keyer1.range.B} {parent.Keyer1.range.C} {parent.Keyer1.range.D}}
  FogKernel_Size {{parent.size}}
  "FogKernel_Noise Type" {{parent.type}}
  FogKernel_Translation {{-parent.translation} {-parent.translation} {-parent.translation}}
  FogKernel_Octaves {{parent.octaves}}
  FogKernel_Lacunarity {{parent.lacunarity}}
  FogKernel_Gain {{parent.gain}}
  FogKernel_Gamma {{parent.gamma}}
  "FogKernel_Low Frequency Scale" {{parent.low_frequency_scale} {parent.low_frequency_scale} {parent.low_frequency_scale} {parent.low_frequency_scale}}
  "FogKernel_High Frequency Scale" {{parent.high_frequency_scale} {parent.high_frequency_scale} {parent.high_frequency_scale} {parent.high_frequency_scale}}
  "FogKernel_Low Frequency Translation" {{parent.low_frequency_translation} {parent.low_frequency_translation} {parent.low_frequency_translation} {parent.low_frequency_translation}}
  "FogKernel_High Frequency Translation" {{parent.high_frequency_translation} {parent.high_frequency_translation} {parent.high_frequency_translation} {parent.high_frequency_translation}}
  "FogKernel_Invert Depth" {{parent.invert_depth}}
  rebuild_finalise ""
  name BlinkScript1
  xpos 1755
  ypos 1148
 }
 Output {
  name Output1
  xpos 1755
  ypos 1314
 }
 Keyer {
  inputs 0
  operation "luminance key"
  range {7 8 12 13}
  name Keyer1
  xpos 1982
  ypos 979
 }
end_group
